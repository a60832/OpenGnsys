#!/bin/bash
###########################################################
#####librerias de ATA v0.0.8r5 para Advanced Deploy enViorenment###########
# Liberado bajo licencia GPL <http://www.gnu.org/licenses/gpl.html>################
############# 2008 Antonio Doblas Viso   adv@uma.es ##########################
########### Universidad de Malaga (Spain)############################
##########################################################

export temporal=/tmp/temporal
######### 

function UpdateDisk ()
# requiere partprobe
{
Msg "Forzando al kernel la lectura de la tabla de particiones" info
list=`partprobe -sd | cut -f1 -d: ` 2>/dev/null 
echo $list > /tmp/disk
}

function DetectDevices () {
#requiere lshw
lshw -short -C disk > $temporal
z=0
for i in `cat $temporal | awk '/GB/ {print $2}' | sort`
do
	export disco$z=$i
	#tam=`lshw -short -C disk | grep $i | awk '{print $4}'`
	tam=`grep $i $temporal | awk '{print $4}'`
	Msg "HDsata/ata/usb en $i capacidad: $tam  acesible como disco$z" result
	z=$[$z+1]
done 
z=0
for i in `cat $temporal | sed -e '1,2d' | awk '! /GB/ {print $2}' | uniq |sort`
do
	export cdrom$z=$i
	Msg "cd/dvd encontrado en $i accesible como cdrom$z" result
	z=$[$z+1]
done
rm -fr $temporal
}

function DetectNumberPartition () {
disco=`Disk $1`
totalpart=`parted $disco print | egrep ^" [0123456789] " -c`
echo $totalpart
}

function FindCache () {
# requiere parted fdisk Disk
if [ $# != 0 ]
then 	
	Msg "FindCache detecta la particion tipo a7 o aquella que tenga el label CACHE" info
	Msg "devuelve /dev/sda3" info2
	Msg "sintaxis: FindCache   --- Ejemplo: FindCache -> /dev/sda3/ " example
	return 
fi
end=`Disk | wc -w`
unset cache
for (( disk = 1; disk <= $end; disk++))
do	
	disco=`Disk $disk`
	totalpart=`parted $disco print | egrep ^" [0123456789] " -c`
	#echo $disco
	if [ `fdisk -l $disco | egrep ^/dev | grep a7 | cut -f1 -d" "` ]
	then 
		#echo comprobando si es particion a7
		cache=`fdisk -l $disco | egrep ^/dev | grep a7 | cut -f1 -d" "`
	else
		#echo comprobando si existe la etiqueta cache
		if ls -R /dev/disk/ | grep CACHE > /dev/null
		then 
			devcache=`ls -ls /dev/disk/by-label/CACHE | awk -F..\/..\/ '{print $2}'`
			cache=/dev/$devcache 
		fi
	fi
done
if [ -n "$cache" ]
then
	echo $cache
else
	return 1
fi
}


function Disk () {
# traduce los ID EAC Disk a Linux:
# 0 parametros:  devuelve los nombre de los dispositivos sata/ata/usb linux encontrados: /dev/sda  /dev/sdb, 
# 1 paramtero (int_disk): devuelve el nombre del dispositivo. Disk 1 -> /dev/sda
# 2 parametros (int_disk int_partition): devuelve el nombre de la particiion- Disk 2 1 -> /dev/sdb1
list=`awk '($1==3 || $1==8) && $4!~/[0-9]/ {printf "/dev/%s ",$4}' /proc/partitions`  # Ramón Gómez Universidad Sevilla. Proyecto Hidra
countlist=`echo $list | wc -w`
if [ $# = 0 ]
then 
	echo $list
fi
# (adv) identificacion linux del disco a partir de la identificacion EAC (int_disk)
if [ $# = 1 ]
then 
	#echo hola $1
	disk=`echo $list | cut -f$1 -d' ' ` 2>/dev/null
	if [ $1 -gt $countlist ]
	then
		Msg "dispositivo no encontrdo" red
		return
	else
		echo $disk
	fi
fi
# (adv) identificacion linux de la particion a partir de la identificacion EAC. (int_disk int_partition)
if [ $# = 2 ]
then 
	# comprobamos que exite el disco
	 disk=`echo $list | cut -f$1 -d' ' ` 2>/dev/null
	 if [ $1 -gt $countlist ]
	then
		Msg "dispositivo no encontrdo" red
		return
	else
		#Msg "comprobamos que exite la particion." yellow
		totalpart=`parted $disk print | egrep ^" [0123456789] " -c`
		if [ "$2" -gt "$totalpart" ]
		then
			Msg "Partition no encontrada" red
		else
			partition="${disk}$2"
			#Msg "$partition" result
			echo $partition
		fi
	fi
fi
}


function IdPartition () {
# requiere Disk
if [ $# = 0 ]
then
	Msg "Info: Traduce el identificador del dispositivo EAC a dispositivo linux \n" info 
	Msg "Sintaxis1: IdPartition int_disk -----------------Ejemplo1: IdPartition 1 -> sda " example
	Msg "Sintaxis2: IdPartition int_disk int_partition  --Ejemplo2: IdPartition 1 2 -> sda2 " example
	
return
fi
PART="$(Disk|cut -f$1 -d' ')$2"
echo $PART | cut -f3 -d \/
}


function DiskEAC () {
# requiere IDpartition
if [ $# != 1 ]
then
	Msg "Traduce el identificador de dispositivo LINUX a dispositivo EAC: admite /dev/sda1/ /dev/sda1  sda1" red
return
fi
######### comprobamos si es identificador de partiticoin. devuelve 1 1 o 1 2 ...
for DISCO in 1 2 3 4 5 6 7 8 9; do
    for PART in 1 2 3 4 5 6 7 8 9; do
      	dev=`IdPartition $DISCO $PART`
	echo $1 | grep $dev > /dev/null && echo $DISCO $PART && return
     done
done
########## comprobamos si es identificador de disco duro. devuelve 1 o 2 o 3
for DISCO in 1 2 3 4 5 6 7 8 9; do
	dev=`IdPartition $DISCO`
	echo $1 | grep $dev > /dev/null && echo $DISCO && return
done
}

function TypeFS () {
# requiere DiskEAC y FindCache y FormatToUpper (filesystem.lib)
# Error si no se reciben 1 o 2 parametros.
# if [ $# -lt 1 -o $# -gt 2 ] 
if [ $# = 0 ]
then 
	Msg "sintaxis type fs2 con parametros EAC: TypeFS int_disk int_partition" red
	Msg "sintaxis con parmaetros LINUX: TypeFS /dev/sda2" red
return
fi
# Si solo 1 parametro, comprobar que es dispositivo (/dev/*).
if [ $# = 1 ] 
then
	[ -n "${1%/dev/*}" ] && return
        part=`DiskEAC $1`
	TypeFS $part
fi
#Si son 2 parametros, int_disk int_partition
if [ $# = 2 ]
then
	 part=`Disk $1`
	fs=`parted $part print | egrep ^" $2 " | awk '{print $6}'`	
	if [ $fs = "ext3" ]
	then
		cache=`FindCache`		
		#echo comparando si la identificacion int_disk e int_part tiene la etiqueta CACHE. la particion con label cache es  $cache
		partition=`Disk $1 $2`
		if [ "$partition" == "$cache" ]
		then
			fs="cache" 
		fi	
	fi	
	FormatToUpper $fs
fi
unset fs
}




function ListPartitions () {
#requiere findcache
if [ $# = 1 ]
then
	disco=`Disk $1`
	totalpart=`parted $disco print | egrep ^" [0123456789] " -c`
	totalpri=`parted $disco print | egrep ^" [0123456789] " | grep primary -c`
	cache=`FindCache`
	if parted $disco print | grep extended > /dev/null
	then 
		numextended=`parted $disco print | egrep ^" [0123456789] " | grep extended | cut -c 2` 
		end=$numextended 
	else
		numextended=0 
		end=`expr $totalpart + 1`
	fi
	totallogicas=`parted $disco print | egrep ^" [0123456789] " | grep logical -c`

	for (( times = 1; times < $end; times++))
	do
		particion=`Disk $1 $times`
		if [ "$particion" = "$cache" ]
		then
			table="$table `parted $disco unit GB print | egrep ^" $times " | awk '{print $1 ":" $4 ":CACHE"}'`"
		else
			table="$table `parted $disco unit GB print | egrep ^" $times " | awk '{print $1 ":" $4 ":"  $6}'`"
		fi
	done
	if [ $numextended != 0 ]
	then
		table="$table `parted $disco print | egrep ^" $numextended " | awk '{print $1 ":" $4 ":"  $5}'`"
		for (( times = $numextended + 1; times <= totalpart; times ++ ))
		do
			particion=`Disk $1 $times`
			if [ "$particion" == "$cache" ]
			then
				table="$table `parted $disco unit GB print | egrep ^" $times " | awk '{print $1 ":" $4 ":CACHE"}'`"
			else
				table="$table `parted $disco unit GB print | egrep ^" $times " | awk '{print $1 ":" $4 ":"  $6}'`"
			fi
		done
	fi
	FormatToUpper $table	
else
	Msg "Error de sintaxis: ListPrimaryPartition int_identificador[1-9]" red
fi
unset table
unset end
}


function NewMbrXP () {
if [ $# = 0 ]
then 
	Msg "sintaxis: NewMbrXP int_disco " red
return
fi
if [ $# = 1 ]
then 
	particion=`Disk $1`
	ms-sys -z -f $particion
	ms-sys -m -f $particion
fi
}

function DeletePartitionTable () {
if [ $# = 0 ]
then 
	Msg "sintaxis1: DeletePartitionTable int_disk" red
	Msg "sintaxis2: DeletePartitionTable str_/dev/sdX" red
	return
fi
if [ -n "${1%/dev/*}" ] 
	then 
	dev=`Disk $1`
	else 
	dev=$1
fi
echo -ne "o\nw" | fdisk $dev
}


SetPartitionActive() {
if [ $# = 0 ]
then 
	Msg "sintaxis: SetPartitionActive int_disk int_partition" red
	return
fi
if [ $# = 2 ]
	then 
	dev=`Disk $1`
	partition=$2
	parted -s $dev set $partition boot on
fi
}

SetPartitionType() {
if [ $# = 0 ]
then 
	Msg "sintaxis: SetPartitionType int_disk int_partition type" red
	return
fi
if [ $# = 3 ]
then 
	case $3 in
		"EXT2")
			fstype=83;;
		"EXT3")
			fstype=83;;
		"NTFS")
			fstype=7 ;;
		"FAT32")
			fstype=b ;;
		"SWAP")	
			fstype=82;;
		"CACHE")
			fstype=a7;;
	esac
disco=`Disk $1`
#totalpart=`parted $disco print | egrep ^" [0123456789] " -c`
totalpart=`DetectNumberPartition $1`
echo $totalpart
if [ $totalpart -gt 1 ]
then
       echo -ne "t\n$2\n$fstype\nw\n" | fdisk $disco 1>/dev/null 2>&1
else

       echo -ne "t\n$fstype\nw\n" | fdisk $disco 1>/dev/null 2>&1
fi

parametros="$*"
${REPO}admin/procedimientos/Log "$IP" " " "SetPartitionType" "$parametros" 
fi
}


 function CreatePartitions () {
if [ $# = 0 ]
then 
	Msg "como minimo dos particiones"
	Msg "sintaxis1: CreatePartitions int_disk  [int_part:intMB:str_TypeFS]" red
	Msg "int_part primaria y la extendida-> de la 1 a3 siempre primarias, la 4, puede ser primaria o la extendida (str_TypeFS EXTENDED)" blue
	Msg "int_part logicas, si hemos definido la 4 como EXTENDED, podemos utilizar como int_disk 5, 6 , 7, 8 ..." blue 
	Msg "int_MB, el tamaño en MB, pri+ext= totaldisco.  ext=totalext menos 1 gb" blue
	Msg "ejemplo45gb de pri + 150ext 1+48: CrearParticiones 1  1:15000:NTFS 2:15000:NTFS 3:15000:EXT3 4:150000:EXTENDED 5:1000:SWAP 6:148000:CACHE" orange
return
fi
processtart=`WhatsTime`
unset comando
unset comandodeletetable
unset comando
unset comandotype

##borramos las posibles etiquetas del sistema
DeleteLABELS

## empezamos a crear las particiones
contador=0 

for elemento in $*
do
	#echo el contador es: $contador
	if [ $contador -eq 0 ] 
	then
		dev=`Disk $1`	
	fi

	if [ $contador -gt 0 ] 
	then
		npart=`echo $elemento | awk -F: '{print $1}'`
		tam=`echo $elemento | awk -F\: '{print $2}'`
		type=`echo $elemento | awk -F\: '{print $3}'`
		case $type in
		"EXT2")
			fstype=83;;
		"EXT3")
			fstype=83;;
		"NTFS")
			fstype=7 ;;
		"FAT32")
			fstype=b ;;
		"SWAP")	
			fstype=82;;
		"CACHE")
			fstype=a7;;
		esac	
		case $npart in
		1)
			comando="${comando}n\np\n${npart}\n\n+${tam}MB \n"
		        #echo
                        if [ $# -eq 2 ]
                        then
                               comandotype="t\n${fstype}\n"
			else 
                                
                               comandotype="t\n${npart}\n${fstype}\n"
                        fi
                        ;;
		2|3)
			comando="${comando}n\np\n${npart}\n\n+${tam}MB \n"
			comandotype="${comandotype}\nt\n${npart}\n${fstype}\n"
			;;
		4)
			type=`echo $elemento | awk -F\: '{print $3}'`
			if [ $type = EXTENDED ]
			then
				comando="${comando}n\ne\n${npar}\n\n+${tam}MB\n"
			else
				comando="${comando}n\np\n${npart}\n\n+${tam}MB\n"
				comandotype="${comandotype}\nt\n${npart}\n${fstype}\n"
			fi
			;;
		5|6|7|8|9|10)
			comando="${comando}n\nl\n${npart}\n\n+${tam}MB\n"
			comandotype="${comandotype}\nt\n${npart}\n${fstype}\n"
			;;
		esac		
	fi
	contador=$[$contador+1]
done
comandodeletetable="o\n"
#comando="${comandodeletetable}${comando}${comandotype}\nw\n"
#echo $comando > /tmp/comandofdisk.txt
#echo -ne "$comando" | fdisk $dev > /dev/null

#echo "${comandodeletetable}\nw\n" > /tmp/deletetable.txt
echo -ne "${comandodeletetable}\nw\n" | fdisk $dev 1>/dev/null 2>&1

#echo "${comando}\nw\n" > /tmp/cretep.txt
echo -ne "${comando}\nw\n" | fdisk $dev 1>/dev/null 2>&1

#echo "${comandotype}\nw\n" > /tmp/typep.txt 
echo -ne "${comandotype}\nw\n" | fdisk $dev 1>/dev/null 2>&1

unset comandodeletetable
unset comando
unset comadotype



#actualizamos la informacion del kernel sobre la nueva tabla de particiones
UpdateDisk

##Establecemos los sitstemas de archivos correspondientes.
contador=1
for elemento in $*
do
	if [ $contador -gt 0 ]
	then		
		espacio=
		nparticion=`echo $elemento | awk -F: '{print $1}'`
		type=`echo $elemento | awk -F\: '{print $3}'`
		Msg "controlando la particion ${dev}${nparticion} para formatear con sistema $type " red
		case $type in
		"EXT2")
			#echo "mkfs.ext3 ${dev}${nparticion}";
			mkfs.ext3 ${dev}${nparticion};;
		"EXT3")
			#echo "mkfs.ext3 ${dev}${nparticion}";
			mkfs.ext3 ${dev}${nparticion};;
		"NTFS")
			#echo "mkfs.ntfs -l ${dev}${nparticion}"; 
			mkfs.ntfs -f ${dev}${nparticion} ;;
		"CACHE")
			#echo "mkfs.ext3 -L CACHE ${dev}${nparticion}";
			mkfs.ext3 -L CACHE ${dev}${nparticion};;
		"FAT32")
			;;
		"SWAP")	
			#echo "mkfswap ${dev}${nparticion}";
			mkswap ${dev}${nparticion};;
		"EXTENDED")
		;;
		esac
	fi
contador=$[$contador+1]
done

#asignacion por defecto de la particion boot en disk 1
SetPartitionActive $1 1

howlong=`HowLongHasWorked $processtart`
parametros="$*"
${REPO}admin/procedimientos/Log "$IP" "$howlong" "CreatePartitions" "$parametros" 
#FormatCACHE
}
 

function FormatCACHE () {
processtart=`WhatsTime`
if [ $# = 0 ]
then 
	cd /
	UmountCache
	dev=`FindCache`
	Msg "Iniciando el formateo de la particion CACHE, ubicada en $dev, y asignandole el label CACHE" red
	mkfs.ext3 $dev -L CACHE
	InfoCache
fi
if [ $# = 1 ]
then 
	mkfs.ext3 $1 -L CACHE
fi
howlong=`HowLongHasWorked $processtart`
parametros="$*"
${REPO}/admin/procedimientos/Log "$IP" "$howlong" "FormatCACHE" "$1 $2" 
}



function DeleteLABELS () {
rm /dev/disk/by-label/* 
}

function InfoHardware () {
lshw -c system -c memory -c processor -c display -c network -c disk -c volume -c multimedia > /var/EAC/hosts/${IP}-InfoHardware
if cat /var/EAC/hosts/${IP}-InfoHardware | grep "Dell"
then 
	echo "equipo Dell"
	export pci=nomsi
	export acpi=off
else
	echo "equipo clonico"
	export pci=msi
	export acpi=on
fi
}


function ReducirFileSystemNT () {
if [ $# = 2 ]
then
	processtart=`WhatsTime`
        export part=`Disk $1 $2`
        #ntfsfix $particion 
        montaje=`MountPartition $1 $2`
        sleep 2
        [ -e $montaje/pagefile.sys ] && rm $montaje/pagefile.sys
        UmountPartition $1 $2
        declare -i tam
        tam=`ntfsresize -i -f $part | awk '/You might resize at/ {print $8}'`
        tam=${tam}+1000	
        Msg "iniciando la reduccion del volumen $part a un tamanio $tam MegasBytes" red
	parametros="$* to $tam MB"
        echo y | ntfsresize -f -s ${tam}M $part
	howlong=`HowLongHasWorked $processtart`
	${REPO}/admin/procedimientos/Log "$IP" "$howlong" "ReducirFileSystemNT" "$parametros" 
        #echo y | ntfsresize -n -s ${tam}M $part
        unset tam
        unset part
else 
        Msg "error de sintaxis: ReducirFileSystemNT ndisco npartition" red
fi
}

function AmpliarFileSystemNT () {
if [ $# = 2 ]
then
	processtart=`WhatsTime`
        part=`Disk $1 $2`
        echo $part
        ntfsfix $part
        echo y | ntfsresize -f $part
	howlong=`HowLongHasWorked $processtart`
	${REPO}/admin/procedimientos/Log "$IP" "$howlong" "AmpliarFileSystemNT" "$parametros" 
        unset part
else 
        Msg "error de sintaxis: AmpliarFileSystemNT ndisco npartition" red
fi
}

##################### A eliminar
function FormatPartition () {
## Error si no se reciben 2 parametros.
### [ $# -ne 2 ] && exit 1
PART=`Disk $1 $2`
TYPE=`TypeFS $1 $2`
# Elegir tipo de formato segun el tipo de particion.
#case $TYPE in
#EXT3) TIPO="ext3";;
#EXT2)		
#	TIPO="ext2";;
#NTFS|HNTFS)	
#	TIPO="ntfs";;
#VFAT|HVFAT)	
#	TIPO="vfat";;
#BIGDOS|HBIGDOS)	
#	TIPO="";;
#CACHE)		
#	TIPO="ext2";;
#*) 		
#	return;;
#esac
# Formatear particion.
### Modo depuracion, quitar comentarios para trabajar.
#mkfs -t $TIPO $PART
unset PART
unset TYPE
}

function CrearSistemaArchivos () {
echo sintaxis: CrearSistemaArchivos /dev/sda 1:SISTEMA:NTFS 2:DATOS:NTFS 3:CACHE:EXT3 
contador=0
for elemento in $*
do
if [ $contador -eq 0 ] 
then
echo controlamos el primer parametro. numero de disco
if export | grep $1 | awk -F\" '{print $2}'  
then
dev=`export | grep $1 | awk -F\" '{print $2}'`
echo $dev esto es dev
echo "seguimos con el proceso"
else
DetectaDispositivo
fi 
echo fin control del primer parametro. numero disco.
fi

if [ $contador -gt 0 ]
then
espacio=
echo controlando la particion para formatear
#echo $espacio >> $temporal
#echo t >> $temporal
nparticion=`echo $elemento | awk -F: '{print $1}'`
#echo $nparticion >> $temporal 
label=`echo $elemento | awk -F\: '{print $2}'`
type=`echo $elemento | awk -F\: '{print $3}'`
case $type in
"EXT2")
	mkfs.ext3 -L ${label} ${dev}${nparticion};;
"EXT3")
	mkfs.ext3 -L ${label} ${dev}${nparticion};;
"NTFS")
	mkfs.ntfs -f -L ${label} ${dev}${nparticion} ;;
"CACHE")
	mkfs.ext3 -L ${label} ${dev}${nparticion};;
"FAT32")
	;;
"SWAP")	
	;;
"EXTENDED")
	;;
esac
#echo $fstype >> $temporal
fi
contador=$[$contador+1]
done
partprobe $dev
unset contador
unset elemento
}






