#!/bin/bash
PARM=`cat`
#PARM=$@


#TODO:  ticket 379
#buscar parametro de identificador de operacion.
#usar parametro de identificacion para anexarlo al nombre de log
#Comprobar si la variable está seteas.
#Si no lo está setearla.
#Si esta seteada (en progreso) salir.


TIME=$SECONDS

BASEDIR=/opt/opengnsys
PATH=$PATH:$BASEDIR/bin
REPONAME=ogAdmRepo
REPOLOG=$BASEDIR/log/$REPONAME.log
MCASTLOGBASE=$BASEDIR/log/mcastlog
MCASTLOG=$MCASTLOGBASE/ogAdmRepoMcast.`date +%Y%m%d-%H%M%S`
REPODIR="$BASEDIR/images/"

BACKUP=$(grep BACKUP /opt/opengnsys/client/etc/engine.cfg| cut -d= -f2)

# Añade registro de incidencias.
function echolog () {
	date +"%Y%m%d-%H%M%S $*" >> $REPOLOG
}

mkdir -p $MCASTLOGBASE


PARM1=$(echo $PARM | cut -f1 -d" ")
PARM2=$(echo $PARM | cut -f2 -d" ")
PARM3=$(echo $PARM | cut -f3 -d" ")
PARM4=$(echo $PARM | cut -f4 -d" ")

case "$PARM1" in
	START_MULTICAST)
		#1 START_MULTICAST
		#2 fichero a enviar
		#3 opciones de multicast
		FILE="$PARM2"
		MCASTOPT="$PARM3"
		echolog "Ejecutar $(which sendFileMcast) $FILE $MCASTOPT"
		sendFileMcast $FILE $MCASTOPT &>> $MCASTLOG
		case $? in
			1)  echolog "Parametros insuficientes"
			    return 1 ;;
			2)  echolog "Fichero no accesible"
			    return 2 ;;
			3)  echolog "Sesion multicast no valida"
			    return 3 ;;
		esac
	;;
	CREATE_IMAGE)
		# Creamos/Redimensionamos el fichero de imagen y lo montamos para que se pueda escribir sobre el
		#1 CREATE_IMAGE
		#2 nombre imagen
		#3 extension imagen
		#4 tamaño imagen 
		IMGEXT="$PARM3"
		IMGFILE="$REPODIR/$PARM2.$IMGEXT"
		IMGDIR="$(dirname $IMGFILE)"
		[ -d  $IMGDIR ] || mkdir -p $IMGDIR

		MOUNTDIR="$REPODIR/mount/${PARM2}"
		[ "$IMGEXT" == "diff" ] && MOUNTDIR="$MOUNTDIR.$IMGEXT"

		# Aumentamos El tamaño por el error de rsycn -> Probar con menos tamaño
		SIZEREQUIRED="$PARM4"
		#let SIZEREQUIRED=$PARM4*4/3

		if [ -f "$IMGFILE" ]; then
		    echolog "Redimensionamos la imagen $IMGFILE al tamaño necesario: $SIZEREQUIRED"
		    # Copia de seguridad de la imagen 
		    # Si la imagen esta montada la desmonto
		    if [ -r "$MOUNTDIR/ogimg.info" ]; then
			echolog "umount $MOUNTDIR"
			umount "$MOUNTDIR"
			[ $? -ne 0 ] && echolog "Error: No podemos desmontar la imagen para hacer copia de seguridad" && exit 1
		    fi
		    if [ "$BACKUP" == "true" ]; then
		    	echolog "Copia de seguridad de la imagen anterior"
		    	echolog "cp  $IMGFILE $IMGFILE.ant" 
		    	cp  "$IMGFILE" "$IMGFILE.ant" 
		    	echolog mv -f "$IMGFILE.torrent" "$IMGFILE.torrent.ant" 2>/dev/null
		    	mv -f "$IMGFILE.torrent" "$IMGFILE.torrent.ant" 2>/dev/null
		    fi

		    # Redimensionamos la imagen al tamaño necesario
		    # TODO modificar ogGetImageSize
		    IMGSIZE=$(ls -lk $IMGFILE| cut -f5 -d" ")
		    if [ $IMGSIZE -lt $SIZEREQUIRED ];then
		        echolog "truncate --size=\">$SIZEREQUIRED\"k $IMGFILE" 
		        truncate --size=">$SIZEREQUIRED"k $IMGFILE 2>&1 > $REPOLOG
			# Montamos la imagen, si da error nos salimos
		    	mount -o compress=lzo  "$IMGFILE" "$MOUNTDIR"
			echolog "btrfs filesystem resize max $MOUNTDIR"
			btrfs filesystem resize max "$MOUNTDIR"  2>&1 > $REPOLOG
			
		    fi


	
		else
		    echolog "Creamos la imagen $IMGFILE al tamaño necesario: $SIZEREQUIRED"
		    echolog dd if=/dev/zero of=$IMGFILE bs=1024 count=$SIZEREQUIRED 
		    dd if=/dev/zero of=$IMGFILE bs=1024 count=$SIZEREQUIRED
		    #Formateamos imagen
		    LOOPDEVICE=$(losetup -f)
		    echo losetup $LOOPDEVICE "$IMGFILE"
		    losetup $LOOPDEVICE "$IMGFILE"
		    echo mkfs.btrfs  -L ${PARM2##*\/} $LOOPDEVICE 
		    mkfs.btrfs  -L ${PARM2##*\/} $LOOPDEVICE #&> $OGLOGCOMMAND
	
		fi
		# Montamos la imagen.
		mkdir -p "$MOUNTDIR"
		echolog "mount -o compress=lzo  $IMGFILE $MOUNTDIR"
		mount -o compress=lzo  "$IMGFILE" "$MOUNTDIR"
		[ "$?" == "0" -o "$?" == "32" ] || (echolog "Error al crear/redimensionar la imagen"; exit 1)
		touch "$MOUNTDIR/ogimg.info"
		TIME2=$[SECONDS-TIME]
		echolog "Fin creación/redimension de la  imagen: $[TIME2/60]m $[TIME2%60]s"
		echo losetup -d $LOOPDEVICE
		losetup -d $LOOPDEVICE
		# TODO: comprobar que no se quede el losetup bloqueado.

	;;
	MOUNT_IMAGE)
		# Montamos el fichero imagen para que se pueda 
		#1 MOUNT_IMAGE
		#2 nombre imagen
		#3 extension imagen
		IMGFILE="$REPODIR/$PARM2.$PARM3"
		MOUNTDIR="$REPODIR/mount/$PARM2"
		[ "$PARM3" == "diff" ] && MOUNTDIR="$MOUNTDIR.$PARM3"
		echolog "Montamos la imagen $IMGFILE "
		mkdir -p "$MOUNTDIR"
		mount -o ro,compress=lzo  "$IMGFILE" "$MOUNTDIR"
		[ "$?" == "0" ] || (echolog "Error al montar la imagen"; exit 1)
	;;
	UMOUNT_IMAGE)
                # Desmontamos el fichero imagen.
		# Si el directorio esta ocupado no se desmontará
                #1 UMOUNT_IMAGE
                #2 nombre imagen
                #3 extension imagen
		IMGEXT="$PARM3"
		MOUNTDIR="$REPODIR/mount/$PARM2"
		[ "$IMGEXT" == "diff" ] && MOUNTDIR="$MOUNTDIR.$IMGEXT"
		echolog "Desmontamos la imagen $IMGFILE "
		umount $MOUNTDIR

	;;
	REDUCE_IMAGE)
		# Reduce el archivo de la imagen a tamaño datos + 500M
		#1 REDUCE_IMAGE
		#2 Nombre Imagen
		#3 Extensión [ img |diff ]
		IMGEXT="$PARM3"
                IMGFILE="$REPODIR$PARM2.$IMGEXT"
		[ ! -f $IMGFILE ] && echolog "Imagen no existe" && exit 1 
		MOUNTDIR="$REPODIR""mount/${PARM2}"
                [ "$IMGEXT" == "diff" ] && MOUNTDIR="$MOUNTDIR.$IMGEXT"

		mount -o compress=lzo  "$IMGFILE" "$MOUNTDIR"	
		AVAILABLE=$(df -k|grep $MOUNTDIR|awk '{print $4}')

        	# Si el espacio libre menor que 500Mb desmontamos la imagen y nos salimos
        	if [ $AVAILABLE -lt 500000 ]; then
		     umount $MOUNTDIR 
		     exit 0
		fi

		USED=$(df -k|grep $MOUNTDIR|awk '{print $3}')
		let ENDSIZE=USED+500000
        	echolog "reducir imagen REPO $PARM2 $IMGEXT, tamaño final: $ENDSIZE"
        	echolog btrfs filesystem resize "$ENDSIZE"k $MOUNTDIR
        	btrfs filesystem resize "$ENDSIZE"k $MOUNTDIR
		umount $MOUNTDIR
		echolog "truncate --size=\"$ENDSIZE\"k $IMGFILE"
        	truncate --size="$ENDSIZE"k $IMGFILE
	;;
	default)
	    echolog "Solicitud con parametros  \"$PARM\"  no realizada, no registrada o con errores"
	;;
esac

