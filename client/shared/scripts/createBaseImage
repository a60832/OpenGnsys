#!/bin/bash

#/**
#         createBaseImage
#@brief   Script de ejemplo para crear una imagen de un sistema de archivos.
#@brief (puede usarse como base para el programa de creación de imágenes usado por OpenGnSys Admin).
#@param 1 disco 
#@param 2 particion 
#@param 3 REPO|CACHE
#@param 4 imagen
#@return  
#@exception OG_ERR_FORMAT     # 1 formato incorrecto.
#@exception OG_ERR_PARTITION  # 3 Error en partición de disco o en su sistema de archivos
#@exception OG_ERR_LOCKED     # Imagen o particion bloqueada
#@exception OG_ERR_IMAGE      # 5 Error en funcion ogCreateImage o ogRestoreImage.
#@exception OG_ERR_NOTWRITE   # 14 error de escritura
#@exception OG_ERR_NOTCACHE   # 15 si cache no existe 15
#@exception OG_ERR_CACHESIZE  # 16 si espacio de la cache local o remota no tiene espacio 16
#@note  se toma como punto de partida el script createImage, cambiando solo lo especifico para la imagen squash
#@todo: que hacer, si el tamaño de la cache es sufciente, pero no tiene espacio libre
#@version 1.0 - creación imagen con mksquasfs
#@author  
#@date   2012-12-04
#*/ ##

trap "ogUnlockImage $3 \"/$4.$IMGEXT\"; ogUnlock $1 $2;  hose $REPOIP 2009 --out sh -c 	\"echo -ne UMOUNT_IMAGE $4 $IMGEXT\" ; umount \"$DIRMOUNT\"; exit 1" 1 2 3 6 9 14 15


TIME1=$SECONDS
#Carga el configurador del engine desde el fichero engine.cfg
[ -z $OGENGINECONFIGURATE ] && source /opt/opengnsys/etc/engine.cfg

# Opciones rsync
CREATESPEED=${CREATESPEED:-"100000*4"}

PROG="$(basename $0)"
if [ $# -ne 4 ]; then
    ogRaiseError $OG_ERR_FORMAT "$MSG_FORMAT: $PROG ndisco nparticion REPO|CACHE imagen"
    exit $?
fi

# Valores por defecto en etc/engine.cfg
IMGEXT="img"
REPOIP=$(ogGetRepoIp)

echo "[1] $MSG_SCRIPTS_START $0 $*" | tee -a  $OGLOGFILE


# Comprobamos si la imagen o la particion estan bloqueada:
ogIsImageLocked "$3" "$4.$IMGEXT" && echo  "$MSG_ERR_LOCKED $3 $4.$IMGEXT" | tee -a $OGLOGSESSION $OGLOGFILE && exit $(ogRaiseError $OG_ERR_LOCKED "$3 $4.$IMGEXT" ; echo $?)
ogIsLocked "$1" "$2" &&  echo  "$MSG_ERR_LOCKED $1 $2"  | tee -a $OGLOGSESSION $OGLOGFILE && exit $(ogRaiseError $OG_ERR_LOCKED  "$1 $2"; echo $?)

# Si el repositorio es CACHE comprobamos que exista
if [ "$3" == "CACHE" -o "$3" == "cache" ]; then 
	! ogFindCache >/dev/null && exit $(ogRaiseError $OG_ERR_NOTCACHE "CACHE " | tee -a $OGLOGSESSION $OGLOGFIL | tee -a $OGLOGSESSION $OGLOGFILEE ; echo $?)
fi

echo " " > $OGLOGCOMMAND

# Obtener información de los parámetros de entrada.
PART=$(ogDiskToDev "$1" "$2" 2>/dev/null) || exit $(ogRaiseError $OG_ERR_PARTITION "$1 $2"; echo $?)

#Comprobamos acceso de escritura.
DIRTEMP=$(date +%Y%m%d-%H%M%S)
ogMakeDir $3 /$4$DIRTEMP 2>/dev/null || exit $(ogRaiseError $OG_ERR_NOTWRITE "$3"; echo $?) && ogDeleteTree $3 /$4$DIRTEMP 

#Comprobar espacio que requerira la imagen para ser almacenada
echo " " > $OGLOGCOMMAND
if ogMount $1 $2 &>/dev/null
then
	SIZEDATA=$(df -k | grep $PART | awk '{print $3}')
	#Aplicar factor de compresion
	FACTORSYNC=90/100
        let SIZEREQUIRED=$SIZEDATA*$FACTORSYNC
	# El tamaño mínimo del sistema de ficheros btrfs es 250M, ponemos 300
	[ $SIZEREQUIRED -lt 300000 ] && SIZEREQUIRED=300000
	#Comprobar espacio libre en el contenedor.
	[ "$3" == "CACHE" -o "$3" == "cache" ] && SIZEFREE=$(ogGetFreeSize `ogFindCache`)
	[ "$3" == "REPO"  -o "$3" == "repo"  ] && SIZEFREE=$(df -k | grep $OGIMG | awk '{print $4}')
else
 	ogRaiseError $OG_ERR_PARTITION "$1 $2"
    	exit $?
fi
echo "[16] $PROG: $MSG_SCRIPTS_CREATE_SIZE  $SIZEREQUIRED $SIZEFREE" | tee -a $OGLOGSESSION $OGLOGFILE
[ $SIZEREQUIRED -gt $SIZEFREE ] && exit $(ogRaiseError $OG_ERR_CACHESIZE "$3" || echo $?)

IMGDIR=$(ogGetParentPath "$3" "/$4")
IMGFILE=${IMGDIR[$3]}/$(basename "/$4").$IMGEXT

ogLockImage "$3"  "/$4.$IMGEXT"

# Si existe el fichero de la imagen se hace copia de seguridad y se redimensiona, si  no existe se crea.
ogCreateFileImage $3 "$4" $IMGEXT $SIZEREQUIRED


DIRMOUNT="mount/$4"

# Comprobar consistencia del sistema de archivos.
echo " " > $OGLOGCOMMAND
SIZEFS=$(ogGetFsSize  $1 $2)
FSTYPE=$(ogGetFsType $1 $2)   
echo "[20] $MSG_HELP_ogCheckFs  $PART $SIZEFS (KB) " | tee -a $OGLOGSESSION $OGLOGFILE
ogUnmount $1 $2
ogCheckFs $1 $2 &> $OGLOGCOMMAND || exit $(ogRaiseError $OG_ERR_PARTITION "ogCheckFs $1 $2" && echo $?)

# Crear la imagen.
echo " " > $OGLOGCOMMAND
TIME2=$SECONDS
echo "[40] $MSG_HELP_ogCreateImage $1 $2 $3 $4 " | tee -a $OGLOGSESSION $OGLOGFILE

# Creamos la lista del contenido y lo situamos en la particion a copiar.
ogCreateInfoImage $1 $2 $IMGEXT

TIMEAUX3=$[SECONDS-TIME2]
echo "      Fin listado  contenido y lista de control de acceso: $[TIMEAUX3/60]m $[TIMEAUX3%60]s" | tee -a $OGLOGSESSION $OGLOGFILE


# Esperamos que el servidor termine de crear y montar la imagen
#ogWaitMountImage "$3" "$4" $IMGEXT $SIZEREQUIRED || exit $(ogRaiseError "Error al montar la imagen $1 $2 $3: time_out $TIMEAUX seg."; echo $?)
ogWaitMountImage "$3" "$4" $IMGEXT $SIZEREQUIRED

# Sincronizamos los datos de la particion con la imagen.
echo "[70] Sincronizamos los datos de la particion con la imagen."
ogSyncCreate $1 $2 $3 "$4"  $IMGEXT

echo "      Desmontamos la imagen en $3" | tee -a $OGLOGSESSION $OGLOGFILE
ogUnmountImage $3 "$4" $IMGEXT

ogUnlockImage "$3" "/$4.$IMGEXT"
ogUnlock $1 $2

TIMEAUX5=$[SECONDS-TIMEAUX3]
echo "      Fin copia de ficheros a la imagen: $[TIMEAUX3/60]m $[TIMEAUX3%60]s" | tee -a $OGLOGSESSION $OGLOGFILE
# Comprobamos que la imagen esta bien detectacdo que es un sistema de ficheros.
file $IMGFILE|grep "BTRFS Filesystem" 2>&1 >/dev/null
[ $? == 0 ] || exit $(ogRaiseError $OG_ERR_IMAGE "$3 $4" ; echo $?)

TIMEAUX7=$[SECONDS-TIME2]
echo "      $MSG_SCRIPTS_TIME_PARTIAL : $[TIMEAUX7/60]m $[TIMEAUX7%60]s" | tee -a $OGLOGSESSION $OGLOGFILE



#resumen de la operacion
IMGSIZE=$(ls -s $IMGFILE | cut -f1 -d" ")
# TODO: Hay que cambiar la funcion ogGetImageInfo
#IMGOS=$(ogGetImageInfo `ogGetPath $3 $4.img`) NO FUNCIONA Hay que modificar la funcion para las imagenes squash

TIME=$[SECONDS-TIME1]
echo "[100] $MSG_SCRIPTS_TIME_TOTAL $[TIME/60]m $[TIME%60]s" | tee -a $OGLOGSESSION $OGLOGFILE
echo "      FileSystem $PART with $NEWSIZEFS KB data created onto file-image as $4 and used $IMGSIZE KB acros DFS rsync " | tee -a $OGLOGSESSION $OGLOGFILE
echo "      Image-file $4 metada: $IMGOS " | tee -a $OGLOGSESSION $OGLOGFILE
