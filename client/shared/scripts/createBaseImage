#!/bin/bash

#/**
#         createBaseImage
#@brief   Script de ejemplo para crear una imagen de un sistema de archivos.
#@brief (puede usarse como base para el programa de creación de imágenes usado por OpenGnSys Admin).
#@param 1 disco 
#@param 2 particion 
#@param 3 REPO|CACHE
#@param 4 imagen
#@return  
#@exception OG_ERR_FORMAT     # 1 formato incorrecto.
#@exception OG_ERR_PARTITION  # 3 Error en partición de disco o en su sistema de archivos
#@exception OG_ERR_LOCKED     # 4 Imagen o particion bloqueada
#@exception OG_ERR_IMAGE      # 5 Error en funcion ogCreateImage o ogRestoreImage.
#@exception OG_ERR_NOTWRITE   # 14 error de escritura
#@exception OG_ERR_NOTCACHE   # 15 si cache no existe 15
#@exception OG_ERR_CACHESIZE  # 16 si espacio de la cache local o remota no tiene espacio 16
#@exception OG_ERR_DONTMOUNT_IMAGE # 70 Error al montar una imagen sincronizada
#@note  se toma como punto de partida el script createImage, cambiando solo lo especifico para la imagen sincronizada
#@todo: que hacer, si el tamaño de la cache es sufciente, pero no tiene espacio libre
#@version 1.0 - creación imagen con btrfs
#@author  
#@date   2012-12-04
#*/ ##

trap "onexit $1 $2 $3 \"$4\"" 1 2 3 6 9 14 15 ERR

# Establecemos factor de compresion
COMPRESS=90/100
COMPRESSLINUX=80/100 

# Si salimos con error demontamos la imagen y desbloqueamos la imagen y la particion
function onexit() {
    local exit_status=$?
    echo "$MSG_ERR_GENERIC $exit_status" |tee -a $OGLOGFILE  $OGLOGSESSION
    echo ogUnmountImage $3 "$4" $IMGEXT 
    ogUnmountImage $3 "$4" $IMGEXT &>/dev/null
    echo ogUnlockImage "$3" "/$4.$IMGEXT"
    ogUnlockImage "$3" "/$4.$IMGEXT" 
    echo ogUnlock $1 $2
    ogUnlock $1 $2
    exit $exit_status
}

TIME1=$SECONDS
#Carga el configurador del engine desde el fichero engine.cfg
[ -z $OGENGINECONFIGURATE ] && source /opt/opengnsys/etc/engine.cfg

# Factor de calculo de Time out al crear imagen: valor por defecto en engine.cfg 
CREATESPEED=${CREATESPEED:-"100000*4"}

PROG="$(basename $0)"
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp  "$PROG: $MSG_HELP_createBaseImage" \
	    "$PROG ndisco nparticion REPO|CACHE base_image" \
            "$PROG 1 1 REPO Windows7"
   exit 0
fi

[ $# -ne 4 ] && ogRaiseError $OG_ERR_FORMAT "$MSG_FORMAT: $PROG ndisco nparticion REPO|CACHE imagen" 

# Valores por defecto en etc/engine.cfg
IMGEXT="img"
REPOIP=$(ogGetRepoIp)

# Limpiamos fichero de log
echo  -n ""> $OGLOGSESSION

echo "[1] $MSG_SCRIPTS_START $0 $*" | tee -a $OGLOGSESSION  $OGLOGFILE

# Comprobamos si la imagen o la particion estan bloqueada:
ogIsImageLocked "$3" "$4.$IMGEXT" && ogRaiseError $OG_ERR_LOCKED "$3 $4.$IMGEXT"
ogIsLocked "$1" "$2" && ogRaiseError $OG_ERR_LOCKED  "$1 $2"

# Si el repositorio es CACHE comprobamos que exista
if [ "$3" == "CACHE" -o "$3" == "cache" ]; then 
	! ogFindCache >/dev/null && ogRaiseError $OG_ERR_NOTCACHE "CACHE "
fi

echo " " > $OGLOGCOMMAND

# Obtener información de los parámetros de entrada.
PART=$(ogDiskToDev "$1" "$2" 2>/dev/null) || ogRaiseError $OG_ERR_PARTITION "$1 $2"
# Comprobamos que la particion se puede montar
ORIG=$(ogMount $1 $2) || ogRaiseError $OG_ERR_PARTITION "$1 $2"

#Comprobamos acceso de escritura.
DIRTEMP=$(date +%Y%m%d-%H%M%S)
ogMakeDir $3 /$4$DIRTEMP 2>/dev/null || ogRaiseError $OG_ERR_NOTWRITE "$3" && ogDeleteTree $3 /$4$DIRTEMP 

# Borramos ficheros de paginacion y configuracion
case "$(ogGetFsType $1 $2)" in 
    EXT[234])
	ogCleanLinuxDevices $1 $2
	rm -rf $ORIG/tmp/*
	COMPRESS=$COMPRESSLINUX
	;;
    NTFS)
        [ $(ogGetPath $1 $2 pagefile.sys) ] && ogDeleteFile $1 $2 pagefile.sys
        [ $(ogGetPath $1 $2 hiberfil.sys) ] && ogDeleteFile $1 $2 hiberfil.sys
	;;
esac

#Comprobar espacio que requerira la imagen para ser almacenada
SIZEDATA=$(df -k | grep $PART | awk '{print $3}')
#Aplicar factor de compresion
let SIZEREQUIRED=$SIZEDATA*$COMPRESS
# El tamaño mínimo del sistema de ficheros btrfs es 250M, ponemos 300
[ $SIZEREQUIRED -lt 300000 ] && SIZEREQUIRED=300000
#Comprobar espacio libre en el contenedor.
[ "$3" == "CACHE" -o "$3" == "cache" ] && SIZEFREE=$(ogGetFreeSize `ogFindCache`)
[ "$3" == "REPO"  -o "$3" == "repo"  ] && SIZEFREE=$(df -k | grep $OGIMG | awk '{print $4}')
echo "[16]$MSG_SCRIPTS_CREATE_SIZE  $SIZEREQUIRED $SIZEFREE" | tee -a $OGLOGSESSION $OGLOGFILE
[ $SIZEREQUIRED -gt $SIZEFREE ] && ogRaiseError $OG_ERR_CACHESIZE "$3"

IMGDIR=$(ogGetParentPath "$3" "/$4")
IMGFILE=${IMGDIR[$3]}/$(basename "/$4").$IMGEXT

# Comprobar consistencia del sistema de archivos.
echo " " > $OGLOGCOMMAND
SIZEFS=$(ogGetFsSize  $1 $2)
echo "[20] $MSG_HELP_ogCheckFs  $PART $SIZEFS (KB) " | tee -a $OGLOGSESSION $OGLOGFILE
ogUnmount $1 $2
ogCheckFs $1 $2 &> $OGLOGCOMMAND || ogRaiseError $OG_ERR_PARTITION "ogCheckFs $1 $2"

# Crear la imagen.
echo " " > $OGLOGCOMMAND
TIME2=$SECONDS

ogLockImage "$3"  "/$4.$IMGEXT"

# Si existe el fichero de la imagen se hace copia de seguridad y se redimensiona, si  no existe se crea.
echo "[30] $MSG_HELP_ogCreateFileImage." | tee -a $OGLOGSESSION $OGLOGFILE
ogCreateFileImage $3 "$4" $IMGEXT $SIZEREQUIRED

# Creamos la lista del contenido y lo situamos en la particion a copiar.
echo "[50] $MSG_HELP_ogCreateImage $1 $2 $3 $4 " | tee -a $OGLOGSESSION $OGLOGFILE
echo "      $MSG_HELP_ogCreateInfoImage"  | tee -a $OGLOGSESSION $OGLOGFILE
ogCreateInfoImage $1 $2 $IMGEXT

TIMEAUX3=$[SECONDS-TIME2]
echo "      $MSG_SCRIPTS_TASK_END, $MSG_SCRIPTS_TIME_PARTIAL : $[TIMEAUX3/60]m $[TIMEAUX3%60]s" | tee -a $OGLOGSESSION $OGLOGFILE

# Esperamos que el servidor termine de crear y montar la imagen
ogWaitMountImage "$3" "$4" $IMGEXT $SIZEREQUIRED  || ogRaiseError $OG_ERR_DONTMOUNT_IMAGE "$3 $4 $IMGEXT: time_out."


# Sincronizamos los datos de la particion con la imagen.
echo "      $MSG_HELP_ogSyncCreate."  | tee -a $OGLOGSESSION $OGLOGFILE
ogSyncCreate $1 $2 $3 "$4"  $IMGEXT

# Lo comantamos hasta probar -> da error de ERROR: unable to resize '/tmp/mount/IMG' - No space left on device
# Reducimos la imagen
#echo "[90] $MSG_HELP_ogReduceImage: $3 /$4.$IMGEXT" | tee -a $OGLOGSESSION $OGLOGFILE
#ogReduceImage $3 "$4" $IMGEXT

# Desmontamos la Imagen
ogUnmountImage $3 "$4" $IMGEXT
ogUnlockImage "$3" "/$4.$IMGEXT"
ogUnlock $1 $2
TIMEAUX5=$[SECONDS-TIMEAUX3]
echo "      $MSG_SCRIPTS_TASK_END, $MSG_SCRIPTS_TIME_PARTIAL: $[TIMEAUX3/60]m $[TIMEAUX3%60]s" | tee -a $OGLOGSESSION $OGLOGFILE

# Comprobamos que la imagen esta bien detectacdo que es un sistema de ficheros.
file $IMGFILE|grep "BTRFS Filesystem" 2>&1 >/dev/null || ogRaiseError $OG_ERR_IMAGE "$3 $4" 

TIMEAUX7=$[SECONDS-TIME2]
echo "      $MSG_SCRIPTS_TIME_PARTIAL : $[TIMEAUX7/60]m $[TIMEAUX7%60]s" | tee -a $OGLOGSESSION $OGLOGFILE


#resumen de la operacion
IMGSIZE=$(ls -l --block-size=1024 $IMGFILE | cut -f5 -d" ")

TIME=$[SECONDS-TIME1]
echo "[100] $MSG_SCRIPTS_TIME_TOTAL $[TIME/60]m $[TIME%60]s" | tee -a $OGLOGSESSION $OGLOGFILE
echo "      FileSystem $PART with $SIZEDATA KB data created onto file-image as $4 and used $IMGSIZE KB acros DFS rsync " | tee -a $OGLOGSESSION $OGLOGFILE
