#!/bin/bash

#/**
#         cloneremoteFromMaster
#@brief   Restaura una particion o imagen sobre las particiones de equipos cliente remotos
#@param 1 str_origen admite dirección IP del equipo Master.
#@param 2 str_origen  admite int_disk    str_REPO|str_CACHE
#@param 3 str_origen  admite int partorigen   stre_imagen
#@param 4 str_sesion multicast|unicast
#@param $5 int_disco_destino
#@param $6 init_particion_destino
#@param $7 str_tool_clone
#@param $8 str_tool_compresor
#@param ejemplo: cloneRemoteFromMaster 172.17.36.11 1 1 9000:full-duplex:239.194.17.36:70M:50:100 1 1 partclone lzop
#@param ejemplo: cloneRemoteFromMaster 172.17.36.11 REPO /imagen1 9000:full-duplex:239.194.17.36:70M:50:100 1 1 partclone lzop 
#@param ejemplo: cloneRemoteFromMaster 172.17.36.11 CACHE /imagen1 9000:full-duplex:239.194.17.36:70M:50:100 1 1 partclone lzop 
#@return  
#@exception OG_ERR_FORMAT     formato incorrecto.
#@exception $OG_ERR_IMGSIZEPARTITION=30   #Imagen demasiado pequeña para ser clonada
#@exception OG_ERR_REDUCEFS=17     #error al reducir sistema de archivos.
#@exception OG_ERR_EXTENDFS=18     #errror al expandir el sistema de archivos.
#@exception OG_ERR_UCASTSYNTAXT=50  # Error en la generación de sintaxis de transferenica unicast
#@exception OG_ERR_UCASTSENDPARTITION=51  # Error en envio UNICAST de una particion
#@exception OG_ERR_UCASTSENDFILE=52  # Error en envio UNICAST de un fichero
#@exception OG_ERR_UCASTRECEIVERPARTITION=53  #Error en la recepcion UNICAST de una particion
#@exception OG_ERR_UCASTRECEIVERFILE=54  #Error en la recepcion UNICAST de un fichero
#@exception OG_ERR_MCASTSYNTAXT=55 # Error en la generacion de sintaxis de transferenica Multicast.
#@exception OG_ERR_MCASTSENDFILE=56  # Error en envio MULTICAST de un fichero
#@exception OG_ERR_MCASTRECEIVERFILE=57  #Error en la recepcion MULTICAST de un fichero
#@exception OG_ERR_MCASTSENDPARTITION=58  # Error en envio MULTICAST de una particion
#@exception OG_ERR_MCASTRECEIVERPARTITION=59  # Error en la recepcion MULTICAST de una particion
#@exception OG_ERR_PROTOCOLJOINMASTER=60 # Error en la conexion de una sesion UNICAST|MULTICAST con el MASTER
#@note   
#@todo: 
#@version 0.9.1 - integración con OpenGnsys
#@author  Antonio J. Doblas Viso. Universidad de Malaga.
#@date   2009/03/17
#@version 0.9.2 - adaptacion a OpenGnsys
#@author  Antonio J. Doblas Viso. Universidad de Malaga.
#@date    2010/07/27
#@version 0.1.0 - gestion unicast
#@author  Antonio J. Doblas Viso. Universidad de Malaga.
#@date    2011/01/26
#@version 1.0 - control de errores para el ogAdmServer
#@author  Antonio J. Doblas Viso. Universidad de Malaga.
#@date    2011/04/24
#@version 1.0 - Uso de parted para controlar tamaño particion destino. Requiere Formateo FS previo -parted usa FS para el tamanyo".
#@author  Antonio J. Doblas Viso. Universidad de Malaga.
#@date    2011/04/24

#*/ ##


TIME1=$SECONDS
PROG="$(basename $0)"
if [ $# -lt 1 ]; then
	echo "cloneRemoteFromMaster ipmaster disk init [MULTICAST|UNICAST] session disk part tool comp"
	exit 1
fi

if [  $# -lt 6  ]; then
    ogRaiseError $OG_ERR_FORMAT "$MSG_FORMAT: $PROG ipMaster SOURCE_disco SOURCE_particion [MULTICAT|UNICAST] SESSION TARGER_disck TARGET_partition" 
    exit $?
fi

# Obtener información de los parámetros de entrada.
HOSTIP=`ogGetIpAddress`
if [ -z "$HOSTIP" ] 
then
	source /tmp/net-eth* 
	HOSTIP=`ogGetIpAddress`
fi
MASTERIP=$1
PROTOCOL=$4
case $PROTOCOL in 
 	MULTICAST|multicast)
		SESSIONMCASTSERVER=$5
		SESSIONMCASTCLIENT=`echo $5 | awk -F: '{print $1}'`
	;;
	UNICAST|unicast) 
		SESSIONUCASTSERVER=$5
    	SESSIONUCASTCLIENT=`echo $5 | awk -F: '{print $1}'`:$MASTERIP
	;;
esac
# contenedor destino (disco particion)
DISKTARGET=$6
PARTTARGET=$7
#herramienta de compresión.
TOOLCLONE=$8
COMPRESOR=$9

pkill faucet

# Preparando Instrucción según sea Master o Client
case $MASTERIP in
	$HOSTIP)
		echo "[1] Equipo Master preparando el origen de los datos a enviar"
		ogGetPath $2 $3.img &>/dev/null; RC=$?; 
		ogDiskToDev $2 $3 &>/dev/null; RETVAL=$?; 

		if [ "$RC" == "0" ]; then 
			IMG=$(ogGetPath $2 $3.img); MODEMASTER=SENDFILE
		elif [ "$RETVAL" == "0" ]; then
			DISKSOURCE=$2; PARTSOURCE=$3; MODEMASTER=SENDPARTITION
		else
			ogRaiseError $OG_ERR_NOTFOUND "$2 $3"; exit $?
		fi 
		echo $MODEMASTER
		# Preparando instrucción del Master segun $MODEMASTER{SENDPARTITION SENDFILE}
					
		case "$MODEMASTER" in
			SENDPARTITION)
				echo "[5] Master en modo  $MODEMASTER: informacion inicial a los clientes-slaves"
				faucet 4000 --out echo "WORKING" &			
				echo "[10]: Desmontando DISK:$DISKSOURCE PARTITION:$PARTSOURCE"
				ogUnmount $2 $3 || exit $?
				echo "[15]: Calculando la reduccion del sistema de archivos DISK:$DISKSOURCE PARTITION:$PARTSOURCE SIZE:$SIZE"
				#Obtener tamaño de la partición.
				SIZE=$(ogGetPartitionSize $2 $3)  
				# Reducir el sistema de archvios.
				ogReduceFs $2 $3 || exit $?
				REDSIZE=$(ogGetFsSize $2 $3) 	
				echo "[20]: Reducido el  sistema de archivos a $REDSIZE  $DISKSOURCE $PARTSOURCE"
				if [ $REDSIZE -lt $SIZE ]; then
    					echo "[24] Redimensionar partición a $REDSIZE KB."
    					ogSetPartitionSize $2 $3 $REDSIZE
				fi
				echo "[25] Master en Modo $MODEMASTER: informacion de transferencia a los clientes-slaves $PROTOCOL $TOOLCLONE $COMPRESOR $REDSIZE"
				pkill faucet
				faucet 4000 --out echo "READY $TOOLCLONE $COMPRESOR $REDSIZE" &
						
				case $PROTOCOL in
					MULTICAST|multicast)
						echo "[29] ogMcastSendPartition $DISKSOURCE $PARTSOURCE $SESSIONMCASTSERVER $TOOLCLONE $COMPRESOR" 
 						ogMcastSendPartition $DISKSOURCE $PARTSOURCE $SESSIONMCASTSERVER $TOOLCLONE $COMPRESOR || RETVAL=$?
 					;;
 					UNICAST|unicast)
 						sleep 60
 						echo "[29] ogUcastSendPartition $DISKSOURCE $PARTSOURCE $SESSIONUCASTSERVER $TOOLCLONE $COMPRESOR"
 						ogUcastSendPartition $DISKSOURCE $PARTSOURCE $SESSIONUCASTSERVER $TOOLCLONE $COMPRESOR || RETVAL=$?
 					;;
 				esac	
 				
 				if [ $REDSIZE -lt $SIZE ]; then
   					echo "[85] Redimensionar partición a $SIZE KB."
   		 			ogSetPartitionSize $2 $3 $SIZE
   		 			echo "[90] Extender sistema de archivos."
   		 			ogExtendFs $2 $3
				fi
				pkill faucet
			;;
			SENDFILE)				
				echo "[5] Master en modo  $MODEMASTER: informacion inicial a los clientes-slaves"
				echo "[10]: Preparando Imagen: $IMG"
				TOOLCLONE=$(ogGetImageProgram $2 $3)
				COMPRESOR=$(ogGetImageCompressor $2 $3)
				REDSIZE=$(ogGetImageSize $2 $3)
				echo "[25] Master en Modo $MODEMASTER: informacion de transferencia a los clientes-slaves $PROTOCOL $TOOLCLONE $COMPRESOR $REDSIZE"
				faucet 4000 --out echo "READY $TOOLCLONE $COMPRESOR $REDSIZE" &
				case $PROTOCOL in
					MULTICAST|multicast)
						echo "[29] ogMcastSendFile $2 $3.img $SESSIONMCASTSERVER "
						ogMcastSendFile  $2 $3.img $SESSIONMCASTSERVER	|| RETVAL=$?
						;;
 					UNICAST|unicast)
 						sleep 60
 						echo "[29] ogUcastSendFile $2 $3.img $SESSIONUCASTSERVER"
 						ogUcastSendFile $2 $3.img $SESSIONUCASTSERVER || RETVAL=$?
 					;;
 				esac							
				pkill faucet	
			;;
		esac
		#exit $RETVAL
        exit 0
		# FIN Preparando instrucción del Master segun $MODEMASTER{SENDPARTITION SENDFILE}
	;;
	*)
		echo "[1] Equipo -Client- preparando para recibir datos $PROTOCOL"
		# TODO: si el cliente no está en la lista de clientes UNICAST salir.
		case $PROTOCOL in
			UNICAST|unicast)
 				echo "$SESSIONUCASTSERVER" | grep $HOSTIP || exit 1			
 			;;
 		esac	
 		echo "[2] Desmontando particion destino"	 
		ogUnmount $DISKTARGET $PARTTARGET 
		echo -n "[25] Buscando informacion extra sobre la clonacion con el master $MASTERIP: "
		sleep 10
		TIMEWAITMASTER=120
		TIMEWAITING=0
		GETINFO="NONE"
		while [ "${GETINFO}" != "OK" ]
		do
			INFOEXTRA=`hose $MASTERIP 4000 --in cat 2>/dev/null`
			sleep 10; echo -n "."
			#Si no consigue conectar con Master, comienza el timeout $TIMEWAITMASTER para abortar
			[ -z "$INFOEXTRA" ] && let TIMEWAITMASTER=$TIMEWAITMASTER-10
			[ "$TIMEWAITMASTER" -gt "0" ] || ogRaiseError $OG_ERR_PROTOCOLJOINMASTER " " || exit $?
			#Si primer parametro desde el server es READY, salimos del bucle
			GETINFO=$(echo $INFOEXTRA | awk '{print $1}')
			[ "$GETINFO" == "READY" ] && GETINFO=OK 
		done		
		echo $INFOEXTRA
		TOOLCLONE=$(echo $INFOEXTRA | awk '{print $2}')
		COMPRESOR=$(echo $INFOEXTRA | awk '{print $3}')
		SIZEIMAGE=$(echo $INFOEXTRA | awk '{print $4}')
		echo -n "[26] $INFOEXTRA = herramienta= $TOOLCLONE  compresor= $COMPRESOR size= $SIZEIMAGE "
		SIZEPARTTARGET=$(parted `ogDiskToDev $DISKTARGET $PARTTARGET` unit kB print | awk '{y=x; x=$4};END{print y}' | tr -d kB) 
		if [ -z $SIZEPARTTARGET ]; then
			echo "[5] TODO Formateando particion destino si no es accesible por parted"	 
			ogFormat $DISKTARGET $PARTTARGET 
			SIZEPARTTARGET=$(parted `ogDiskToDev $DISKTARGET $PARTTARGET` unit kB print | awk '{y=x; x=$4};END{print y}' | tr -d kB) 
		fi 
		echo "[29] comprobando que el tamaño de la imagen $SIZEIMAGE es menor que el de la particion destino $SIZEPARTTARGET"	 
		# comprobamos que el tamaño de a imagen es menor que la del cliente.
		if [ "$SIZEIMAGE" -lt "$SIZEPARTTARGET" ]
 		then	
			echo "[30] Iniciando Cliente $PROTOCOL "
				case $PROTOCOL in
					MULTICAST|multicast)
						echo ogMcastReceiverPartition $DISKTARGET $PARTTARGET $SESSIONMCASTCLIENT $TOOLCLONE $COMPRESOR 
						ogMcastReceiverPartition "$DISKTARGET" "$PARTTARGET" "$SESSIONMCASTCLIENT" "$TOOLCLONE" "$COMPRESOR"  || exit $?
		 					;;
 					UNICAST|unicast)
 						echo ogUcastReceiverPartition $DISKTARGET $PARTTARGET $SESSIONUCASTCLIENT $TOOLCLONE $COMPRESOR
 						ogUcastReceiverPartition $DISKTARGET $PARTTARGET $SESSIONUCASTCLIENT $TOOLCLONE $COMPRESOR || exit $?
 					;;
 				esac
			
			
			echo "[90] Extender sistema de archivos"
			ogExtendFs $DISKTARGET $PARTTARGET
			# Cambiar nombre en sistemas Windows.
			if [ "$(ogGetOsType $DISKTARGET $PARTTARGET)" = "Windows" ]; then
    				HOST=$(ogGetHostname)
    				HOST=${HOST:-"UNKNOWN"}
    				echo "[90] Cambiar nombre Windows a \"$HOST\"."
    				ogSetWindowsName $DISKTARGET $PARTTARGET "$HOST"
			fi		
		else
		    # Si el tamaño de los datos recibidos es más grande que la particion destino
			ogRaiseError $OG_ERR_IMGSIZEPARTITION "ERROR tamanio particion= $SIZEPARTTARGET  menor que la imagen= $SIZEIMAGE"; exit $?
		fi
	;;
esac
TIME=$[SECONDS-TIME1]
echo "[100] Duración de la operación $[TIME/60]m $[TIME%60]s"


