#!/bin/bash


#/**
#         updateCache
#@brief   Actualiza la cache del cliente con imagen o fichero iso.
#@param 1 REPO          Origen del fichero. -accesible por nfs-samba-
#@param 2 str_fichero   nombre del fichero a actualizar.
#@param 3 str_protoco.  TORRENT | MULTICAST    | UNICAST.
#@param 4 str_opcionesprotocolo
#@param 4 str_opcionesupdatecache
#@ejemplo: oneRemoteFromMaster 172.17.36.11 CACHE /imagen1 9000:full-duplex:239.194.17.36:70M:50:100 1 1 partclone lzop 
#@return  
#@exception OG_ERR_FORMAT       formato incorrecto.
#@exception OG_ERR_NOTCACHE     No existe cache -15-
#@exception $OG_ERR_CACHESIZE   Tamaño de la paticion menor al archivo a descargar -16-
#@note   
#@todo: 
#@version 0.9.1 - integracion EAC
#@author  Antonio J. Doblas Viso. Universidad de Malaga.
#@date    2008/03/17
#@version 0.9.2 - integracion OpenGnsys
#@author  Antonio J. Doblas Viso. Universidad de Malaga.
#@date    2010/07/27
#@version 1.0.1 - Control de espacio requerido
#@author  Antonio J.Doblas Viso
#@date   2011-05-10
#@version 2.0.1 - Imagenes sincronizadas
#@date    2013-02-20
#*/ ##

PROG="$(basename $0)"
if [ $# -lt 3 ]; then
    ogRaiseError $OG_ERR_FORMAT "$MSG_FORMAT: $PROG str_REPO _str_Relative_Path_OGIMG_with_/ PROTOCOLO OPCIONES_PROTOCOLO OPCIONES_UPDATECACHE"
    exit $?
fi

#Carga del configurador del engine
[ -z $OGENGINECONFIGURATE ] && source /opt/opengnsys/etc/engine.cfg

REPOSITORIO="$1"
PROTOCOLO="$3"
OPTPROTOCOLO="$4"
REPOIP=$(ogGetRepoIp)
echo $REPOSITORIO $REPOIP $PROTOCOLO $OPTPROTOCOLO

# Si el repositorio local CACHE no existe error 15.
if ! $(ogFindCache >/dev/null); then
        ogRaiseError $OG_ERR_NOTCACHE "CACHE"
        exit $?
fi

# comprobar si la imagen existe
REPOFILE=$(ogGetPath "REPO" "/$2")  || ogRaiseError $OG_ERR_NOTFOUND "REPO /$2"

echo "$MSG_SCRIPTS_UPDATECACHE_DOUPDATE "
# Distingo si es monolitica o sincronizable
file $REPOFILE | grep " BTRFS Filesystem" 2>&1 > /dev/null
if [ $? == 0 ]; then
	IMGTYPE="RSYNC"
	# Para imagen sincronizada, si hay imagen en cache uso rsync, si no otro protocolo
	CACHEFILE=$(ogGetPath "CACHE" "/$2")  && PROTOCOLO="RSYNC"

	# Si es imagen sincronizada siempre da distinto md5. No podemos comprobar -> actualizamos.
	RETVAL=0
else
	IMGTYPE="MONOLITICA"
	#TODO: ogUpdateCacheIsNecesary debe borrar la imagen que tenga igual nombre pero distinto sum-
	ogUpdateCacheIsNecesary $1 $2
	RETVAL=$?
fi
# si RETVAL=0 => actualizamos  si RETVAL=1 no actaulizasmo-exit 0  || si RETVAL>2 exit 1
[ "$RETVAL" == "1" ] && exit 0
[ "$RETVAL" -gt  "1" ] && exit 1

CACHESIZE=$(ogGetCacheSize)
CACHESIZEFREE=$(ogGetFreeSize `ogFindCache`)
FILESIZE=$(ls -sk $(ogGetPath $REPOSITORIO "$2") | cut -f1 -d" ")
REALFILESIZE=$(ls -l --block-size=1024 $(ogGetPath $REPOSITORIO "$2") | cut -f5 -d" ")

# La sincronizada, si existe la imagen en cache el espacio necesario
#	 es la nueva menos lo que ocupa la que ya hay.
if [ "$PROTOCOLO" == "RSYNC" ]; then
	CACHEFILESIZE=$(ls -l --block-size=1024 $(ogGetPath "CACHE" "$2") | cut -f5 -d" ")
	let SIZEREQUIRED=$CACHEFILESIZE-$FILESIZE
	[ $SIZEREQUIRED -lt 0 ] && SIZEREQUIRED=0
else
	SIZEREQUIRED=$FILESIZE

fi

echo "$MSG_SCRIPTS_UPDATECACHE_CHECKSIZECACHE"
#ERROR CACHESIZE 16
if [ "$SIZEREQUIRED" -ge "$CACHESIZE" ]  
then
	echo "WARNING: $MSG_ERR_CACHESIZE:  $2 = $SIZEREQUIRED > CACHE = $CACHESIZE" | tee -a $OGLOGSESSION $OGLOGFILE
	ogRaiseError $OG_ERR_CACHESIZE "CACHE"
    exit $?
fi

echo "$MSG_SCRIPTS_UPDATECACHE_IFNOTCACHEDO"
#ERROR CACHESIZE 16
if [ "$SIZEREQUIRED" -ge "$CACHESIZEFREE" ]  
then
	# echo "[ ] No hay espacio sufiente en la CACHE, detectar que hacer con engine.cfg"  | tee -a $OGLOGSESSION $OGLOGFILE
	case $ACTIONCACHEFULL in 
	NONE)
		NEXTOPERATION=UNICAST
	;;
	FORMAT)
	    echo "[51] $MSG_HELP_ogFormatCache "  | tee -a $OGLOGSESSION $OGLOGFILE
	    ogUnmountCache
	    ogFormatCache
	    ogMountCache
	    NEXTOPERATION=REPEAT
	;;
	DELETE)
		echo "[51] #MSG_HELP_ogDeleteTree $OGCAC$OGIMG/* "  | tee -a $OGLOGSESSION $OGLOGFILE
	    rm -fr  $OGCAC$OGIMG/*
	    NEXOPERATION=REPEAT
	;;
	*)
	 	echo "WARNING: $MSG_ERR_CACHESIZE:  $2 = $FILESIZE > CACHE = $CACHESIZEFREE" | tee -a $OGLOGSESSION $OGLOGFILE
		ogRaiseError $OG_ERR_CACHESIZE "CACHE"
    	exit $?
	;;
	esac	
fi

# Comprobamos que imagen cache igual a la del repo. Si sincronizada no podemos comprobar. 
[ "$IMGTYPE" == "RSYNC" ] || ogUpdateCacheIsNecesary $REPOSITORIO "$2"
RETVAL=$?
# si RETVAL=0 => actualizamos  si RETVAL=1 no actaulizasmo-exit 0  || si RETVAL>2 exit 1
[ "$RETVAL" == "1" ] && exit 0
[ "$RETVAL" -gt  "1" ] && exit 1

ogMountCache >/dev/null

## Si no existe, crear subdirectorio para el fichero en la cache.
IMGDIR=$(ogGetParentPath CACHE "/$2")
if [ $? != 0 ]; then
    echo "[5] $MSG_HELP_ogMakeDir  \"$2 $(dirname "$2")."
    ogMakeDir CACHE $(dirname "/$2")
    IMGDIR=$(ogGetParentPath CACHE "/$2") || exit $?
fi

TIME1=$SECONDS

case "$PROTOCOLO" in
	torrent | TORRENT )
		echo "ogCopyFile $1 $2.torrent absolute $OGCAC/$OGIMG"
		# tiempos 
		timewait=$(expr $(printf '%d\n' 0x$(ogGetMacAddress | awk -F: '{print $5$6}')) \* 120 / 65535)                         
		ogCopyFile $REPOSITORIO "$2.torrent" "$IMGDIR"
		#TODO: comprobar que el tracker definido en el fichero es correcto.
    		#TODO comprobar que el fichero torrent está en cache
		# retardamos el inicio -aleatorio de 0 a 120 segundos- al tracker para gestionar mas de +-40 equipos 
		P2PWAIT=$[ ( $RANDOM % 120 )  + 1 ]
		echo "   [ ] $MSG_SCRIPTS_TASK_SLEEP :  $P2PWAIT seconds ogTorrentStart CACHE $2.torrent $4" | tee -a $OGLOGSESSION $OGLOGFILE
		sleep $P2PWAIT
		echo "   [  ] $MSG_SCRIPTS_TASK_START:  ogTorrentStart CACHE $2.torrent $4" | tee -a $OGLOGSESSION $OGLOGFILE
		ogTorrentStart CACHE "$2.torrent" $4
		RESUMEUPDATECACHE=$(cat $OGLOGCOMMAND | grep -B1 "Download") 
	;;
	multicast | MULTICAST )
		PORT=$(echo $OPTPROTOCOLO | cut -f1 -d":")
		let PORTAUX=$PORT+1
		echo "$MSG_SCRIPTS_UPDATECACHE_CHECKMCASTSESSION : $REPOIP:$PORTAUX:$PORT"
        #TODO: ticket 379
		NUMBER=$[ ( $RANDOM % 30 )  + 1 ]
		sleep $NUMBER
		#FIN TODO
		if (nmap -n -sU -p $PORTAUX $REPOIP | grep open)
		then 
	   		ogMcastReceiverFile $PORT CACHE "$2"
		else
		    # TODO ticket 379 Realizar la petición basada en identificador de operacion
	   		echo "$MSG_SCRIPTS_TASK_START :  hose $REPOIP 2009 --out sh -c "echo -ne START_MULTICAST $2 $OPTPROTOCOLO""
	   		hose $REPOIP 2009 --out sh -c "echo -ne START_MULTICAST $2 $OPTPROTOCOLO"
	   		#echo "espero y llamo a: ogMcastReceiverFile $PORT CACHE $2"
	   		sleep 10
	   		if (nmap -n -sU -p $PORTAUX $REPOIP | grep open)
	   		then 
	   			ogMcastReceiverFile $PORT CACHE "$2"
			else
			    echo "$MSG_SCRIPTS_TASK_ERR : hose $REPOIP 2009 --out sh -c echo -ne START_MULTICAST $2 $OPTPROTOCOLO"
	   		    exit 1
	   		fi
		fi
		#cat $OGLOGCOMMAND.tmp | grep -B1 "Transfer complete"
		sleep 5
		#cat $OGLOGCOMMAND.tmp | grep -B1 "Transfer complete"
		RESUMEUPDATECACHE=$(cat $OGLOGCOMMAND.tmp | grep -B1 "Transfer complete")
	;;
	unicast | UNICAST )
		echo "unicast"
		ogCopyFile $REPOSITORIO "$2" "$IMGDIR"
	;;
	RSYNC)
		USERRSYNC="opengnsys"
		OPTRSYNC=" --delete --password-file=/scripts/passrsync "
		[ "$ogcompress" ==  "true" ] && OPTRSYNC="z $OPTRSYNC"
		IMGEXT=${2##*.} 
		DIRMOUNT="$(ogGetMountDir "${2%%.*}" $IMGEXT)"
		DIRLOCAL="/tmp/$DIRMOUNT"
		mkdir $DIRLOCAL 2>/dev/null
		echo "$MSG_SCRIPTS_UPDATECACHE_CHECKSIZEIMG" 


		if [ $CACHEFILESIZE -lt $REALFILESIZE ]; then
		   # Si la imagen esta montada la desmonto
		   mount |grep $CACHEFILE >/dev/null && umount $CACHEFILE
		   echo "      $MSG_SYNC_RESIZE." | tee -a $OGLOGSESSION $OGLOGFILE
                   echo "      truncate --size=>$REALFILESIZE k $CACHEFILE" | tee -a $OGLOGSESSION $OGLOGFILE
                   truncate --size=">$REALFILESIZE"k $CACHEFILE &> $OGLOGCOMMAND
                   echo "      mount -o compress=lzo $CACHEFILE $DIRLOCAL"
                   mount -o compress=lzo $CACHEFILE $DIRLOCAL
                   echo "      btrfs filesystem resize max $DIRLOCAL"
                   btrfs filesystem resize max $DIRLOCAL
                   TIMEAUX3=$[SECONDS-TIMEAUX3]
                   echo "      $MSG_SCRIPTS_TASK_END, $MSG_SCRIPTS_TIME_PARTIAL: $[TIMEAUX3/60]m $[TIMEAUX3%60]s" | tee -a $OGLOGSESSION $OGLOGFILE
  

		fi
		# Montamos las imagenes para sincronizarlas
		ogMountImage CACHE  "${2%%.*}" $IMGEXT >/dev/null
		ogMountImage REPO  "${2%%.*}" $IMGEXT >/dev/null
		# Esperamos que se monte la imagen en el servidor
		ogWaitMountImage  REPO  "${2%%.*}" $IMGEXT
		echo -e "\n      rsync -aHAX OPTRSYNC  --quiet $USERRSYNC@$REPOIP::ogimages/$DIRMOUNT/ $DIRLOCAL |tee -a $OGLOGSESSION $OGLOGFILE"
		rsync -aHAX$OPTRSYNC  --quiet $USERRSYNC@$REPOIP::ogimages/$DIRMOUNT/ $DIRLOCAL |tee -a $OGLOGSESSION $OGLOGFILE
		# RETVAL="1" -> OK  RETVAL="2" -> error  # valores igual que ogUpdateCacheIsNecesary
		[ $? == 0 ] && RETVAL="1"|| RETVAL="2"
		# Desmonto las imagenes
		ogUnmountImage CACHE  "${2%%.*}" $IMGEXT
		ogUnmountImage REPO  "${2%%.*}" $IMGEXT
	;;
esac

TIME1=$[SECONDS-TIME1]
echo "   [ ] $RESUMEUPDATECACHE " | tee -a $OGLOGSESSION $OGLOGFILE
echo "   [ ] $MSG_SCRIPTS_TIME_PARTIAL updateCache $[TIME1/60]m $[TIME1%60]s" | tee -a $OGLOGSESSION $OGLOGFILE
echo "   [ ] $MSG_SCRIPTS_TASK_START $MSG_HELP_ogCalculateChecksum " | tee -a $OGLOGSESSION $OGLOGFILE
TIME2=$SECONDS
if [ "$IMGTYPE" == "MONOLITICA" ]; then 
	ogUpdateCacheIsNecesary $REPOSITORIO "$2"
	RETVAL=$?
fi

TIME2=$[SECONDS-TIME2]
echo "   [ ] $MSG_SCRIPTS_TIME_PARTIAL $MSG_HELP_ogCalculateChecksum $[TIME2/60]m $[TIME2%60]s" | tee -a $OGLOGSESSION $OGLOGFILE

# si RETVAL=0 => actualizamos  si RETVAL=1 no actaulizasmo-exit 0  || si RETVAL>2 exit 1
[ "$RETVAL" == "0" ] && exit 1
[ "$RETVAL" == "1" ] && exit 0
[ "$RETVAL" -gt  "1" ] && exit 1

