#!/bin/bash


#/**
#         updateCache
#@brief   Actualiza la cache del cliente con imagen o fichero iso.
#@param 1 REPO          Origen del fichero. -accesible por nfs-samba-
#@param 2 str_fichero   nombre del fichero a actualizar.
#@param 3 str_protoco.  TORRENT | MULTICAST    | UNICAST.
#@param 4 str_opcionesprotocolo
#@param 4 str_opcionesupdatecache
#@ejemplo: oneRemoteFromMaster 172.17.36.11 CACHE /imagen1 9000:full-duplex:239.194.17.36:70M:50:100 1 1 partclone lzop 
#@return  
#@exception OG_ERR_FORMAT       formato incorrecto.
#@exception OG_ERR_NOTCACHE     No existe cache -15-
#@exception $OG_ERR_CACHESIZE   Tamaño de la paticion menor al archivo a descargar -16-
#@note   
#@todo: 
#@version 0.9.1 - integracion EAC
#@author  Antonio J. Doblas Viso. Universidad de Malaga.
#@date    2008/03/17
#@version 0.9.2 - integracion OpenGnsys
#@author  Antonio J. Doblas Viso. Universidad de Malaga.
#@date    2010/07/27
#@version 1.0.1 - Control de espacio requerido
#@author  Antonio J.Doblas Viso
#@date   2011-05-10
#@version 2.0.1 - Imagenes sincronizadas
#@date    2013-02-20
#*/ ##

PROG="$(basename $0)"
if [ $# -lt 3 ]; then
    ogRaiseError $OG_ERR_FORMAT "$MSG_FORMAT: $PROG str_REPO _str_Relative_Path_OGIMG_with_/ PROTOCOLO OPCIONES_PROTOCOLO OPCIONES_UPDATECACHE" 2>&1  | tee -a $OGLOGSESSION $OGLOGFILE
    exit ${PIPESTATUS[0]}
fi

#Carga del configurador del engine
[ -z $OGENGINECONFIGURATE ] && source /opt/opengnsys/etc/engine.cfg

# Clear temporary file used as log track by httpdlog
# Limpia los ficheros temporales usados como log de seguimiento para httpdlog
echo " " > $OGLOGCOMMAND
[ "$(ogGetCaller)" == "deployImage" ] || echo -n "" > $OGLOGSESSION;

REPOSITORIO="${1^^}"
PROTOCOLO="${3^^}"
OPTPROTOCOLO="$4"
REPOIP=$(ogGetRepoIp)
echo $REPOSITORIO $REPOIP $PROTOCOLO $OPTPROTOCOLO

# Si el repositorio local CACHE no existe error 15.
if ! $(ogFindCache >/dev/null); then
        ogRaiseError $OG_ERR_NOTCACHE "CACHE" 2>&1 | tee -a $OGLOGSESSION $OGLOGFILE
        exit ${PIPESTATUS[0]}
fi

# comprobar si la imagen existe (.img, .img.diff o directorio)
REPOFILE=$(ogGetPath "REPO" "/$2") 
if [ "$REPOFILE" == "" ]; then
	ogRaiseError $OG_ERR_NOTFOUND "REPO /$2" 2>&1 | tee -a $OGLOGSESSION $OGLOGFILE
	exit ${PIPESTATUS[0]}
fi

echo "$MSG_SCRIPTS_UPDATECACHE_DOUPDATE " | tee -a $OGLOGSESSION $OGLOGFILE
# Distingo si es monolitica o sincronizable
file "$REPOFILE" | grep -i -e " BTRFS Filesystem " -e " ext4 filesystem " -e " directory" 2>&1 > /dev/null
if [ $? == 0 ]; then
	IMGSYNC=TRUE
	# Para imagen sincronizada, si hay imagen en cache siempre protocolo = rsync.
	CACHEFILE="$(ogGetPath "CACHE" "/$2")"  && PROTOCOLO="RSYNC"
	# Si es sincronizada tipo directorio  siempre protocolo = rsync.
	[ -d $REPOFILE ] && PROTOCOLO="RSYNC" && IMGTYPE="dir"

	# Si es imagen sincronizada siempre da distinto md5. No podemos comprobar -> actualizamos.
	RETVAL=0
else
	# Si la imagen es monolitica y ha elegido protocolo = RSYNC salimos con error.
	if [ $PROTOCOLO == "RSYNC" ]; then
		ogRaiseError $OG_ERR_DONTSYNC_IMAGE "REPO $2" 2>&1| tee -a $OGLOGSESSION $OGLOGFILE
		exit ${PIPESTATUS[0]}
	fi	
	IMGSYNC=FALSE
	#TODO: ogUpdateCacheIsNecesary debe borrar la imagen que tenga igual nombre pero distinto sum-
	ogUpdateCacheIsNecesary $1 $2
	RETVAL=$?
fi
# si RETVAL=0 => actualizamos  si RETVAL=1 no actaulizasmo-exit 0  || si RETVAL>2 exit 1
[ "$RETVAL" == "1" ] && exit 0
[ "$RETVAL" -gt  "1" ] && exit 1

echo "$MSG_SCRIPTS_UPDATECACHE_CHECKSIZECACHE" | tee -a $OGLOGSESSION $OGLOGFILE
CACHESIZE=$(ogGetCacheSize)
CACHESIZEFREE=$(ogGetFreeSize `ogFindCache`)
FILESIZE=$(ls -sk $(ogGetPath $REPOSITORIO "$2") | cut -f1 -d" ")
if [ "$IMGTYPE" == "dir" ]; then
	echo "   * $MSG_SCRIPTS_UPDATECACHE_CHECKSIZEDIR" | tee -a $OGLOGSESSION $OGLOGFILE
	echo "     du -sk $REPOFILE" | tee -a $OGLOGSESSION $OGLOGFILE
	REALFILESIZE=$(du -sk "$REPOFILE"|awk '{print $1}')
else
	REALFILESIZE=$(ls -l --block-size=1024 $REPOFILE | cut -f5 -d" ")
fi

# La sincronizada, si existe la imagen en cache el espacio necesario
#	 es la nueva menos lo que ocupa la que ya hay.
if [ "$PROTOCOLO" == "RSYNC" ]; then
	if [ "$CACHEFILE" == "" ]; then
		CACHEFILESIZE=0
	else
	   if [ "$IMGTYPE" == "dir" ]; then
		echo "   * $MSG_SCRIPTS_UPDATECACHE_CHECKSIZEDIR $CACHEFILESIZE" | tee -a $OGLOGSESSION $OGLOGFILE
		echo "     du -sk $CACHEFILE" | tee -a $OGLOGSESSION $OGLOGFILE
		CACHEFILESIZE=$(du -sk $CACHEFILE |awk '{print $1}')
	   else
		CACHEFILESIZE=$(ls -l --block-size=1024 "$CACHEFILE" | cut -f5 -d" ")
	   fi
	fi
	let SIZEREQUIRED=$REALFILESIZE-$CACHEFILESIZE
	[ $SIZEREQUIRED -lt 0 ] && SIZEREQUIRED=0
else
	SIZEREQUIRED=$FILESIZE
fi

#ERROR CACHESIZE 16
if [ "$SIZEREQUIRED" -ge "$CACHESIZE" ]  
then
	echo "$MSG_WARNING: $MSG_ERR_CACHESIZE:  $2 = $SIZEREQUIRED > CACHE = $CACHESIZE" | tee -a $OGLOGSESSION $OGLOGFILE
	ogRaiseError $OG_ERR_CACHESIZE "CACHE" 2>&1 | tee -a $OGLOGSESSION $OGLOGFILE
	exit ${PIPESTATUS[0]}
fi

echo "$MSG_SCRIPTS_UPDATECACHE_IFNOTCACHEDO" | tee -a $OGLOGSESSION $OGLOGFILE
#ERROR CACHESIZE 16
if [ "$SIZEREQUIRED" -ge "$CACHESIZEFREE" ]  
then
	# echo "[ ] No hay espacio sufiente en la CACHE, detectar que hacer con engine.cfg"  | tee -a $OGLOGSESSION $OGLOGFILE
	case "$ACTIONCACHEFULL" in 
	NONE)
		NEXTOPERATION=UNICAST
	;;
	FORMAT)
	    echo "[51] $MSG_HELP_ogFormatCache "  | tee -a $OGLOGSESSION $OGLOGFILE
	    ogUnmountCache
	    ogFormatCache
	    ogMountCache
	    NEXTOPERATION=REPEAT
	;;
	DELETE)
	    echo "[51] #MSG_HELP_ogDeleteTree $OGCAC$OGIMG/* "  | tee -a $OGLOGSESSION $OGLOGFILE
	    rm -fr  $OGCAC$OGIMG/*
	    NEXOPERATION=REPEAT
	;;
	*)
	 	echo "$MSG_WARNING: $MSG_ERR_CACHESIZE:  $2 = $FILESIZE > CACHE = $CACHESIZEFREE" | tee -a $OGLOGSESSION $OGLOGFILE
		ogRaiseError $OG_ERR_CACHESIZE "CACHE" 2>&1 | tee -a $OGLOGSESSION $OGLOGFILE
		exit ${PIPESTATUS[0]}
	;;
	esac	
fi

# Comprobamos que imagen cache igual a la del repo. Si sincronizada no podemos comprobar. 
[ "$IMGSYNC" == "TRUE" ] || ogUpdateCacheIsNecesary $REPOSITORIO "$2"
RETVAL=$?
# si RETVAL=0 => actualizamos  si RETVAL=1 no actaulizasmo-exit 0  || si RETVAL>2 exit 1
[ "$RETVAL" == "1" ] && exit 0
[ "$RETVAL" -gt  "1" ] && exit 1

ogMountCache >/dev/null

## Si no existe, crear subdirectorio para el fichero en la cache.
IMGDIR=$(ogGetParentPath CACHE "/$2")
if [ $? != 0 ]; then
    echo "[5] $MSG_HELP_ogMakeDir  \"$2 $(dirname "$2")." | tee -a $OGLOGSESSION $OGLOGFILE
    ogMakeDir CACHE $(dirname "/$2")
    IMGDIR=$(ogGetParentPath CACHE "/$2") || exit $?
fi

TIME1=$SECONDS

case "$PROTOCOLO" in
	TORRENT)
		echo "ogCopyFile $1 $2.torrent absolute $OGCAC/$OGIMG" | tee -a $OGLOGSESSION $OGLOGFILE
		# tiempos 
		timewait=$(expr $(printf '%d\n' 0x$(ogGetMacAddress | awk -F: '{print $5$6}')) \* 120 / 65535)                         
		ogCopyFile $REPOSITORIO "$2.torrent" "$IMGDIR" 2>&1 | tee -a   $OGLOGCOMMAND
		#TODO: comprobar que el tracker definido en el fichero es correcto.
    		#TODO comprobar que el fichero torrent está en cache
		# retardamos el inicio -aleatorio de 0 a 120 segundos- al tracker para gestionar mas de +-40 equipos 
		P2PWAIT=$[ ( $RANDOM % 120 )  + 1 ]
		echo "   [ ] $MSG_SCRIPTS_TASK_SLEEP :  $P2PWAIT seconds ogTorrentStart CACHE $2.torrent $4" | tee -a $OGLOGSESSION $OGLOGFILE
		sleep $P2PWAIT
		echo "   [  ] $MSG_SCRIPTS_TASK_START:  ogTorrentStart CACHE $2.torrent $4" | tee -a $OGLOGSESSION $OGLOGFILE
		ogTorrentStart CACHE "$2.torrent" $4 2>&1 | tee -a   $OGLOGCOMMAND
		RESUMEUPDATECACHE=$(grep -m 1 -B1 "Download" $OGLOGCOMMAND) 
	;;
	MULTICAST)
		PORT=$(echo $OPTPROTOCOLO | cut -f1 -d":")
		let PORTAUX=$PORT+1
		echo "$MSG_SCRIPTS_UPDATECACHE_CHECKMCASTSESSION : $REPOIP:$PORTAUX:$PORT" | tee -a $OGLOGSESSION $OGLOGFILE
		#TODO: ticket 379
		NUMBER=$[ ( $RANDOM % 30 )  + 1 ]
		sleep $NUMBER
		#FIN TODO
		if (nmap -n -sU -p $PORTAUX $REPOIP | grep open)
		then 
	   		ogMcastReceiverFile $PORT CACHE "$2" 2>&1  | tee -a   $OGLOGCOMMAND

		else
		    # TODO ticket 379 Realizar la petición basada en identificador de operacion
	   		echo "$MSG_SCRIPTS_TASK_START :  hose $REPOIP 2009 --out sh -c "echo -ne START_MULTICAST $2 $OPTPROTOCOLO"" | tee -a $OGLOGSESSION $OGLOGFILE
	   		hose $REPOIP 2009 --out sh -c "echo -ne START_MULTICAST $2 $OPTPROTOCOLO"
	   		#echo "espero y llamo a: ogMcastReceiverFile $PORT CACHE $2"
	   		sleep 10
	   		if (nmap -n -sU -p $PORTAUX $REPOIP | grep open)
	   		then 
	   			ogMcastReceiverFile $PORT CACHE "$2" 2>&1  | tee -a   $OGLOGCOMMAND

			else
			    echo "$MSG_SCRIPTS_TASK_ERR : hose $REPOIP 2009 --out sh -c echo -ne START_MULTICAST $2 $OPTPROTOCOLO" | tee -a $OGLOGSESSION $OGLOGFILE
	   		    exit 1
	   		fi
		fi
		#cat $OGLOGCOMMAND.tmp | grep -B1 "Transfer complete"
		sleep 5
		#cat $OGLOGCOMMAND.tmp | grep -B1 "Transfer complete"
		RESUMEUPDATECACHE=$(grep -m 1  -B1 "Transfer complete" $OGLOGCOMMAND.tmp)
	;;
	UNICAST)
		echo "unicast" | tee -a $OGLOGSESSION $OGLOGFILE
		ogCopyFile $REPOSITORIO "$2" "$IMGDIR" 2>&1  | tee -a   $OGLOGCOMMAND
		sleep 5
		RESUMEUPDATECACHE=$(grep -m 1  "100%" $OGLOGCOMMAND.tmp)
	;;
	RSYNC)
	   # Opciones de rsync
	   USERRSYNC="opengnsys"
	   PASSWORD=" --password-file=/scripts/passrsync "
	   OPTRSYNC=" --delete --progress "
	   [ "$ogrsyncz" ==  "true" ] && OPTRSYNC="z $OPTRSYNC"
	   [ "$ogrsyncw" ==  "true" ] && OPTRSYNC="w$OPTRSYNC"

	   if [ -d $REPOFILE ]; then
		# Si es sincronizada tipo directorio.
		[ -d "$OGCAC$OGIMG/$2" ] || mkdir "$OGCAC$OGIMG/$2"
		echo "rsync -aHAX$OPTRSYNC  $USERRSYNC@$REPOIP::ogimages/$2/ $OGCAC$OGIMG/$2" |tee -a $OGLOGSESSION $OGLOGFILE
		rsync -aHAX$OPTRSYNC  $PASSWORD "$USERRSYNC@$REPOIP::ogimages/$2/" "$OGCAC$OGIMG/$2" 2>&1  | egrep "^sent|^sending|^total%" >>  $OGLOGCOMMAND
           else
		# Si es sincronizada tipo archivo.
		[ "${2##*.}" == "img" ] && IMGTYPE="img" ||  IMGTYPE="diff"
		IMGNAME="${2%.img*}"

		DIRMOUNT=$(ogGetMountImageDir "$IMGNAME" $IMGTYPE)
		DIRLOCAL="/tmp/$DIRMOUNT"
		mkdir "$DIRLOCAL" 2>/dev/null
		echo "$MSG_SCRIPTS_UPDATECACHE_CHECKSIZEIMG"  | tee -a $OGLOGSESSION $OGLOGFILE

		# Si la imagen no existe la creo
		# Si la imagen del repositorio es mayor, redimensiono la imagen de cache
		if [ "$CACHEFILE" == "" -o  $CACHEFILESIZE -lt $REALFILESIZE ]; then
		   echo "$MSG_HELP_ogCreateFileImage" | tee -a $OGLOGSESSION $OGLOGFILE
		   ogCreateFileImage CACHE "$IMGNAME" $IMGTYPE $REALFILESIZE 
                   TIMEAUX3=$[SECONDS-TIMEAUX3]
                   echo "      $MSG_SCRIPTS_TASK_END, $MSG_SCRIPTS_TIME_PARTIAL: $[TIMEAUX3/60]m $[TIMEAUX3%60]s" | tee -a $OGLOGSESSION $OGLOGFILE
		fi
		# Montamos las imagenes para sincronizarlas. Quitamos / inicial.
		ogMountImage CACHE  "${IMGNAME#\/}" $IMGTYPE >/dev/null
		ogMountImage REPO  "${IMGNAME#\/}" $IMGTYPE >/dev/null
		# Esperamos que se monte la imagen en el servidor
		ogWaitMountImage  REPO  "$IMGNAME" $IMGTYPE
		echo "$MSG_HELP_ogSyncCreate" | tee -a $OGLOGSESSION $OGLOGFILE
		echo "rsync -aHAX$OPTRSYNC  $USERRSYNC@$REPOIP::ogimages/$DIRMOUNT/ $DIRLOCAL" |tee -a $OGLOGSESSION $OGLOGFILE
		rsync -aHAX$OPTRSYNC  $PASSWORD "$USERRSYNC@$REPOIP::ogimages/$DIRMOUNT/" "$DIRLOCAL" 2>&1  | egrep "^sent|^sending|^total|%" >>   $OGLOGCOMMAND
		# RETVAL="1" -> OK  RETVAL="2" -> error  # valores igual que ogUpdateCacheIsNecesary
		[ ${PIPESTATUS[0]} == 0 ] && RETVAL="1"|| RETVAL="2"
		# Desmonto las imagenes
		ogUnmountImage CACHE  "$IMGNAME" $IMGTYPE
		ogUnmountImage REPO  "$IMGNAME" $IMGTYPE
	   fi
	;;
esac

TIME1=$[SECONDS-TIME1]

echo "   [ ] $RESUMEUPDATECACHE " | tee -a $OGLOGSESSION $OGLOGFILE
echo "   [ ] $MSG_SCRIPTS_TIME_PARTIAL updateCache $[TIME1/60]m $[TIME1%60]s" | tee -a $OGLOGSESSION $OGLOGFILE
echo "   [ ] $MSG_SCRIPTS_TASK_START $MSG_HELP_ogCalculateChecksum " | tee -a $OGLOGSESSION $OGLOGFILE
TIME2=$SECONDS
# Si es imagen sincronizada siempre da distinto md5. No podemos comprobar 
if [ "$IMGSYNC" == "TRUE" ]; then 
	# RETVAL="1" -> OK  RETVAL="2" -> error  # valores igual que ogUpdateCacheIsNecesary
	[ $PROTOCOLO == "RSYNC" ] || RETVAL=1
else
	ogUpdateCacheIsNecesary $REPOSITORIO "$2"
	RETVAL=$?
fi

if [ "$(ogGetCaller)" != "deployImage" ]; then
	TIME2=$[SECONDS-TIME2]
	echo "   [ ] $MSG_SCRIPTS_TIME_PARTIAL $MSG_HELP_ogCalculateChecksum $[TIME2/60]m $[TIME2%60]s" | tee -a $OGLOGSESSION $OGLOGFILE
fi
# si RETVAL=0 => actualizamos  si RETVAL=1 no actaulizamos-exit 0  || si RETVAL>2 exit 1
[ "$RETVAL" == "0" ] && exit 1
[ "$RETVAL" == "1" ] && exit 0
[ "$RETVAL" -gt  "1" ] && exit 1

