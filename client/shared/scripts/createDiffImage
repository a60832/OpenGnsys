#!/bin/bash

#/**
#         createDiffImage
#@brief   Script de ejemplo para crear una imagen diferencial de un sistema de archivos.
#@brief (puede usarse como base para el programa de creación de imágenes usado por OpenGnSys Admin).
#@param 1 disco 
#@param 2 particion 
#@param 3 REPO|CACHE
#@param 4 imagen_completa
#@param 5 imagen_diferencial
#@return  
#@exception OG_ERR_FORMAT     # 1 formato incorrecto.
#@exception OG_ERR_PARTITION  # 3 Error en partición de disco o en su sistema de archivos
#@exception OG_ERR_NOTFOUND   # Fichero de registro no encontrado.
#@exception OG_ERR_IMAGE      # 5 Error en funcion ogCreateImage o ogRestoreImage.
#@exception OG_ERR_NOTWRITE   # 14 error de escritura
#@exception OG_ERR_NOTCACHE   # 15 si cache no existe 15
#@exception OG_ERR_CACHESIZE  # 16 si espacio de la cache local o remota no tiene espacio 16
#@note  Se toma como punto de partida el script createImage.
#@todo: que hacer, si el tamaño de la cache es sufciente, pero no tiene espacio libre
#@version 1.0 - creacion de la diferencial con rsync y mksquash
#@author  
#@date   2012-12-04
#*/ ##
trap "ogUnlockImage $3 \"/$4.$IMGEXT\"; ogUnlockImage $3 \"/$5.$DIFFEXT\"; ogUnlock $1 $2; ogUnmountImage $3 \"$5\" $DIFFEXT; ogUnmountImage $3 \"$4\" $IMGEXT ; exit 1" 1 2 3 6 9 14 15

#Carga el configurador del engine desde el fichero engine.cfg
[ -z $OGENGINECONFIGURATE ] &&  source /opt/opengnsys/etc/engine.cfg
# opciones de rsync
CREATESPEED=${CREATESPEED:-"100000*4"}

TIME1=$SECONDS


PROG="$(basename $0)"
if [ $# -lt 5 ]; then
    ogRaiseError $OG_ERR_FORMAT "$MSG_FORMAT: $PROG ndisco nparticion REPO|CACHE base_image diff_image"
    exit $?
fi

# Valores por defecto en etc/engine.cfg
IMGEXT="img"
DIFFEXT="diff"

echo "[1] $MSG_SCRIPTS_START $0 $*" | tee -a $OGLOGSESSION $OGLOGFILE

# Comprobamos si la imagen diferencial o la particion estan bloqueada:
ogIsImageLocked "$3" "$5.$DIFFEXT" && exit $(ogRaiseError $OG_ERR_LOCKED "$3 $5.$DIFFEXT"; echo $?)
ogIsLocked "$1" "$2" && exit $(ogRaiseError $OG_ERR_LOCKED  "$1 $2"; echo $?)

# Comprobar si la imagen completa existe.
IMGFILE=$(ogGetPath "$3" "$4.$IMGEXT") || exit $(ogRaiseError $OG_ERR_NOTFOUND "$3 $4.$IMGEXT"; echo $?)

# Comprobar que es sincronizable
#echo "      Comprobamos que la imagen es sincronizable" 
file $IMGFILE | grep " BTRFS Filesystem" >/dev/null 
[ $? == 0 ] ||  exit  $(ogRaiseError $OG_ERR_IMAGE "$3 $4"; echo $?) 
# Comprobar que no está bloqueada
ogIsImageLocked "$3" "$4.$IMGEXT" && exit $(ogRaiseError $OG_ERR_LOCKED "$3 $4.$IMGEXT"; echo $?)

echo " " > $OGLOGCOMMAND
# Si el repositorio es CACHE comprobamos que exista
if [ "$3" == "CACHE" -o "$3" == "cache" ]; then
        ! ogFindCache >/dev/null && exit $(ogRaiseError $OG_ERR_NOTCACHE "CACHE "; echo $?)
fi

echo " " > $OGLOGCOMMAND

# Obtener información de los parámetros de entrada.
PART=$(ogDiskToDev "$1" "$2" 2>/dev/null) || exit $(ogRaiseError $OG_ERR_PARTITION "$1 $2"; echo $?)

# Comprobamos que la partición se puede montar.
ORIG=$(ogMount $1 $2) ||  exit $(ogRaiseError $OG_ERR_PARTITION "$1 $2"; echo $?) 

#Comprobamos acceso de escritura.
DIRTEMP=$(date +%Y%m%d-%H%M%S)
ogMakeDir $3 /$4$DIRTEMP 2>/dev/null || exit $(ogRaiseError $OG_ERR_NOTWRITE "$3"; echo $?) && ogDeleteTree $3 /$4$DIRTEMP 
DIFFDIR="$(ogGetParentPath "$3" "/$5")"
DIFFFILE="$DIFFDIR/$5.$DIFFEXT"

ogLockImage "$3"  "/$4.$IMGEXT"
ogLockImage "$3"  "/$5.$DIFFEXT"
LOOPDEVICE=$(losetup -f)

# Comprobar consistencia del sistema de archivos.
echo " " > $OGLOGCOMMAND
SIZEFS=$(ogGetFsSize  $1 $2)
echo "[20] $MSG_HELP_ogCheckFs  $1 $2 $SIZEFS (KB) " | tee -a $OGLOGSESSION $OGLOGFILE
ogUnmount $1 $2
#### TODO: comprobar que la salida de errores va bien
ogCheckFs $1 $2 >$OGLOGCOMMAND || exit $(ogRaiseError $OG_ERR_PARTITION "ogCheckFs $1 $2" && echo $?)

TIMEAUX1=$[SECONDS-TIME1]
echo "      Fin chequeo sistema de ficheros : $[TIMEAUX1/60]m $[TIMEAUX1%60]s" | tee -a $OGLOGSESSION $OGLOGFILE

# Crear la imagen.
echo " " > $OGLOGCOMMAND
TIME2=$SECONDS
echo "[40] Genera imagen diferencial de la particion $1 $2 respecto a la imagen $3 $4" | tee -a $OGLOGSESSION $OGLOGFILE
# Creamos la lista del contenido y lo situamos en la particion a copiar.
FSTYPE=$(ogGetFsType $1 $2)

IMGDIRAUX=$(ogGetMountDir "$4" $IMGEXT)

# Montamos imagen completa (con la que vamos a comparar)
ogMountImage $3 "$4" $IMGEXT

# Comprobar que la imagen completa se ha montado 
ogWaitMountImage $3 "$4" $IMGEXT || exit $(ogRaiseError "Error al montar la imagen $1 $2 $3: time_out $TIMEAUX seg."; echo $?)
echo "[50] Creamos información de las diferencias"
echo ogCreateInfoImage $1 $2 $3 "$4" "$DIFFEXT"
ogCreateInfoImage $1 $2 $3 "$4" "$DIFFEXT"
TIMEAUX3=$[SECONDS-TIME2]
echo "      Fin listado contenido y lista de control de acceso: $[TIMEAUX3/60]m $[TIMEAUX3%60]s" | tee -a $OGLOGSESSION $OGLOGFILE
#Calculamos el tamaño de la imagen:
ogMount $1 $2
ogLock $1 $2
cd $ORIG

SIZEREQUIRED=$(cat /tmp/ogimg.info | tr '\n' '\0'| du -c --files0-from=- 2>/dev/null|tail -n1 |cut -f1)
let SIZEREQUIRED=SIZEREQUIRED*115/100
# El tamaño mínimo del sistema de ficheros btrfs es 250M, ponemos 300
[ $SIZEREQUIRED -lt 300000 ] && SIZEREQUIRED=300000
TIMEAUX4=$[SECONDS-TIMEAUX3]

# TODO: Comprueba que quepa en el repositorio
[ "$3" == "CACHE" -o "$3" == "cache" ] && SIZEFREE=$(ogGetFreeSize `ogFindCache`) && ogMountCache >/dev/null
[ "$3" == "REPO"  -o "$3" == "repo"  ] && SIZEFREE=$(df -k | grep $OGIMG | awk '{print $4}')
echo "     $MSG_SCRIPTS_CREATE_SIZE  $SIZEREQUIRED $SIZEFREE" | tee -a $OGLOGSESSION $OGLOGFILE
[ $SIZEREQUIRED -gt $SIZEFREE ] && exit $(ogRaiseError $OG_ERR_CACHESIZE "$3" || echo $?)
echo "      Fin calculo tamaño imagen $SIZEREQUIRED: $[TIMEAUX4/60]m $[TIMEAUX4%60]s" | tee -a $OGLOGSESSION $OGLOGFILE

# Creamos o redimensionamos la imagen
echo "[60] Creamos el archivo de la imagen."  | tee -a $OGLOGSESSION $OGLOGFILE
ogCreateFileImage $3 "$5" $DIFFEXT $SIZEREQUIRED

# Esperamos que se monte la imagen despues de crarla en el servidor
ogWaitMountImage "$3" "$5" "$DIFFEXT" $SIZEREQUIRED  ||exit $(ogRaiseError "Error al montar la imagen $1 $2 $3: time_out $TIMEAUX seg."; echo $?)

TIMEAUX6=$[SECONDS-TIMEAUX5]
echo  -e "      Fin preparacion imagen: $[TIMEAUX6/60]m $[TIMEAUX6%60]s" | tee -a $OGLOGSESSION $OGLOGFILE

echo "[80] Sincronizo los datos de la imagen."
# Copio los datos a la imagen diferecial :
ogSyncCreate $1 $2 $3 "$5" $DIFFEXT

ogUnmountImage $3 "$5" $DIFFEXT
ogUnmountImage $3 "$4" $IMGEXT

TIMEAUX7=$[SECONDS-TIMEAUX6]
echo "      Fin copia dato a diferencial: $[TIMEAUX7/60]m $[TIMEAUX7%60]s" | tee -a $OGLOGSESSION $OGLOGFILE


TIMEAUX8=$[SECONDS-TIME2]
echo "      $MSG_SCRIPTS_TIME_PARTIAL : $[TIMEAUX8/60]m $[TIMEAUX8%60]s" | tee -a $OGLOGSESSION $OGLOGFILE

ogUnlockImage "$3" "/$4.$IMGEXT"
ogUnlockImage "$3" "/$5.$DIFFEXT"
ogUnlock $1 $2

# Comprobamos que la imagen esta bien
echo file "$DIFFFILE" |grep "BTRFS Filesystem"
file "$DIFFFILE" |grep "BTRFS Filesystem" >/dev/null
[ $? == 0 ] ||  exit  $(ogRaiseError $OG_ERR_IMAGE "$3 $4"; echo $?)

#resumen de la operacion
IMGSIZE=$(ls -s ${DIFFFILE[CACHE]}| cut -f1 -d" ")
#IMGOS=$(ogGetImageInfo `ogGetPath $3 $4.img`) NO FUNCIONA Hay que modificar la funcion para las imagenes squash

TIME=$[SECONDS-TIME1]
echo "[100] $MSG_SCRIPTS_TIME_TOTAL $[TIME/60]m $[TIME%60]s" | tee -a $OGLOGSESSION $OGLOGFILE
echo "      FileSystem $PART with $NEWSIZEFS KB data created onto file-image as $4 and used $IMGSIZE KB acros DFS rsync " | tee -a $OGLOGSESSION $OGLOGFILE
