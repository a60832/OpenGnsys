#!/bin/bash
#/**
#@file    deployImage
#@brief   Proceso completo de despliegue de imagen, incluyendo actualización de la caché, restauración y post-configuración (este script es llamado por la interfaz RestaurarImagen).
#@param   $1 Repositorio (CACHE, REPO o dirección IP)
#@param   $2 Nombre canónico de la imagen (sin extensión)
#@param   $3 Número de disco
#@param   $4 Número de particion
#@param   $5 Protocolo (UNICAST, por defecto, MULTICAST o TORRENT)
#@param   $6 Opciones del protocolo
#@exception OG_ERR_FORMAT   1 formato incorrecto.
#@exception OG_ERR_NOTFOUND  2 fichero de imagen o partición no detectados.
#@exception OG_ERR_PARTITION 3	# Error en partición de disco.
#@exception OG_ERR_LOCKED    4 partición bloqueada por otra operación.
#@exception OG_ERR_IMAGE    5 error al restaurar la imagen del sistema.
#@exception OG_ERR_IMGSIZEPARTITION  30 Tamaño de la particion es menor al tamaño de la imagen.
#@version 1.0.1 - Separación en protocolos de transferencia y postconfiguracion
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2011-05-11
#@version 1.0.1 - Separación de los ficheros-log para ser gestionado por el httpd-log
#@author  Antonio J. Doblas Viso. Universidad de Málaga  
#@date    2011-05-11
#@version 1.0.2 - Logica basada en fichero de configuracion engine.cfg
#@author  Antonio J. Doblas Viso. Universidad de Málaga  
#@date    2012-01-11
#@version 1.0.5 - Renominación del script como "deployImage".
#@author  Antonio J. Doblas Viso y Ramón M. Gómez.
#@date    2013-12-04
#**/


#Descripcion:
# La interfaz detecta:
#    Si Repositorio es el global (REPO) realiza un deploy.
#    Si Repositorio es local (CACHE) realiza un restoreImage CACHE
# El deploy, si detecta que el cliente no tiene una cache con espacio suficiente 
#  -- reazlia un ogRestore REPO



PROG="$(basename $0)"
if [ $# -lt 4 ]; then
    ogRaiseError $OG_ERR_FORMAT "$MSG_FORMAT: $PROG REPO imagen ndisco nparticion [ UNICAST|UNICAST-CACHE|MULTICAST|MULTICAST-CACHE|TORRENT [opciones protocolo] ]"
    exit $?
fi

# Asignación de variables (repositorio y protocolo se convierten a mayúsculas).
TIME1=$SECONDS
REPO="${1^^}"
REPO=${REPO:-"REPO"}
IMGNAME="$2"
DISK="$3"
PART="$4"
PROTO="${5^^}"
PROTO="${PROTO:-"UNICAST"}"
PROTOOPT="$6"

#Load engine configurator from engine.cfg file.
#Carga el configurador del engine desde el fichero engine.cfg
[ -z $OGENGINECONFIGURATE ] && source /opt/opengnsys/etc/engine.cfg

# Clear temporary file used as log track by httpdlog
# Limpia los ficheros temporales usados como log de seguimiento para httpdlog
echo " " > $OGLOGCOMMAND
[ "$(ogGetCaller)" == "EjecutarScript" ] || echo -n "" > $OGLOGSESSION

# Registro de inicio de ejecución
ogEcho log session "[1] $MSG_SCRIPTS_START $0 $*"

# Si el origen(pariticion) esta bloqueada salir.
ogIsLocked $DISK $PART && exit $(ogRaiseError $OG_ERR_LOCKED "$MSG_PARTITION, $DISK $PART"; echo $?)

ogEcho log session "Desmontando $DISK $PART"
ogUnmount $DISK $PART 2>/dev/null

# Valor por defecto para el repositorio.
[ "$REPO" == "$(ogGetRepoIp)" ] && REPO="REPO"
[ "$REPO" == "$(ogGetIpAddress)" ] && REPO="CACHE"

#Informacioin previa de la imagen
IMGOS=$(ogGetImageInfo `ogGetPath $REPO $IMGNAME.img`) || exit $(ogRaiseError $OG_ERR_NOTFOUND "$REPO $3"; echo $?)
IMGSIZE=$(ls -s `ogGetPath $REPO $IMGNAME.img`| cut -f1 -d" ")

ogEcho log session "[1] REPO=$REPO IMG-FILE=$IMGNAME.img  SIZE=$IMGSIZE (KB)   METADATA=$IMGOS"

# Procesar repositorio.
case "$REPO" in
    CACHE)  # Repositorio en caché local.
        NEXTOPERATION=CACHE
    ;;
    REPO)   # Repositorio remoto por defecto.
        case "$PROTO" in
            MULTICAST-DIRECT)
                NEXTOPERATION=MULTICAST
            ;;
            UNICAST-DIRECT)
                NEXTOPERATION=UNICAST
            ;;

            # Si protocolo es torrent|torrent-cache o multicast|multicast-cache
            TORRENT|TORRENT-CACHE|MULTICAST|MULTICAST-CACHE|UNICAST|UNICAST-CACHE)
                ogEcho log session "[2] updateCache REPO \"/$IMGNAME.img\" $PROTO $PROTOOPT"
                TIME2=$SECONDS
                updateCache REPO "/$IMGNAME.img" "$PROTO" "$PROTOOPT"	 	
                RETVAL=$?
                TIME2=$[SECONDS-TIME2]
                ogEcho log session "   [ ]  $MSG_SCRIPTS_TIME_PARTIAL updateCache $[TIME2/60]m $[TIME2%60]s"
                case $RETVAL in
                    0)
                        ogEcho log session "[50] updateCache (OK)"
                        NEXTOPERATION=CACHE
                    ;;
                    15|16)
                        ogEcho log session "[50] $MSG_ERR_NOTCACHE ;  $MSG_ERR_CACHESIZE "
                        ogEcho log session "[50] $MSG_SCRIPTS_CHECK_ENGINE "
                        if [ "$RESTOREPROTOCOLNOCACHE" == "MULTICAST" ]; then
                            case "$PROTO" in
                                MULTICAST)  NEXTOPERATION=MULTICAST ;;
                                TORRENT)    NEXTOPERATION=UNICAST ;;
                                UNICAST)    NEXTOPERATION=UNICAST ;;
                            esac
                        else
                            NEXTOPERATION=UNICAST
                        fi
                    ;;
                esac
            ;;
            *)  # Error: protocolo desconocido.
                ogRaiseError $OG_ERR_FORMAT "$MSG_ERR_FORMAT, $PROTO"
                exit $?
            ;;
        esac
    ;;
    *)  # Error: repositorio desconocido.
        ogRaiseError $OG_ERR_FORMAT "$MSG_ERR_FORMAT, $REPO" 
        exit $?
    ;;
esac

TIME3=$SECONDS

case "$NEXTOPERATION" in
    CACHE)
        ogEcho log session "[55] $MSG_HELP_ogRestoreImage : restoreImage CACHE $IMGNAME $DISK $PART UNICAST"
        restoreImage CACHE "$IMGNAME" "$DISK" "$PART"
        RETVAL=$?
    ;;
    UNICAST)
        ogEcho log session "[55] $MSG_HELP_ogRestoreImage : restoreImage REPO $IMGNAME $DISK $PART UNICAST"
        restoreImage REPO "$IMGNAME" "$DISK" "$PART"
        RETVAL=$?
    ;;
    MULTICAST)
        ogEcho log session "[55] $MSG_HELP_ogRestoreImage : restoreImage REPO $IMGNAME $DISK $PART $PROTO $PROTOOPT"
        restoreImage REPO "$IMGNAME" "$DISK" "$PART" $PROTO $PROTOOPT 
        RETVAL=$?
    ;;
esac
RESUMERESTOREIMAGE=$(grep -m 1 "Total Time:" $OGLOGCOMMAND)
ogEcho log session "   [ ]      $RESUMERESTOREIMAGE " | tee -a $OGLOGSESSION $OGLOGFILE
# Si la transferencia ha dado error me salgo.
if [ $RETVAL -ne 0 ] ; then
	ogRaiseError $OG_ERR_IMAGE "$REPO $IMGNAME" 2>&1
	# Muestro registro de fin de ejecución si no viene de Ejecutar Script
	[ "$(ogGetCaller)" == "EjecutarScript" ] || ogEcho log session "$MSG_INTERFACE_END $OG_ERR_IMAGE"
        exit $OG_ERR_IMAGE
fi
TIME3=$[SECONDS-TIME3]
ogEcho log session "   [ ]      $MSG_SCRIPTS_TIME_PARTIAL : $[TIME3/60]m $[TIME3%60]s"

if which configureOsCustom &>/dev/null; then
    ogEcho log session "[90] configureOsCustom"
    configureOsCustom "$DISK" "$PART"
else
    ogEcho log session "[90] $MSG_SCRIPTS_OS_CONFIGURE "
    configureOs "$DISK" "$PART"
fi

TIME=$[SECONDS-TIME1]
ogEcho log session "[100] $MSG_SCRIPTS_TIME_TOTAL $[TIME/60]m $[TIME%60]s"

# Registro de fin de ejecución
# Si se ha llamado desde ejecutar script no lo muestro para no repetir.
if [ "$(ogGetCaller)" != "EjecutarScript" ] ; then
	ogEcho log session "$MSG_INTERFACE_END $RETVAL"
	exit $RETVAL
fi

