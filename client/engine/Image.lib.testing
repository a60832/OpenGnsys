#!/bin/bash
#/**
#@file    Image.lib
#@brief   Librería o clase Image testing
#@class   Image
#@brief   Funciones para creación, restauración y clonación de imágenes de sistemas.
#@version 0.9
#@warning License: GNU GPLv3+
#*/
#/**
#         ogCheckProgram 
#@brief   Función para determinar si el programa/s están disponibles
#@param 1 programa o programas a comprobar
#@return  0 si está disponible.
#@return  7 si NO está disponible
#@exception OG_ERR_FORMAT     formato incorrecto.
#@exception OG_ERR_NOTEXEC     programas no disponibles.
#@note    
#@TODO: en pruebas
#@version 0.91 - Definición de 
#@author  Antonio Doblas Viso, Universidad de Málaga
#@date    2010/05/09
#*/ ##
#/**
ogCheckProgram ()
{
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME \"str_program1 program2 programN\" " \
		   "$FUNCNAME \"partimage partclone mbuffer\" "
    return
fi

# Error si no se recibe 1 parámetro.
[ $# == 1 ] || ogRaiseError $OG_ERR_FORMAT || return $?

local PERROR PLOG
PERROR=0
PLOG=" "
for i in `echo $1`
do
  if [ ! `which $i` ] 
     then
     	PERROR=1
     	PLOG="$PLOG $i" 
     fi
done
if [ "$PERROR" == "1" ] 
then
	ogRaiseError $OG_ERR_NOTEXEC "$PLOG" || return $?
else    	
	return 0
fi
} 


function ogPartcloneSyntax ()
{
#TODO: comprobar como unico parametro particion /dev/sda1
#COMPAR="partclone.$FS --clone --force --source $PART"
COMPAR="-F -c -s "
TYPE="$(ogGetFsType `ogDevToDisk $1`)"
case "$TYPE" in
    EXT[234])
        echo "partclone.extfs $COMPAR $1"
        ;;
    REISERFS|XFS|JFS)
        echo "partclone.dd $COMPAR $1"
        ;;
    NTFS|HNTFS)
        echo "partclone.ntfs $COMPAR $1"
        ;;
    FAT16|FAT32|HFAT16|HFAT32)
        echo "partclone.fat $COMPAR $1"
        ;;
    HFS|HFS+)
        echo "partclone.hfsp $COMPAR $1"
        ;;
    *)  ogRaiseError $OG_ERR_PARTITION "$1 $TYPE"
        return $? ;;
esac   
}


#/**
#         ogGetImageInfo filename
#@brief   muestra información sobre la imagen monolitica.
#@param 1   filename           path absoluto del fichero imagen
#@return  cadena compuesta por clonacion:compresor:sistemaarchivos:tamañoKB
#@exception OG_ERR_FORMAT    formato incorrecto.
#@exception OG_ERR_NOTFOUND   fichero no encontrado.
#@exception OG_ERR_IMAGE 	"Image format is not valid $IMGFILE"

#@warning En pruebas iniciales
#@TODO    Definir sintaxis de salida (herramienta y compresor en minuscula)
#@TODO 	  Arreglar loop para ntfsclone 
#@TODO    insertar parametros entrada tipo OG
#@version 1.0 - Primeras pruebas
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2010/02/08
#*/ ##

function ogGetImageInfo () {
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME  filename " \
           "$FUNCNAME  /opt/opengnsys/images/prueba.img "
    return
fi

# Error si no se reciben 1 parámetros.
[ $# == 1 ] || ogRaiseError $OG_ERR_FORMAT || return $?

#comprobando que el parametro uno es un file.
[ -f $1 ] || ogRaiseError $OG_ERR_NOTFOUND "$1" || return $?

local TOOLS COMPRESSOR IMGFILE FILEHEAD FS SIZE PARTIMAGEINFO PARTCLONEINFO NTFSCLONEINFO IMGDETECT
IMGDETECT="FALSE"

IMGFILE=$1
FILEHEAD=/tmp/`basename $IMGFILE`.infohead
COMPRESSOR=`file $IMGFILE | awk '{print $2}'`
ogCheckStringInGroup "$COMPRESSOR" "gzip lzop" || ogRaiseError $OG_ERR_IMAGE "Image format is not valid $IMGFILE" || return $?
$($COMPRESSOR -dc $IMGFILE 2>/dev/null | head > $FILEHEAD) || ogRaiseError $OG_ERR_IMAGE "Image format is not valid $IMGFILE" || return $? 

## buscando Primera opción.
if [ "$IMGDETECT" == "FALSE" ] 
then 
	PARTCLONEINFO=$(partclone.info $FILEHEAD 2>&1)
	if `echo $PARTCLONEINFO | grep size > /dev/null`
	then
		TOOLS=PARTCLONE
		FS=$(echo $PARTCLONEINFO | awk '{gsub(/\: /,"\n"); print toupper($8);}')
		SIZE=$(echo $PARTCLONEINFO | awk '{gsub(/\: /,"\n"); printf "%d\n", $11*1024*1024;}')
		IMGDETECT="TRUE"
	fi
fi
#buscando segunda opcion.
if [ "$IMGDETECT" == "FALSE" -a ! -f /dev/loop2  ] 
then 
	cat $FILEHEAD | grep -w ntfsclone-image > /dev/null && NTFSCLONEINFO=$(cat $FILEHEAD | ntfsclone --restore --overwrite /dev/loop2 - 2>&1)
	if `echo $NTFSCLONEINFO | grep ntfsclone > /dev/null`  
	then
		TOOLS=NTFSCLONE
   		SIZE=$(echo $NTFSCLONEINFO | awk '{gsub(/\(|\)|\./,""); printf "%d\n",$17/1000;}')
   		FS=NTFS
   		IMGDETECT="TRUE"
	fi
fi
## buscando Tercer opción. 
if [ "$IMGDETECT" == "FALSE" ]
then
	PARTIMAGEINFO=$(partimage -B gui=no imginfo "$FILEHEAD" 2>&1)
	if `echo $PARTIMAGEINFO | grep Partition > /dev/null`
	then	
		TOOLS=PARTIMAGE	
		FS=$(echo $PARTIMAGEINFO | awk '{gsub(/ /,"\n"); print $17;}' | awk '{sub(/\.\.+/," "); print toupper($2)}') 
		SIZE=$( echo $PARTIMAGEINFO | awk '{gsub(/ /,"\n"); print $36;}' | awk '{sub(/\.\.+/," "); printf "%d\n",$2*1024*1024;}')
		IMGDETECT="TRUE"
	fi	
fi
#comprobamos valores #Chequeamos los valores devueltos.
if [ -z "$TOOLS" -o -z "$COMPRESSOR" -o "$IMGDETECT" == "FALSE" ]
then
	ogRaiseError $OG_ERR_IMAGE "Image format is not valid $IMGFILE" || return $?
else
	COMPRESSOR=$(echo $COMPRESSOR | tr [a-z] [A-Z])
	echo $TOOLS:$COMPRESSOR:$FS:$SIZE
fi
}




#/**
#         ogCreateImageSyntax partition filename [tools]  [levelcompresor]
#@brief   Genera una cadena de texto con la instrucción para crear un fichero imagen
#@param 1  partition             identificador linux del dispositivo particion.
#@param 2  filename           path absoluto del fichero imagen
#@param 3  [opcional] str_tools          herrmaienta de clonacion [partimage, partclone, ntfsclone]
#@param 4  [opcional] str_levelcompresor nivel de compresion. [0 -none-, 1-lzop-, 2-gzip]
#@return  cadena con el comando que se debe ejecutar.
#@exception OG_ERR_FORMAT    formato incorrecto.
#@warning En pruebas iniciales
#@TODO    introducir las herramientas fsarchiver, dd
#@TODO    introducir el nivel de compresion gzip
#@version 1.0 - Primeras pruebas
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2010/02/08
#*/ ##

function ogCreateImageSyntax()
{
local FS TOOL LEVEL PART IMGFILE BUFFER

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME partition filename [tool] [levelcompresor]" \
           "$FUNCNAME /dev/sda1 /opt/opengnsys/images/prueba.img partclone lzop"
    return
fi
# Error si no se reciben al menos los 2 parámetros para obtener el valor default.
[ $# -lt 2 ] && ogRaiseError $OG_ERR_FORMAT && return $?


PART=`echo $1`
IMGFILE=`echo $2`

case "$#" in
   "2")
   	# Sintaxis por defecto OG PART IMGFILE
   	#echo "partimage -M -f3 -o -d -V0 -B gui=no -c -z1 save $PART $IMGFILE"
    # Se comenta la instruccion que debería ir aqui
    ogCreateImageSyntax $1 $2 partclone gzip
   ;;
   "4")
   	# Sintaxis condicionada.
   	# comprobamos parametro herramienta compresion.
	TOOL=$(echo $3 | tr [A-Z] [a-z])	
	#ogCheckProgram $TOOL
	#comprobar parámetro compresor.
	LEVEL=$(echo $4 | tr [A-Z] [a-z])
	#ogCheckProgram $LEVEL

	# herramienta
	case "$TOOL" in
		"ntfsclone")
			PARAM1="ntfsclone --force --save-image -O - $PART"
		;;
		"partimage"|DEFAULT)
			PARAM1="partimage -M -f3 -o -d -B gui=no -c -z0 --volume=0 save $PART stdout"
		;;
		"partclone")
   			PARAM1=`ogPartcloneSyntax $PART` || ogRaiseError $OG_ERR_FORMAT || return $?
		;;
	esac
	# mbuffer
	which mbuffer > /dev/null && PARAM2="| mbuffer -q -m 40M " || PARAM2=" "

	# nivel de compresion
	case "$LEVEL" in
    	"0"|"none")
    		PARAM3=" > "
    	;;
    	"1"|"lzop")
    		PARAM3=" | lzop > "
    	;;
    	"2"|"gzip")
    		PARAM3=" | gzip -c > "
    	;;
    	"3"|"bzip")
    		PARAM3=" | bzip -c > "
    	;;
	esac
	#sintaxis final.
	echo "$PARAM1 $PARAM2 $PARAM3 $IMGFILE"
	;;
esac
}

#/**
#         ogRestoreImageSyntax filename partition [tools]  [levelcompresor]
#@brief   Genera una cadena de texto con la instrucción para crear un fichero imagen
#@param 1  filename           path absoluto del fichero imagen
#@param 2  partition             identificador linux del dispositivo particion.
#@param 3  [opcional] str_tools          herrmaienta de clonacion [partimage, partclone, ntfsclone]
#@param 4  [opcional] str_levelcompresor nivel de compresion. [0 -none-, 1-lzop-, 2-gzip]
#@return  cadena con el comando que se debe ejecutar.
#@exception OG_ERR_FORMAT    formato incorrecto.
#@warning En pruebas iniciales
#@TODO    introducir las herramientas fsarchiver, dd
#@TODO    introducir el nivel de compresion gzip
#@version 1.0 - Primeras pruebas
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2010/02/08
#*/ ##

ogRestoreImageSyntax ()
{
local TOOL COMPRESSOR LEVEL PART IMGFILE FILEHEAD INFOIMG


# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME  filename partition [tool] [levelcompresor]" \
           "$FUNCNAME  /opt/opengnsys/images/prueba.img /dev/sda1 [partclone] [lzop]"
    return
fi

# Error si no se reciben al menos 2 parámetros.
[ $# -lt 2 ] && ogRaiseError $OG_ERR_FORMAT && return $?

# controlamos que el parametro 1 (imagen) es tipo file.
[ -f $1 ] || ogRaiseError $OG_ERR_NOTFOUND "$1" || return $?

# Si 2 parametros (file-origen-, device-destino-) = ogGetImageFull($1)
if [ "$#" -eq 2 ]; then
	IMGFILE=$1
	PART=$2
	INFOIMG=$(ogGetImageInfo $IMGFILE) || ogRaiseError $OG_ERR_NOTFOUND "No Image $1" || return $?
	TOOL=`echo $INFOIMG | cut -f1 -d:`
	COMPRESSOR=`echo $INFOIMG | cut -f2 -d:`
	ogRestoreImageSyntax $IMGFILE $PART $TOOL $COMPRESSOR
fi


# Si cuatro parametros genera sintaxis
if [ "$#" -eq 4 ]; then
	IMGFILE=$1
	PART=$2 
	# comprobamos parametro herramienta compresion.
	TOOL=$(echo $3 | tr [A-Z] [a-z])	
	#ogCheckProgram $TOOL
	#comprobar parámetro compresor.
	LEVEL=$(echo $4 | tr [A-Z] [a-z])
	#ogCheckProgram $LEVEL
	
	case "$LEVEL" in
    	"0"|"none")
    		COMPRESSOR=" "
    	;;
    	"1"|"lzop" | "LZOP")
    		COMPRESSOR=" lzop -dc "
    	;;
    	"2"|"gzip" | "GZIP")
    		COMPRESSOR=" gzip -dc "
    	;;
    	"3"|"bzip" | "BZIP" )
    		COMPRESSOR=" bzip -dc "
    	;;
    	*)
    		ogRaiseError $OG_ERR_NOTFOUND "Compressor no valid $TOOL" || return $?
    	;;
	esac
    #comprobar mbuffer
	which mbuffer > /dev/null && MBUFFER="| mbuffer -q -m 40M " || MBUFFER=" "

	case "$TOOL" in
		"ntfsclone" | "NTFSCLONE")
			TOOL="| ntfsclone --restore-image --overwrite $PART -"
		;;
		"partimage"| "PARTIMAGE")
			TOOL="| partimage -f3 -B gui=no restore $PART stdin"
		;;
		"partclone" | "PARTCLONE")
		    # -C para que no compruebe tamaños
			TOOL="| partclone.restore -o $PART"
		;;
		*)
    		ogRaiseError $OG_ERR_NOTFOUND "Tools imaging no valid $TOOL" || return $?
    	;;
	esac

	echo "$COMPRESSOR $IMGFILE $MBUFFER $TOOL"
fi

}


function ogGetImageProgram ()
{
local IMGFILE
IMGFILE=$(ogGetPath "$1" "$2.img") || return $?
[ -r "$IMGFILE" ] || ogRaiseError OG_ERR_NOTFOUND "$IMGFILE" || return $?
ogGetImageInfo $IMGFILE | awk -F: '{print $1}'

}

function ogGetImageCompressor ()
{
local IMGFILE
IMGFILE=$(ogGetPath "$1" "$2.img") || return $?
[ -r "$IMGFILE" ] || ogRaiseError OG_ERR_NOTFOUND "$IMGFILE" || return $?
ogGetImageInfo $IMGFILE | awk -F: '{print $2}'
}

#######################
###########################
###########################



function ogGetImageType ()
{
local IMGFILE
IMGFILE=$(ogGetPath "$1" "$2.img") || return $?
[ -r "$IMGFILE" ] || ogRaiseError OG_ERR_NOTFOUND "$IMGFILE" || return $?
#partimage -B gui=no imginfo "$IMGFILE" 2>&1 | \
#        awk '/^Filesystem/ {sub(/\.\.+/," "); sub(/fs$/,""); print toupper($2);}'
ogGetImageInfo $IMGFILE | awk -F: '{print $3}'

}





function ogGetImageSize ()
{
# Variables locales
local IMGFILE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME testing path_dir str_image int_ndisk int_npart" \
           "$FUNCNAME 1 1 REPO /aula1/winxp  ==>  5642158"
    return
fi
# Error si no se reciben menos de 2 parámetros.
[ $# -lt 2 ] && ogRaiseError $OG_ERR_FORMAT && return $?
# Error si el fichero de imagen no es accesible.
IMGFILE=$(ogGetPath "$1" "$2.img") || return $?
[ -r "$IMGFILE" ] || ogRaiseError OG_ERR_NOTFOUND "$IMGFILE" || return $?

# Devuelve el tamaño de la imagen en KB.
#partimage -B gui=no imginfo "$IMGFILE" 2>&1 | \
#        awk '/Partition size/ {sub(/\.\.+/," "); printf "%d\n",$3*1024*1024;}'
ogGetImageInfo $IMGFILE | awk -F: '{print $4}'
}


#/**
#         ogCreateImage int_ndisk int_npartition str_repo path_image
#@brief   Crea una imagen a partir de una partición.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@param   str_repo       repositorio de imágenes (remoto o caché local)
#@param   path_image     camino de la imagen (sin extensión)
#@return  (nada, por determinar)
#@note    repo = { REPO, CACHE }
#@exception OG_ERR_FORMAT    formato incorrecto.
#@exception OG_ERR_NOTFOUND  fichero o dispositivo no encontrado.
#@exception OG_ERR_PARTITION partición no accesible o no soportada.
#@exception OG_ERR_LOCKED    particion bloqueada por otra operación.
#@exception OG_ERR_IMAGE     error al crear la imagen del sistema.
#@warning En pruebas iniciales
#@todo    Comprobaciones, control de errores, definir parámetros, etc.
#@version 0.1 -  Integracion para Opengnsys  -  HIDRA:CrearImagen{EXT3, NTFS}.sh;  EAC: CreateImageFromPartition () en Deploy.lib
#@author Ramon Gomez, ETSII Universidad de Sevilla 
#@Date    2008/05/13
#@author  Antonio J. Doblas Viso. Universidad de Malaga
#@date    2008/10/27
#@version 0.9 - Versión en pruebas para OpenGnSys
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009/10/07
#*/ ##
function ogCreateImage ()
{
# Variables locales
local PART PROGRAM IMGDIR IMGFILE IMGTYPE ERRCODE

# TESTING mensajes
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npart str_repo path_image [str_tools] [str_levelcompresor]" \
           "$FUNCNAME 1 1 REPO /aula1/winxp " \
           "$FUNCNAME 1 1 REPO /aula1/winxp partclone lzop" \
           "$FUNCNAME 1 1 REPO /aula1/winxp partimage gzip" \
           "$FUNCNAME 1 1 REPO /aula1/winxp ntfsclone lzop" 
    return
fi
# TESTING de -n a -lt 
# Error si no se reciben 4 parámetros.
[ $# -lt 4 ] && ogRaiseError $OG_ERR_FORMAT && return $?

# Comprobar que no está bloqueada ni la partición, ni la imagen.
PART="$(ogDiskToDev $1 $2)" || return $?
if ogIsLocked $1 $2; then
    ogRaiseError $OG_ERR_LOCKED "$MSG_PARTITION $1, $2"
    return $?
fi
IMGTYPE="img"			# Extensión genérica de imágenes.
IMGDIR=$(ogGetParentPath "$3" "$4")
[ -n "$IMGDIR" ] || ogRaiseError $OG_ERR_NOTFOUND "$3 $(dirname $4)" || return $?
IMGFILE="$IMGDIR/$(basename "$4").$IMGTYPE"
if ogIsImageLocked "$IMGFILE"; then
    ogRaiseError $OG_ERR_LOCKED "$MSG_IMAGE $3, $4"
    return $?
fi
# Desmontar partición, bloquear partición e imagen.
ogUnmount $1 $2 2>/dev/null
ogLock $1 $2 || return $?
ogLockImage "$3" "$4.$IMGTYPE" || return $?

# Crear Imagen.
trap "ogUnlock $1 $2; ogUnlockImage "$3" "$4.$IMGTYPE"; rm -f $IMGFILE" 1 2 3 6 9

################## TESTING #########################################
#Solicitamos la generación de la instruccion a ejecutar
PROGRAM=`ogCreateImageSyntax $PART $IMGFILE $5 $6`
echo $PROGRAM
eval $PROGRAM

# Controlar salida de error y desbloquear partición.
ERRCODE=$?
if [ $ERRCODE != 0 ]; then
    ogRaiseError $OG_ERR_IMAGE "$1 $2 $IMGFILE"
    rm -f "$IMGFILE"
fi
ogUnlock $1 $2
ogUnlockImage "$3" "$4.$IMGTYPE"
return $ERRCODE
}




function ogRestoreImage ()
{
# Variables locales
local PART PROGRAM PARTSIZE IMGFILE IMGSIZE FSTYPE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME path_dir str_image int_ndisk int_npart" \
           "$FUNCNAME REPO /aula1/winxp 1 1"
    return
fi
# Error si no se reciben 4 parámetros.
[ $# -lt 4 ] && ogRaiseError $OG_ERR_FORMAT && return $?

# Procesar parámetros.
PART="$(ogDiskToDev "$3" "$4")" || return $?
IMGFILE=$(ogGetPath "$1" "$2.img") || return $?
[ -r "$IMGFILE" ] || ogRaiseError OG_ERR_NOTFOUND "$IMGFILE" || return $?


# Error si la imagen no cabe en la particion.
IMGSIZE=$(ogGetImageSize "$1" "$2")
PARTSIZE=$(ogGetPartitionSize $3 $4)
if [ $IMGSIZE -gt $PARTSIZE ]; then
    ogRaiseError $OG_ERR_PARTITION "$IMGSIZE > $PARTSIZE"
    return $?
    else
    echo "Tamanio de la imagen $IMGSIZE < al tamanio particion $PARTSIZE"
fi

# Comprobar el bloqueo de la imagen y de la partición.
if ogIsImageLocked "$IMGFILE"; then
    ogRaiseError $OG_ERR_LOCKED "$MSG_IMAGE $1, $2"
    return $?
fi
if ogIsLocked $3 $4; then
    ogRaiseError $OG_ERR_LOCKED "$MSG_PARTITION $3, $4"
    return $?
fi
# Desmontar y bloquear partición.
ogUnmount $3 $4 2>/dev/null || return $?
ogLock $3 $4 || return $?
trap "ogUnlock $3 $4" 1 2 3 6 9


#Solicitamos la generación de la instruccion a ejecutar
PROGRAM=`ogRestoreImageSyntax  $IMGFILE $PART`
echo $PROGRAM
eval $PROGRAM


ERRCODE=$?
if [ $ERRCODE != 0 ]; then
    ogRaiseError $OG_ERR_IMAGE "$IMGFILE, $3, $4"
fi
ogUnlock $3 $4
return $ERRCODE

}
