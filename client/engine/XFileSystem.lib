#!/bin/bash
#/**
#@file    FileSystem.lib
#@brief   Librería o clase FileSystem
#@class   FileSystem
#@brief   Funciones para gestión de sistemas de archivos.
#@version 0.9
#@warning License: GNU GPLv3+
#*/




#/**
#         ogReduceFs int_ndisk int_npartition
#@brief   Reduce el tamaño del sistema de archivos, sin tener en cuenta el espacio libre.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@return  tamañoKB
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@exception OG_ERR_PARTITION Partición desconocida o no accesible.
#@warning En Windows, se borran los ficheros pagefile.sys e hiberfile.sys
#@warning El sistema de archivos se amplía al mínimo + 1 KB.
#@note    Requisitos:	*resize*
#@version 0.9 - Primera versión para OpenGNSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-09-23
#*/ ##
function ogReduceFs ()
{
# Variables locales
local PART BLKS SIZE
echo "xfile"
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
           "$FUNCNAME 1 1"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Obtener partición.
PART="$(ogDiskToDev $1 $2)" || return $?

# Redimensionar según el tipo de particion.
case "$(ogGetFsType $1 $2)" in
    EXT[234])
        ogUnmount $1 $2 2>/dev/null
        # Ext2/3/4: Tamaño de los bloques del sistema de archivos
        BLKS=$(tune2fs -l $PART | awk '/Block size/ {print int($3/512)}')
        # Traduce el num. en sectores de 512B a tamano en MB.
        SIZE=$(resize2fs -P $PART 2>/dev/null | \
		       awk -v B=$BLKS '/minimum size/ {print int($7*B/2048+1000)}')
        resize2fs -fp $PART "${SIZE}M" &>/dev/null || ogRaiseError $OG_ERR_PARTITION "$1,$2" || return $?
	    ;;
#    REISERFS)		# Usar "resize_reiserfs"
#	    ;;
    NTFS|HNTFS)
        ogDeleteFile $1 $2 pagefile.sys &>/dev/null
        ogDeleteFile $1 $2 hiberfile.sys &>/dev/null
        ogUnmount $1 $2 2>/dev/null
### Modificaciones del trunk
        # NTFS: Obtiene tamaño mínimo en MB. 1.16
        #SIZEDATA=$(ntfsresize -fi $PART | awk '/resize at/ {printf "%d", $8*1.16}')
        #SIZEDATA=$(ntfsresize -fi $PART | awk '/resize at/ {print $8+500}')
	echo "iniciando calculo reduccion FS"
	SIZE=$(ReduceFsNT2 $1 $2)
### fin modificaciones
	echo "iniciando proceso de reduccion con $SIZE"
	[ "$SIZE" == 0 ] && return 1	
        ntfsresize -fs "${SIZE}M" $PART <<<"y"  || ogRaiseError $OG_ERR_PARTITION "error reduciendo $1,$2" || return $?
        #ntfsresize -fs "${SIZE}M" $PART <<<"y" >/dev/null || ogRaiseError $OG_ERR_PARTITION "$1,$2" || return $?
	    ;;
    *)  
		echo "sin tipo de sistema archivos"
		ogRaiseError $OG_ERR_PARTITION "$1,$2"
	    return $? ;;
esac
#/// Mostrar nuevo tamaño en KB.
echo $[SIZE*1024]
#echo $SIZE
}




function ReduceFsNT2 ()
{
#IMPORTANTE: retorna el valor en MB que podrá reducir el FS de una particion ntfs
#valor devulto 0, y codigo error 1. No se puede reducir, probar a reiniciar windows.


local  PART RC MODE SIZE SIZEDATA 
[ $# == 2 ] && MODE=STAGE1
[ $# == 3 ] && MODE=STAGE2
[ -z $MODE ] && return

PART="$(ogDiskToDev $1 $2)" || return $?
ogUnmount $1 $2 &>/dev/null


case $MODE in
	STAGE1)
	#	echo "primera etapa $*"
		ntfsresize -fi $PART &>/dev/null
		RC=`echo $?`
	#	echo "RC es" $RC
		if [ "$RC" -eq "1" ]
		then 
			echo "0" 
     			return 1	
		fi  
		SIZEDATA=$(ntfsresize -fi $PART | awk '/resize at/ {print $8+1000}')
	#	echo "salida" $?
	#	echo $SIZEDATA
		ReduceFsNT2 $1 $2 $SIZEDATA 
		return 0
       ;;
	STAGE2)
	#	echo "segunda etapa $*"
		SIZEDATA=$3
        	ntfsresize -fns "${SIZEDATA}M" $PART &>/tmp/ntfsresize.txt
		RC=$?
		if [ "$RC" == "0" ]
		then  
			SIZE=$SIZEDATA	
			echo $SIZE	
		else
			SIZEEXTRA=$(cat /tmp/ntfsresize.txt | awk '/Needed relocations :/ {print $0}' | awk -F"(" '{print $2}' | awk '{print $1+500}')
			SIZE=$(expr $SIZEDATA + $SIZEEXTRA)
			ReduceFsNT2 $1 $2 $SIZE 
			return 0 
		fi
	;;
	*)
	return
	;;
esac

}


function ogGetFreeSize () {
if [ $# = 0 ]
then
	echo "sintaxis: ogGetFreeSize int_disco int_partition str_SizeOutput [ kB MB GB -default GB]-]" red
	echo "devuelve int_size : int_data : int_free" red
return
fi
if [ $# -ge 2 ]
then
	particion=`ogMount $1 $2 ` #1>/dev/null 2>&1
	if [ -z $3 ]
		then
			unit=kB  # s B kB MB GB TB %
		else
			unit=$3
	fi
	case $unit in
		kB)
			factor="1.024";
			#valor=`df | grep  $particion | awk -F" " '{size=$2*1.024; used=$3*1.024; free=$4*1.024; printf "%d:%d:%d", size,used,free}'`
			valor=`df | grep  $particion | awk -F" " '{size=$2*1.024; used=$3*1.024; free=$4*1.024; printf "%d", free}'`
			;;
		MB)
			factor="1.024/1000";
			valor=`df | grep  $particion | awk -F" " '{size=$2*1.024/1000; used=$3*1.024/1000; free=$4*1.024/1000; printf "%d:%d:%d", size,used,free}'`
		;;
		GB)
			factor="1.024/1000000";
			valor=`df | grep $particion | awk -F" " '{size=$2*1.024/1000000; used=$3*1.024/1000000; free=$4*1.024/1000000; printf "%f:%f:%f", size,used,free}'`
		;;
	esac
	#echo $valor
	#NumberRound $valor
	#valor=`NumberRound $valor`;
	ogUnmount $1 $2 1>/dev/null 2>&1
	echo $valor

fi
}










#/**  @function ogGetFsSize: @brief Muestra el tamanio del sistema de archivos indicado, permite definir la unidad de medida, por defecto GB
#@param  $1 int_disk
#@param $2 int_Partition
#@param $3 str_UnidadMediada		parametro opcional, admite [ kB MB GB -default kB]
#@return  cadena con int_TotalSize                 no=>:int_DataSize:int_DataFree
#@warning  Salidas de errores no determinada
#@warning
#@attention
#@version 0.1 -  Integracion para Opengnsys  -  EAC:  SizeFileSystem() en FileSystem.lib
#@author  Antonio J. Doblas Viso. Universidad de Malaga
#@date    2008-10-27
#*/
function ogGetFsSize () {
if [ $# = 0 ]
then
	echo "sintaxis: ogGetFsSize int_disco int_partition str_SizeOutput [ kB MB GB -default GB]-]" red
	echo "devuelve int_size : int_data : int_free" red
return
fi
if [ $# -ge 2 ]
then
	particion=`ogMount $1 $2 ` #1>/dev/null 2>&1
	if [ -z $3 ]
		then
			unit=kB  # s B kB MB GB TB %
		else
			unit=$3
	fi
	case $unit in
		kB)
			factor="1.024";
			#valor=`df | grep  $particion | awk -F" " '{size=$2*1.024; used=$3*1.024; free=$4*1.024; printf "%d:%d:%d", size,used,free}'`
			valor=`df | grep  $particion | awk -F" " '{size=$2*1.024; used=$3*1.024; free=$4*1.024; printf "%d", size}'`
			;;
		MB)
			factor="1.024/1000";
			valor=`df | grep  $particion | awk -F" " '{size=$2*1.024/1000; used=$3*1.024/1000; free=$4*1.024/1000; printf "%d:%d:%d", size,used,free}'`
		;;
		GB)
			factor="1.024/1000000";
			valor=`df | grep $particion | awk -F" " '{size=$2*1.024/1000000; used=$3*1.024/1000000; free=$4*1.024/1000000; printf "%f:%f:%f", size,used,free}'`
		;;
	esac
	#echo $valor
	#NumberRound $valor
	#valor=`NumberRound $valor`;
	ogUnmount $1 $2 1>/dev/null 2>&1
	echo $valor

fi
}

#/** copia literal del engine 1.0
function ogDeletePartitionsLabels ()
{
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME " \
           "$FUNCNAME "
    return
fi
rm /dev/disk/by-label/* 2>/dev/null   # */ COMENTARIO OBLIGATORIO PARA DOXYGEN
}













#/** copia literal del engine 1.0
function ogDeletePartitionTable ()
{

# Variables locales.
local DISK

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME int_disk"  \
           "$FUNCNAME 1"
    return
fi
# Error si no se reciben 1 parámetros.
[ $# == 1 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Obteniendo Identificador linux de la particion.
DISK=$(ogDiskToDev $1) || return $?

# Elimando las particiones con fdisk
echo -ne "o\nw" | fdisk $DISK
}


