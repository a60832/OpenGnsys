#!/bin/bash
#/**
#@file    Image.lib
#@brief   Librería o clase Image
#@class   Image
#@brief   Funciones para creación, restauración y clonación de imágenes de sistemas.
#@version 1.0
#@warning License: GNU GPLv3+
#*/



function ogPartcloneSyntax ()
{
#TODO: comprobar como unico parametro particion /dev/sda1
#COMPAR="partclone.$FS --clone --force --source $PART"
COMPAR=" -d0 -F -c -s "
TYPE="$(ogGetFsType `ogDevToDisk $1`)"
case "$TYPE" in
    EXT[234])
        echo "partclone.extfs $COMPAR $1"
        ;;
    REISERFS|XFS|JFS)
        echo "partclone.dd $COMPAR $1"
        ;;
    NTFS|HNTFS)
        echo "partclone.ntfs $COMPAR $1"
        ;;
    FAT16|FAT32|HFAT16|HFAT32)
        echo "partclone.fat $COMPAR $1"
        ;;
    HFS|HFS+)
        echo "partclone.hfsp $COMPAR $1"
        ;;
    *)  ogRaiseError $OG_ERR_PARTITION "$1 $TYPE"
        return $? ;;
esac   
}

#/**
#         ogCreateImageSyntax partition filename [tools]  [levelcompresor]
#@brief   Genera una cadena de texto con la instrucción para crear un fichero imagen
#@param 1  partition             identificador linux del dispositivo particion.
#@param 2  filename           path absoluto del fichero imagen
#@param 3  [opcional] str_tools          herrmaienta de clonacion [partimage, partclone, ntfsclone]
#@param 4  [opcional] str_levelcompresor nivel de compresion. [0 -none-, 1-lzop-, 2-gzip]
#@return  cadena con el comando que se debe ejecutar.
#@exception OG_ERR_FORMAT    formato incorrecto.
#@warning En pruebas iniciales
#@TODO    introducir las herramientas fsarchiver, dd
#@TODO    introducir el nivel de compresion gzip
#@version 1.0 - Primeras pruebas
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2010/02/08
#*/ ##

function ogCreateImageSyntax()
{
local FS TOOL LEVEL PART IMGFILE BUFFER

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME partition filename [tool] [levelcompresor]" \
           "$FUNCNAME /dev/sda1 /opt/opengnsys/images/prueba.img partclone lzop"
    return
fi
# Error si no se reciben al menos los 2 parámetros para obtener el valor default.
[ $# -lt 2 ] && ogRaiseError $OG_ERR_FORMAT && return $?


PART=`echo $1`
IMGFILE=`echo $2`

case "$#" in
   "2")
   	# Sintaxis por defecto OG PART IMGFILE
   	#echo "partimage -M -f3 -o -d -V0 -B gui=no -c -z1 save $PART $IMGFILE"
    # Se comenta la instruccion que debería ir aqui
    ogCreateImageSyntax $1 $2 partclone gzip
   ;;
   "4")
   	# Sintaxis condicionada.
   	# comprobamos parametro herramienta compresion.
	TOOL=$(echo $3 | tr [A-Z] [a-z])	
	#ogCheckProgram $TOOL
	#comprobar parámetro compresor.
	LEVEL=$(echo $4 | tr [A-Z] [a-z])
	#ogCheckProgram $LEVEL

	# herramienta
	case "$TOOL" in
		"ntfsclone")
			PARAM1="ntfsclone --force --save-image -O - $PART"
		;;
		"partimage"|DEFAULT)
			PARAM1="partimage -M -f3 -o -d -B gui=no -c -z0 --volume=0 save $PART stdout"
		;;
		"partclone")
   			PARAM1=`ogPartcloneSyntax $PART` || ogRaiseError $OG_ERR_FORMAT || return $?
		;;
	esac
	# mbuffer
	which mbuffer > /dev/null && PARAM2="| mbuffer -q -m 40M " || PARAM2=" "

	# nivel de compresion
	case "$LEVEL" in
    	"0"|"none")
    		PARAM3=" > "
    	;;
    	"1"|"lzop")
    		PARAM3=" | lzop > "
    	;;
    	"2"|"gzip")
    		PARAM3=" | gzip -c > "
    	;;
    	"3"|"bzip")
    		PARAM3=" | bzip -c > "
    	;;
	esac
	#sintaxis final.
	echo "$PARAM1 $PARAM2 $PARAM3 $IMGFILE"
	;;
esac
}


#/**
#         ogRestoreImageSyntax filename partition [tools]  [levelcompresor]
#@brief   Genera una cadena de texto con la instrucción para crear un fichero imagen
#@param 1  filename           path absoluto del fichero imagen
#@param 2  partition             identificador linux del dispositivo particion.
#@param 3  [opcional] str_tools          herrmaienta de clonacion [partimage, partclone, ntfsclone]
#@param 4  [opcional] str_levelcompresor nivel de compresion. [0 -none-, 1-lzop-, 2-gzip]
#@return  cadena con el comando que se debe ejecutar.
#@exception OG_ERR_FORMAT    formato incorrecto.
#@warning En pruebas iniciales
#@TODO    introducir las herramientas fsarchiver, dd
#@TODO    introducir el nivel de compresion gzip
#@version 1.0 - Primeras pruebas
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2010/02/08
#*/ ##

ogRestoreImageSyntax ()
{
local TOOL COMPRESSOR LEVEL PART IMGFILE FILEHEAD INFOIMG


# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME  filename partition [tool] [levelcompresor]" \
           "$FUNCNAME  /opt/opengnsys/images/prueba.img /dev/sda1 [partclone] [lzop]"
    return
fi

# Error si no se reciben al menos 2 parámetros.
[ $# -lt 2 ] && ogRaiseError $OG_ERR_FORMAT && return $?

# controlamos que el parametro 1 (imagen) es tipo file.
[ -f $1 ] || ogRaiseError $OG_ERR_NOTFOUND "$1" || return $?

# Si 2 parametros (file-origen-, device-destino-) = ogGetImageFull($1)
if [ "$#" -eq 2 ]; then
	IMGFILE=$1
	PART=$2
	INFOIMG=$(ogGetImageInfo $IMGFILE) || ogRaiseError $OG_ERR_NOTFOUND "No Image $1" || return $?
	TOOL=`echo $INFOIMG | cut -f1 -d:`
	COMPRESSOR=`echo $INFOIMG | cut -f2 -d:`
	ogRestoreImageSyntax $IMGFILE $PART $TOOL $COMPRESSOR
fi


# Si cuatro parametros genera sintaxis
if [ "$#" -eq 4 ]; then
	IMGFILE=$1
	PART=$2 
	# comprobamos parametro herramienta compresion.
	TOOL=$(echo $3 | tr [A-Z] [a-z])	
	#ogCheckProgram $TOOL
	#comprobar parámetro compresor.
	LEVEL=$(echo $4 | tr [A-Z] [a-z])
	#ogCheckProgram $LEVEL
	
	case "$LEVEL" in
    	"0"|"none")
    		COMPRESSOR=" "
    	;;
    	"1"|"lzop" | "LZOP")
    		COMPRESSOR=" lzop -dc "
    	;;
    	"2"|"gzip" | "GZIP")
    		COMPRESSOR=" gzip -dc "
    	;;
    	"3"|"bzip" | "BZIP" )
    		COMPRESSOR=" bzip -dc "
    	;;
    	*)
    		ogRaiseError $OG_ERR_NOTFOUND "Compressor no valid $TOOL" || return $?
    	;;
	esac
    #comprobar mbuffer
	which mbuffer > /dev/null && MBUFFER="| mbuffer -q -m 40M " || MBUFFER=" "

	case "$TOOL" in
		"ntfsclone" | "NTFSCLONE")
			TOOL="| ntfsclone --restore-image --overwrite $PART -"
		;;
		"partimage"| "PARTIMAGE")
			TOOL="| partimage -f3 -B gui=no restore $PART stdin"
		;;
		"partclone" | "PARTCLONE")
		    # -C para que no compruebe tamaños
			TOOL="| partclone.restore -d0 -C -I -o $PART"
		;;
		*)
    		ogRaiseError $OG_ERR_NOTFOUND "Tools imaging no valid $TOOL" || return $?
    	;;
	esac

	echo "$COMPRESSOR $IMGFILE $MBUFFER $TOOL"
fi

}




#/**
#         ogCreateImage int_ndisk int_npartition str_repo path_image
#@brief   Crea una imagen a partir de una partición.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@param   str_repo       repositorio de imágenes (remoto o caché local)
#@param   path_image     camino de la imagen (sin extensión)
#@return  (nada, por determinar)
#@note    repo = { REPO, CACHE }
#@exception OG_ERR_FORMAT    formato incorrecto.
#@exception OG_ERR_NOTFOUND  fichero o dispositivo no encontrado.
#@exception OG_ERR_PARTITION partición no accesible o no soportada.
#@exception OG_ERR_LOCKED    particion bloqueada por otra operación.
#@exception OG_ERR_IMAGE     error al crear la imagen del sistema.
#@warning En pruebas iniciales
#@todo    Comprobaciones, control de errores, definir parámetros, etc.
#@version 0.1 -  Integracion para Opengnsys  -  HIDRA:CrearImagen{EXT3, NTFS}.sh;  EAC: CreateImageFromPartition () en Deploy.lib
#@author Ramon Gomez, ETSII Universidad de Sevilla 
#@Date    2008/05/13
#@author  Antonio J. Doblas Viso. Universidad de Malaga
#@date    2008/10/27
#@version 0.9 - Versión en pruebas para OpenGnSys
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009/10/07
#*/ ##
function ogCreateImage ()
{
# Variables locales
local PART PROGRAM IMGDIR IMGFILE IMGTYPE ERRCODE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npart path_dir str_image" \
           "$FUNCNAME 1 1 REPO /aula1/winxp"
    return
fi
# Error si no se reciben 4 parámetros.
[ $# -lt 4 ] && ogRaiseError $OG_ERR_FORMAT && return $?

# Comprobar que no está bloqueada ni la partición, ni la imagen.
PART="$(ogDiskToDev $1 $2)" || return $?
if ogIsLocked $1 $2; then
    ogRaiseError $OG_ERR_LOCKED "$MSG_PARTITION $1, $2"
    return $?
fi
IMGTYPE="img"			# Extensión genérica de imágenes.
IMGDIR=$(ogGetParentPath "$3" "$4")

[ -n "$IMGDIR" ] || ogRaiseError $OG_ERR_NOTFOUND "$3 $(dirname $4)" || return $?
IMGFILE="$IMGDIR/$(basename "$4").$IMGTYPE"
if ogIsImageLocked "$IMGFILE"; then
    ogRaiseError $OG_ERR_LOCKED "$MSG_IMAGE $3, $4"
    return $?
fi
# Desmontar partición, bloquear partición e imagen.
ogUnmount $1 $2 2>/dev/null
ogLock $1 $2 || return $?
ogLockImage "$3" "$4.$IMGTYPE" || return $?

# Crear Imagen.
trap "ogUnlock $1 $2; ogUnlockImage "$3" "$4.$IMGTYPE"; rm -f $IMGFILE" 1 2 3 6 9
#Solicitamos la generación de la instruccion a ejecutar
PROGRAM=`ogCreateImageSyntax $PART $IMGFILE $5 $6`
echo $PROGRAM
eval $PROGRAM

# Controlar salida de error y desbloquear partición.
ERRCODE=$?
if [ $ERRCODE != 0 ]; then
    ogRaiseError $OG_ERR_IMAGE "$1 $2 $IMGFILE"
    rm -f "$IMGFILE"
fi
# Desbloquear partición e imagen.
ogUnlock $1 $2
ogUnlockImage "$3" "$4.$IMGTYPE"
return $ERRCODE
}


#/**
#         ogCreateMbrImage int_ndisk str_repo path_image
#@brief   Crea una imagen a partir del sector de arranque de un disco.
#@param   int_ndisk    nº de orden del disco
#@param   str_repo     repositorio de imágenes (remoto o caché local)
#@param   path_image   camino de la imagen (sin extensión)
#@return  (nada, por determinar)
#@note    repo = { REPO, CACHE }
#@exception OG_ERR_FORMAT    formato incorrecto.
#@exception OG_ERR_NOTFOUND  fichero o dispositivo no encontrado.
#@exception OG_ERR_IMAGE     error al crear la imagen del sistema.
#@version 0.9 - Versión en pruebas para OpenGNSys
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2010/01/12
#@version 1.0 - Adaptación a OpenGnSys 1.0
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2011/03/10
#*/ ##
function ogCreateMbrImage ()
{
# Variables locales
local DISK IMGDIR IMGFILE
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk path_dir str_image" \
           "$FUNCNAME 1 REPO /aula1/mbr"
    return
fi
# Error si no se reciben 3 parámetros.
[ $# -lt 3 ] && ogRaiseError $OG_ERR_FORMAT && return $?

DISK=$(ogDiskToDev "$1") || return $?
IMGDIR=$(ogGetParentPath "$2" "$3")
[ -n "$IMGDIR" ] || ogRaiseError $OG_ERR_NOTFOUND "$2 $(dirname $3)" || return $?
IMGFILE="$IMGDIR/$(basename "$3").mbr"

# Crear imagen del MBR.
dd if="$DISK" of="$IMGFILE" bs=512 count=1 || ogRaiseError $OG_ERR_IMAGE "$1 $IMGFILE" || return $?
}


#/**
#         ogCreateBootLoaderImage int_ndisk str_repo path_image
#@brief   Crea una imagen del boot loader a partir del sector de arranque de un disco.
#@param   int_ndisk    nº de orden del disco
#@param   str_repo     repositorio de imágenes (remoto o caché local)
#@param   path_image   camino de la imagen (sin extensión)
#@return  (nada, por determinar)
#@note    repo = { REPO, CACHE }
#@exception OG_ERR_FORMAT    formato incorrecto.
#@exception OG_ERR_NOTFOUND  fichero o dispositivo no encontrado.
#@exception OG_ERR_IMAGE     error al crear la imagen del sistema.
#@version 1.0 - Adaptacion de ogCreateMbrImage para guardar solo el Boot Loader
#@author  Juan Carlos Xifre, SICUZ Universidad de Zaragoza
#@date    2011/03/21
#*/ ##
function ogCreateBootLoaderImage ()
{
# Variables locales
local DISK IMGDIR IMGFILE
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk path_dir str_image" \
           "$FUNCNAME 1 REPO /aula1/mbr"
    return
fi
# Error si no se reciben 3 parámetros.
[ $# -lt 3 ] && ogRaiseError $OG_ERR_FORMAT && return $?

DISK=$(ogDiskToDev "$1") || return $?
IMGDIR=$(ogGetParentPath "$2" "$3")
[ -n "$IMGDIR" ] || ogRaiseError $OG_ERR_NOTFOUND "$2 $(dirname $3)" || return $?
IMGFILE="$IMGDIR/$(basename "$3").mbr"

# Crear imagen del Boot Loader dentro del MBR.
dd if="$DISK" of="$IMGFILE" bs=446 count=1 || ogRaiseError $OG_ERR_IMAGE "$1 $IMGFILE" || return $?
}


#/**
#         ogIsImageLocked [str_repo] path_image
#@brief   Comprueba si una imagen está bloqueada para uso exclusivo.
#@param   str_repo     repositorio de imágenes (opcional)
#@param   path_image   camino de la imagen (sin extensión)
#@return  Código de salida: 0 - bloqueado, 1 - sin bloquear o error.
#@note    repo = { REPO, CACHE }
#@exception OG_ERR_FORMAT    formato incorrecto.
#@version 1.0 - Adaptación a OpenGnSys 1.0
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2011/03/10
#@version 1.0.1 - Devolver falso en caso de error.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2011-05-18
#*/ ##
function ogIsImageLocked ()
{
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME [str_repo] path_image" \
           "if $FUNCNAME /opt/opengnsys/images/aula1/winxp.img; then ...; fi" \
           "if $FUNCNAME REPO /aula1/winxp.img; then ...; fi"
    return
fi
# Error si no se reciben 1 o 2 parámetros.
[ $# -lt 1 -o $# -gt 2 ] && return 1

# Comprobar si existe el fichero de bloqueo.
test -n "$(ogGetPath $@.lock)"
}


#/**
#         ogLockImage [str_repo] path_image
#@brief   Bloquea una imagen para uso exclusivo.
#@param   str_repo     repositorio de imágenes (opcional)
#@param   path_image   camino de la imagen (sin extensión)
#@return  Nada.
#@note    Se genera un fichero con extensión .lock
#@note    repo = { REPO, CACHE }
#@exception OG_ERR_FORMAT    formato incorrecto.
#@version 1.0 - Adaptación a OpenGnSys 1.0
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2011/03/10
#*/ ##
function ogLockImage ()
{
# Variables locales
local IMGDIR

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME [str_repo] path_image" \
           "$FUNCNAME /opt/opengnsys/images/aula1/winxp.img" \
           "$FUNCNAME REPO /aula1/winxp.img"
    return
fi
# Error si no se reciben 1 o 2 parámetros.
[ $# -lt 1 -o $# -gt 2 ] && ogRaiseError $OG_ERR_FORMAT && return $?
# Comprobar que existe directorio de imagen
IMGDIR=$(ogGetParentPath $@) || return $?
# Crear fichero de bloqueo.
touch $IMGDIR/$(basename "${!#}").lock
}


#/**
#         ogRestoreImage str_repo path_image int_ndisk int_npartition
#@brief   Restaura una imagen de sistema de archivos en una partición.
#@param   str_repo       repositorio de imágenes o caché local
#@param   path_image     camino de la imagen
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@return  (por determinar)
#@exception OG_ERR_FORMAT   1 formato incorrecto.
#@exception OG_ERR_NOTFOUND  2 fichero de imagen o partición no detectados.
#@exception OG_ERR_PARTITION 3	# Error en partición de disco.
#@exception OG_ERR_LOCKED    4 partición bloqueada por otra operación.
#@exception OG_ERR_IMAGE    5 error al restaurar la imagen del sistema.
#@exception OG_ERR_IMGSIZEPARTITION  30 Tamaño de la particion es menor al tamaño de la imagen.
#@todo    Comprobar incongruencias partición-imagen, control de errores, definir parámetros, caché/repositorio, etc.
#@version 0.1 -  Integracion para Opengnsys  - HIDRA:RestaurarImagen{EXT3, NTFS}.sh;  EAC: RestorePartitionFromImage() en Deploy.lib
#@author Ramon Gomez, ETSII Universidad de Sevilla 
#@Date    2008/05/13
#@author  Antonio J. Doblas Viso. Universidad de Malaga
#@date    2008/10/27
#@version 0.9 - Primera version muy en pruebas para OpenGnSys
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009/09/10
#@version 1.0 - generacion sintaxis de restauracion
#@author  Antonio J. Doblas Viso, Universidad de Malaga
#@date    2011/02/01
#@version 1.0.1 - Control errores, tamaño particion, fichero-imagen
#@author  Antonio J. Doblas Viso, Universidad de Malaga
#@date    2011/05/11
#*/ ##
function ogRestoreImage ()
{
# Variables locales
local PART PARTSIZE IMGFILE IMGTYPE IMGSIZE FSTYPE PROGRAM ERRCODE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME path_dir str_image int_ndisk int_npart" \
           "$FUNCNAME REPO /aula1/winxp 1 1"
    return
fi
# Error si no se reciben 4 parámetros.
[ $# -lt 4 ] && return $(ogRaiseError $OG_ERR_FORMAT; echo $?)
# Procesar parámetros.
PART="$(ogDiskToDev $3 $4)" || return $(ogRaiseError $OG_ERR_NOTFOUND " $3 $4"; echo $?)
#IMGTYPE=$(ogGetImageType "$1" "$2")
IMGTYPE=img
IMGFILE=$(ogGetPath "$1" "$2.$IMGTYPE") 
[ -r "$IMGFILE" ] || return $(ogRaiseError $OG_ERR_NOTFOUND " $3 $4"; echo $?)
# comprobamos consistencia de la imagen
ogGetImageInfo $IMGFILE >/dev/null  || return $(ogRaiseError $OG_ERR_IMAGE " $1 $2"; echo $?)

# Error si la imagen no cabe en la particion.
IMGSIZE=$(ogGetImageSize "$1" "$2") || return $(ogRaiseError $OG_ERR_IMAGE " $1 $2"; echo $?)
#TODO:
#Si la particion no esta formateado o tiene problemas formateamos
ogMount $3 $4 || ogFormat $3 $4
#PARTSIZE=$(parted -sm $DISK unit kB print | \
#              awk -F: -v np=$4 '{if ($1==np) {gsub(/kB/,""); print $4} } ')
PARTSIZE=$(ogGetPartitionSize $3 $4)
if [ $IMGSIZE -gt $PARTSIZE ]; then
    ogRaiseError $OG_ERR_IMGSIZEPARTITION "  $PARTSIZE < $IMGSIZE"
    return $?
fi
# Comprobar el bloqueo de la imagen y de la partición.
if ogIsImageLocked "$IMGFILE"; then
    ogRaiseError $OG_ERR_LOCKED "$MSG_IMAGE $1, $2.$IMGTYPE"
    return $?
fi
if ogIsLocked $3 $4; then
    ogRaiseError $OG_ERR_LOCKED "$MSG_PARTITION $3, $4"
    return $?
fi
# Desmontar y bloquear partición.
ogUnmount $3 $4 2>/dev/null || return $(ogRaiseError $OG_ERR_PARTITION " $3 $4"; echo $?)
ogLock $3 $4 || return $(ogRaiseError $OG_ERR_PARTITION " $3 $4"; echo $?)
trap "ogUnlock $3 $4" 1 2 3 6 9

# Restaurar según el tipo de imagen.
# Atención: no se comprueba el tipo de sistema de archivos.
# Atención: no se comprueba incongruencia entre partición e imagen.
#Solicitamos la generación de la instruccion a ejecutar
PROGRAM=`ogRestoreImageSyntax  $IMGFILE $PART`
echo $PROGRAM
eval $PROGRAM

ERRCODE=$?
if [ $ERRCODE != 0 ]; then
    ogRaiseError $OG_ERR_IMAGE "$IMGFILE, $3, $4"
fi
ogUnlock $3 $4
return $ERRCODE
}


#/**
#         ogRestoreMbrImage str_repo path_image int_ndisk
#@brief   Restaura la imagen del sector de arranque de un disco.
#@param   str_repo     repositorio de imágenes o caché local
#@param   path_image   camino de la imagen
#@param   int_ndisk    nº de orden del disco
#@return  (por determinar)
#@exception OG_ERR_FORMAT   formato incorrecto.
#@exception OG_ERR_NOTFOUND fichero de imagen o partición no detectados.
#@exception OG_ERR_IMAGE    error al restaurar la imagen del sistema.
#@version 0.9 - Primera versión en pruebas.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2010/01/12
#@version 1.0 - Adaptación a OpenGnSys 1.0
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2011/03/10
#*/ ##
function ogRestoreMbrImage ()
{
# Variables locales
local DISK IMGFILE
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME path_dir str_image int_ndisk" \
           "$FUNCNAME REPO /aula1/mbr 1"
    return
fi
# Error si no se reciben 3 parámetros.
[ $# -lt 3 ] && ogRaiseError $OG_ERR_FORMAT && return $?
# Procesar parámetros.
DISK=$(ogDiskToDev "$3") || return $?
IMGFILE=$(ogGetPath "$1" "$2.mbr") || return $?
[ -r "$IMGFILE" ] || ogRaiseError OG_ERR_NOTFOUND "$IMGFILE" || return $?

# Restaurar imagen del MBR.
dd if="$IMGFILE" of="$DISK" bs=512 count=1 || ogRaiseError $OG_ERR_IMAGE "$1 $IMGFILE" || return $?
}


#/**
#         ogRestoreBootLoaderImage str_repo path_image int_ndisk
#@brief   Restaura la imagen del boot loader del sector de arranque de un disco.
#@param   str_repo     repositorio de imágenes o caché local
#@param   path_image   camino de la imagen
#@param   int_ndisk    nº de orden del disco
#@return  (por determinar)
#@exception OG_ERR_FORMAT   formato incorrecto.
#@exception OG_ERR_NOTFOUND fichero de imagen o partición no detectados.
#@exception OG_ERR_IMAGE    error al restaurar la imagen del sistema.
#@version 1.0 - Adaptacion de ogRestoreMbrImage para restaurar solo el Boot Loader
#@author  Juan Carlos Xifre, SICUZ Universidad de Zaragoza
#@date    2011/03/21
#*/ ##
function ogRestoreBootLoaderImage ()
{
# Variables locales
local DISK IMGFILE
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME path_dir str_image int_ndisk" \
           "$FUNCNAME REPO /aula1/mbr 1"
    return
fi
# Error si no se reciben 3 parámetros.
[ $# -lt 3 ] && ogRaiseError $OG_ERR_FORMAT && return $?
# Procesar parámetros.
DISK=$(ogDiskToDev "$3") || return $?
IMGFILE=$(ogGetPath "$1" "$2.mbr") || return $?
[ -r "$IMGFILE" ] || ogRaiseError OG_ERR_NOTFOUND "$IMGFILE" || return $?

# Restaurar imagen del MBR.
dd if="$IMGFILE" of="$DISK" bs=446 count=1 || ogRaiseError $OG_ERR_IMAGE "$1 $IMGFILE" || return $?
}

#/**
#         ogUnlockImage [str_repo] path_image
#@brief   Desbloquea una imagen con uso exclusivo.
#@param   str_repo     repositorio de imágenes (opcional)
#@param   path_image   camino de la imagen (sin extensión)
#@return  Nada.
#@note    repo = { REPO, CACHE }
#@note    Se elimina el fichero de bloqueo con extensión .lock
#@exception OG_ERR_FORMAT    formato incorrecto.
#@version 1.0 - Adaptación a OpenGnSys 1.0
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2011/03/10
#*/ ##
function ogUnlockImage ()
{
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME [str_repo] path_image" \
           "$FUNCNAME /opt/opengnsys/images/aula1/winxp.img" \
           "$FUNCNAME REPO /aula1/winxp.img"
    return
fi
# Error si no se reciben 1 o 2 parámetros.
[ $# -lt 1 -o $# -gt 2 ] && ogRaiseError $OG_ERR_FORMAT && return $?

# Borrar fichero de bloqueo para la imagen.
rm -f $(ogGetPath $@.lock)
}


#/**
#         ogGetImageInfo filename
#@brief   muestra información sobre la imagen monolitica.
#@param 1   filename           path absoluto del fichero imagen
#@return  cadena compuesta por clonacion:compresor:sistemaarchivos:tamañoKB
#@exception OG_ERR_FORMAT    formato incorrecto.
#@exception OG_ERR_NOTFOUND   fichero no encontrado.
#@exception OG_ERR_IMAGE 	"Image format is not valid $IMGFILE"
#@warning En pruebas iniciales
#@TODO    Definir sintaxis de salida (herramienta y compresor en minuscula)
#@TODO 	  Arreglar loop para ntfsclone 
#@TODO    insertar parametros entrada tipo OG
#@version 1.0 - Primeras pruebas
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2010/02/08
#*/ ##

function ogGetImageInfo ()
{
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME  filename " \
           "$FUNCNAME  /opt/opengnsys/images/prueba.img "
    return
fi

# Error si no se reciben 1 parámetros.
[ $# == 1 ] || ogRaiseError $OG_ERR_FORMAT || return $?

#comprobando que el parametro uno es un file.
[ -f $1 ] || ogRaiseError $OG_ERR_NOTFOUND "$1" || return $?

local TOOLS COMPRESSOR IMGFILE FILEHEAD FS SIZE SIZEFACTOR PARTIMAGEINFO PARTCLONEINFO NTFSCLONEINFO IMGDETECT
IMGDETECT="FALSE"

IMGFILE=$1
FILEHEAD=/tmp/`basename $IMGFILE`.infohead
COMPRESSOR=`file $IMGFILE | awk '{print $2}'`
ogCheckStringInGroup "$COMPRESSOR" "gzip lzop" || ogRaiseError $OG_ERR_IMAGE "Image format is not valid $IMGFILE" || return $?
$($COMPRESSOR -dc $IMGFILE 2>/dev/null | head > $FILEHEAD) || ogRaiseError $OG_ERR_IMAGE "Image format is not valid $IMGFILE" || return $? 

## buscando Primera opción.
if [ "$IMGDETECT" == "FALSE" ] 
then 
	PARTCLONEINFO=$(partclone.info $FILEHEAD 2>&1)
	if `echo $PARTCLONEINFO | grep size > /dev/null`
	then
		TOOLS=PARTCLONE
		FS=$(echo $PARTCLONEINFO | awk '{gsub(/\: /,"\n"); print toupper($8);}')
		echo $PARTCLONEINFO | grep GB > /dev/null && SIZEFACTOR=1000000 || SIZEFACTOR=1024
		SIZE=$(echo $PARTCLONEINFO | awk -v FACTOR=$SIZEFACTOR '{gsub(/\: /,"\n"); printf "%d\n", $11*FACTOR;}')
		IMGDETECT="TRUE"
	fi
fi
#buscando segunda opcion.
if [ "$IMGDETECT" == "FALSE" -a ! -f /dev/loop2  ] 
then 
	cat $FILEHEAD | grep -w ntfsclone-image > /dev/null && NTFSCLONEINFO=$(cat $FILEHEAD | ntfsclone --restore --overwrite /dev/loop2 - 2>&1)
	if `echo $NTFSCLONEINFO | grep ntfsclone > /dev/null`  
	then
		TOOLS=NTFSCLONE
   		SIZE=$(echo $NTFSCLONEINFO | awk '{gsub(/\(|\)|\./,""); printf "%d\n",$17/1000;}')
   		FS=NTFS
   		IMGDETECT="TRUE"
	fi
fi
## buscando Tercer opción. 
if [ "$IMGDETECT" == "FALSE" ]
then
	PARTIMAGEINFO=$(partimage -B gui=no imginfo "$FILEHEAD" 2>&1)
	if `echo $PARTIMAGEINFO | grep Partition > /dev/null`
	then	
		TOOLS=PARTIMAGE	
		FS=$(echo $PARTIMAGEINFO | awk '{gsub(/ /,"\n"); print $17;}' | awk '{sub(/\.\.+/," "); print toupper($2)}') 
		SIZE=$( echo $PARTIMAGEINFO | awk '{gsub(/ /,"\n"); print $36;}' | awk '{sub(/\.\.+/," "); printf "%d\n",$2*1024*1024;}')
		IMGDETECT="TRUE"
	fi	
fi
#comprobamos valores #Chequeamos los valores devueltos.
if [ -z "$TOOLS" -o -z "$COMPRESSOR" -o "$IMGDETECT" == "FALSE" ]
then
	ogRaiseError $OG_ERR_IMAGE "Image format is not valid $IMGFILE" || return $?
else
	COMPRESSOR=$(echo $COMPRESSOR | tr [a-z] [A-Z])
	echo $TOOLS:$COMPRESSOR:$FS:$SIZE
fi
}

function ogGetImageProgram ()
{
local IMGFILE
IMGFILE=$(ogGetPath "$1" "$2.img") || return $?
[ -r "$IMGFILE" ] || ogRaiseError OG_ERR_NOTFOUND "$IMGFILE" || return $?
ogGetImageInfo $IMGFILE | awk -F: '{print $1}'

}

function ogGetImageCompressor ()
{
local IMGFILE
IMGFILE=$(ogGetPath "$1" "$2.img") || return $?
[ -r "$IMGFILE" ] || ogRaiseError OG_ERR_NOTFOUND "$IMGFILE" || return $?
ogGetImageInfo $IMGFILE | awk -F: '{print $2}'
}

function ogGetImageType ()
{
local IMGFILE
IMGFILE=$(ogGetPath "$1" "$2.img") || return $?
[ -r "$IMGFILE" ] || ogRaiseError OG_ERR_NOTFOUND "$IMGFILE" || return $?
#partimage -B gui=no imginfo "$IMGFILE" 2>&1 | \
#        awk '/^Filesystem/ {sub(/\.\.+/," "); sub(/fs$/,""); print toupper($2);}'
ogGetImageInfo $IMGFILE | awk -F: '{print $3}'

}

function ogGetImageSize ()
{
# Variables locales
local IMGFILE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME REPO|CACHE /str_image" \
           "$FUNCNAME REPO /aula1/winxp  ==>  5642158"
    return
fi
# Error si no se reciben menos de 2 parámetros.
[ $# -lt 2 ] && ogRaiseError $OG_ERR_FORMAT && return $?
# Error si el fichero de imagen no es accesible.
IMGFILE=$(ogGetPath "$1" "$2.img") || return $?
[ -r "$IMGFILE" ] || ogRaiseError OG_ERR_NOTFOUND "$IMGFILE" || return $?

# Devuelve el tamaño de la imagen en KB.
#partimage -B gui=no imginfo "$IMGFILE" 2>&1 | \
#        awk '/Partition size/ {sub(/\.\.+/," "); printf "%d\n",$3*1024*1024;}'
ogGetImageInfo $IMGFILE | awk -F: '{print $4}'
}


#/**
#         ogGetImageFs str_repo path_image
#@brief   Devuelve el tipo de sistema de archivos almacenado en un fichero de imagen.
#@param   str_repo    repositorio de imágenes o caché local
#@param   path_image  camino de la imagen
#@return  str_imgtype - mnemónico del tipo de sistema de archivos
#@exception OG_ERR_FORMAT   formato incorrecto.
#@exception OG_ERR_NOTFOUND fichero de imagen no encontrado.
#@todo    Comprobar salidas para todos los tipos de sistemas de archivos.
#/**
function ogGetImageFsUS ()
{
local IMGFILE IMGTYPE
IMGTYPE=$(ogGetImageType "$1" "$2")
IMGFILE=$(ogGetPath "$1" "$2.$IMGTYPE") || return $?
[ -r "$IMGFILE" ] || ogRaiseError OG_ERR_NOTFOUND "$IMGFILE" || return $?
case "$IMGTYPE" in
    img) # Partimage.
         partimage -B gui=no imginfo "$IMGFILE" 2>&1 | \
                awk '/^Filesystem/ {sub(/\.\.+/," "); if ($2=="ntfs") print NTFS;
                                                      else { sub(/fs$/,""); print toupper($2);} }'
         ;;
    pgz) # Partclone / GZip
         gzip -dc "$IMGFILE" | partclone.chkimg -C -s - 2>&1 | \
                awk '/^File system/ {if ($2=="EXTFS") print "EXT3"; else print $3;}'
         ;;
    *)   # Error si el fichero de imagen no es accesible.
         ogRaiseError OG_ERR_NOTFOUND "$IMGFILE"
         return $?  ;;
esac
}


#         ogGetImageSize str_repo path_image
#@brief   Devuelve el tamaño del sistema de archivos almacenado en un fichero de imagen.
#@param   str_repo    repositorio de imágenes o caché local
#@param   path_image  camino de la imagen
#@return  int_size  - tamaño (en KB)
#@exception OG_ERR_FORMAT   formato incorrecto.
#@exception OG_ERR_NOTFOUND fichero de imagen no encontrado.
#*/
#@warning En pruebas iniciales
#@todo    Definición de parámetros y salidas.
#@version 0.1 - Primera versión muy en pruebas para OpenGNSys
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009/09/11
#*/ ##
function ogGetImageSizeUS ()
{
# Variables locales
local IMGFILE IMGTYPE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME path_dir str_image int_ndisk int_npart" \
           "$FUNCNAME 1 1 REPO /aula1/winxp  ==>  5642158"
    return
fi
# Error si no se reciben menos de 2 parámetros.
[ $# -ne 2 ] && ogRaiseError $OG_ERR_FORMAT && return $?
# Devuelve el tamaño de la imagen en KB.
IMGTYPE=$(ogGetImageType "$1" "$2")
IMGFILE=$(ogGetPath "$1" "$2.$IMGTYPE")
case "$IMGTYPE" in
    img) # Partimage.
         partimage -B gui=no imginfo "$IMGFILE" 2>&1 | \
                awk '/Partition size/ {sub(/\.\.+/," "); ps=$3} END {print ps*1024*1024;}'
         ;;
    pgz) # Partclone / GZip
         gzip -dc "$IMGFILE" | partclone.chkimg -C -s - 2>&1 | \
                awk -F: '/Block size/ {bs=$2} /Used block/ {ub=$2} END {print bs*ub/1024}'
         ;;
    *)   # Error si el fichero de imagen no es accesible.
         ogRaiseError OG_ERR_NOTFOUND "$IMGFILE"
         return $?  ;;
esac
}

