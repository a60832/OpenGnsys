#!/bin/bash

#         ogLoadHiveWindows int_ndisk int_partiton 
#@brief   Localiza los hive del registro de windows (de sistema y usuarios)
#@param   int_ndisk      nº de orden del disco 
#@param   int_partition     nº de particion 
#@return  
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_PARTITION Tipo de partición desconocido o no se puede montar.
#@version 0.9 - Adaptación a OpenGNSys.
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2009-09-24
#*/ ##


function ogLoadHiveWindows () {
# Variables locales.
local PART DISK 

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_partition" \
           "$FUNCNAME 1 1 "
    return
fi	

# Error si no se reciben 2 parámetros.
[ $# == 2 ] || return $(ogRaiseError $OG_ERR_FORMAT; echo $?)

DISK=$1; PART=$2; 

#Comprobaciones redundantes: borrar"
#ogDiskToDev $DISK $PART || return $(ogRaiseError $OG_ERR_PARTITION "particion de windows no detectada"; echo $?)
#ogGetOsType $DISK $PART | grep "Windows" || return $(ogRaiseError $OG_ERR_NOTOS "no es windows"; echo $?)
#VERSION=$(ogGetOsVersion $DISK $PART)
#Fin Comprobaciones redundantes: borrar"


# primera fase, carga de los hive del sistema
if ogGetPath $DISK $PART WINDOWS
then
	SYSTEMROOT="Windows"
elif ogGetPath $DISK $PART WINNT
then 
	SYSTEMROOT="winnt"
else
	return $(ogRaiseError $OG_ERR_NOTOS "version windows no detectada"; echo $?)
fi

hiveSAM=$(ogGetPath $DISK $PART /${SYSTEMROOT}/system32/config/SAM) && export hiveSAM || return $(ogRaiseError $OG_ERR_NOTOS " hive SAM  no detectada"; echo $?)
hiveSYSTEM=$(ogGetPath $DISK $PART /${SYSTEMROOT}/system32/config/system) && export hiveSYSTEM || return $(ogRaiseError $OG_ERR_NOTOS "hive SYSTEM  no detectada"; echo $?)
hiveSOFTWARE=$(ogGetPath $DISK $PART /${SYSTEMROOT}/system32/config/software) && export hiveSOFTWARE || return $(ogRaiseError $OG_ERR_NOTOS "hive SOFTWARE no detectada"; echo $?)
export TEMPhive=/tmp/tmpregistry

# segunda fase, carga de los hive de usuarios windows.
declare -i COUNT
COUNT=3
#TODO WINDOWS XP WINDOWS7
BASEHOMEDIR=$(ogGetPath $DISK $PART /"Documents and Settings")
TMPUSERFILE="/tmp/WuserRegAndDAT.tmp"
find "$BASEHOMEDIR/" -type f -name NTUSER.DAT > $TMPUSERFILE  
LISTUSERS=$(drbl-chntpw -l $hiveSAM | grep RID | awk -F"<" '{print $2}' | awk -F">" '{print $1}')
#echo "$BASEHOMEDIR" $LISTUSERS
for user in $LISTUSERS
do		        
        # Comprobamos que el usuario registrado tiene .DAT
		if HOMEDIR=$(cat $TMPUSERFILE | grep -w $user)  
		then
			#echo "$user exportamos los usuarios de windows como variables, y como valor hiveUSERX; donde la X es 3 4 5 6 ... X"
			export `echo $user=hiveUSER$COUNT` 
			#echo "$user exportamos la variable hiveUSERX con el valor del home de la variable-usuario_windows"
			##export `echo hiveUSER$COUNT`="$(echo $HOMEDIR | sed -e 's/ /\\ /'g | sed -e 's/\\/\\\\/g')"
			export `echo hiveUSER$COUNT`="$(echo $HOMEDIR)"
			#echo " estas variables \$USUARIO -> Identificador del HIVE ; \${!USUARIO} -> path del HIVE "
			COUNT=${COUNT}+1
		fi
		
done
COUNT=0
}


#         ogUpdateHiveWindows  
#@brief   Actualiza los hive de windows.
#@param   int_ndisk       
#@param   int_partition     
#@return  
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_PARTITION Tipo de partición desconocido o no se puede montar.
#@version 0.9 - Adaptación a OpenGNSys.
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2009-09-24
#*/ ##


function ogUpdateHiveWindows (){
# Variables locales.
local PART DISK FILE

#TODO detectar llamada a ogLoadHiveWindows

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME " \
           "$FUNCNAME  "
    return
fi	

echo drbl-chntpw -f $TEMPhive $hiveSAM $hiveSYSTEM $hiveSOFTWARE \"${hiveUSER3}\" \"${hiveUSER4}\" \"${hiveUSER5}\" \"${hiveUSER6}\" \"${hiveUSER7}\" \"${hiveUSER8}\" \"${hiveUSER9}\" > /tmp/run.sh
cat /tmp/run.sh; sh /tmp/run.sh; rm -fr $TEMPhive; rm /tmp/run.sh

unset hiveSAM hiveSYSTEM hiveSOFTWARE TEMPhive hiveUSER3 hiveUSER4 hiveUSER5 hiveUSER6 hiveUSER7 hiveUSER8 hiveUSER9
 

}



function ogHiveNTRunMachine () {
#echo sintaxis:  PathScripts idScripts
#echo ejemplo:   c:\\\\WINDOSWS\\\\crearusuarios.bat  scripts1
#echo IMPORTANTE: el path debe llevar dos barras \\, pero como se deben 'escapar' debes poner cuatro \\\\
#echo "identifica 0=$hiveSAM 1=$hiveSystem 2=$hiveSoftware 3=$HiveUser3"

local PART DISK FILE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME PathScripts|command keyName " \
           "$FUNCNAME c:\\\\Windows\\\\crearusuarios.cmd scripts_crearUsuarios "\
           "$FUNCNAME "cmd /c del c:\ogboot.*" ogcleanboot "\
           "$FUNCNAME Requiere la previa ejecución de ogLoadHive int_disk int_part"\
           "$FUNCNAME Despues requiere el ogUpdateHive"
    return
fi	
	

# Error si no se reciben al menos 1 parámetros.
[ $# == 2 ] || return $(ogRaiseError $OG_ERR_FORMAT; echo $?)	


cat >> $TEMPhive << EOF
h 2
cd \Microsoft\Windows\CurrentVersion\Run
nv 1 $2
ed $2
$1
EOF
#ogGetRegistryValue /mnt/sda1 software '\Microsoft\Windows\CurrentVersion\Run\og3'
}

function ogNTPolUserOn () {

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME id_hive_user " \
           "$FUNCNAME NombreUsuario"\
           "$FUNCNAME "
    return
fi		

# TODO: error si no se ha llamado previamente a ogLoadHiveWindows
[ -n $hiveSAM ] || return $(ogRaiseError $OG_ERR_FORMAT "se debe utilizar primero la utilidad ogLoadHiveWindows"; echo $?)

# TODO: error si el usuario no tiene cuenta en windows.
drbl-chntpw -l $hiveSAM | grep RID | grep -w $1 || return $(ogRaiseError $OG_ERR_FORMAT "el usuario $1 no tiene cuenta en este windows: Compruebe mayusculas o minusculas"; echo $?)

# TODO: error si no el usario no no tiene HIVE asociado.
[ -n "${!1}" ] || return $(ogRaiseError $OG_ERR_FORMAT "el usuario no tiene hive creado"; echo $?)


HIVEID=$(echo ${!1} | tr -d "hiveUSER")


#echo "IMPORTANTE:  la variable HiveUser3=/mnt/windows/Document/\ and/\ Seeting\alumnmos\NTUSER.dat"
echo $HIVEID
#cp /var/EAC/admin/utilswin/Fondo.BMP ${particion}/WINDOWS/

cat >> $TEMPhive << EOF
h $HIVEID
cd \Control Panel\Desktop
ed Wallpaper
C:\\WINDOWS\\fondo.bmp

cd \Software\Microsoft\Windows\CurrentVersion\Policies
nk Explorer
cd Explorer

nv 4 NoDesktop
ed NoDesktop
1

nv 4 NoSimpleStartMenu
ed NoSimpleStartMenu
1
nv 4 NoWindowsUpdate
ed NoWindowsUpdate
1

nv 4 NoSMConfigurePrograms
ed NoSMConfigurePrograms
1

nv 4 NoChangeStartMenu
ed NoChangeStartMenu
1

nv 4 Intellimenus
ed Intellimenus
1

nv 4 NoRun
ed NoRun
1

nv 4 NoRecentDocsHistory
ed NoRecentDocsHistory
1
EOF
}





##########################################################
##########################################################
#####librerias de PostConfiguracion v0.1para Advanced Deploy enViorenment###########
# Liberado bajo licencia GPL <http://www.gnu.org/licenses/gpl.html>################
############# 2008 Antonio Jes�s Doblas Viso  adv@uma.es ##########################
########### Universidad de Malaga (Spain)############################
##########################################################





function NTChangeName () {
if [ $# = 0 ]
then
echo sintaxis: NTChangeNAME str_$var
echo ejemplos: NTCHangeName adi${IPcuatro}-xp
fi
cat >> $temporal << EOF
h 1 
ed ControlSet001\Control\ComputerName\ComputerName\ComputerName
$1
ed ControlSet001\Services\Tcpip\Parameters\Hostname
$1
ed ControlSet001\Services\Tcpip\Parameters\NV Hostname
$1
h 2
cd \Microsoft\Windows NT\CurrentVersion\Winlogon
ed DefaultDomainName
$1
EOF
}



function NTSetGroupName () {
if [ $# = 0 ]
then
echo sintaxis: NTSetGroupName str_$var
echo ejemplos: NTSetGroupName adi
fi
cat >> $temporal << EOF
h 2
ed \Microsoft\Windows NT\CurrentVersion\Winlogon\DefaultDomainName
$1
EOF
}


function NTSetOwner (){
if [ $# = 0 ]
then
echo sintaxis: NtSetOwner str_propietario str_organizacion
echo ejemplos: NTSetOwner eu\ politecnica universidad\ de\ malaga
fi
cat >> $temporal << EOF
h 2
ed \Microsoft\Windows NT\CurrentVersion\RegisteredOwner
$1
ed \Microsoft\Windows NT\CurrentVersion\RegisteredOrganization
$2
EOF
}


function NTAutoLogon (){
if [ $# = 0 ]
then
echo sintaxis: Int_Activar Int_nves str_usuario str_passwd str_equipo 
echo ejemplos: 1 2 administrador 3451 $equipo
echo IMPORTANTE: cuando AutoLogonCount llegue a 0, activa el AutoAdminLogon a 0. Pero no borra los valores de DefaultPassword
return 2
fi
echo la pass es $4
export temporal=/tmp/tmpregistry
cat >> $temporal << EOF
hive 2
cd \Microsoft\Windows NT\CurrentVersion\Winlogon
nv 1 AutoAdminLogon
ed AutoAdminLogon
$1
nv 1 AutoLogonCount
ed AutoLogonCount
$2
nv 1 DefaultUserName
ed DefaultUserName
$3
nv 1 DefaultDomainName
ed DefaultDomainName
$5
EOF
if [ "$4" == none ]
then
echo "debe aparecer done" $4
cat >> $temporal << EOF
dv DefaultPassword


EOF
else
cat >> $temporal << EOF
nv 1 DefaultPassword
ed DefaultPassword
$4
EOF
fi
}

function NTStatusRatonTeclado (){
if [ $# = 0 ]
then
echo sintaxis: Int-StatusRaton Int-StatusTeclado 
echo ejemplos:  int=1 activo   int=4 desactivado
return 2
fi
cat >> $temporal << EOF
hive 1
cd \ControlSet001\Services\Mouclass
ed Start
$1
cd \ControlSet001\Services\Kbdclass
ed Start
$2
EOF
}

function NTRunOnceMachine () {
if [ $# = 0 ]
then
echo sintaxis:  PathScripts idScripts
echo "ejemplo:   c:\\\\WINDOSWS\\\\crearusuarios.bat  scripts1"
echo "IMPORTANTE: el path debe llevar dos barras \\, pero como se deben 'escapar' debes poner cuatro \\\\"
return 2
fi
export temporal=/tmp/tmpregistry
cat >> $temporal << EOF
h 2
cd \Microsoft\Windows\CurrentVersion\RunOnce
nv 1 $2
ed $2
$1
EOF
}

function NTRunMachine () {
if [ $# = 0 ]
then
echo sintaxis:  PathScripts idScripts
echo ejemplo:   c:\\\\WINDOSWS\\\\crearusuarios.bat  scripts1
echo IMPORTANTE: el path debe llevar dos barras \\, pero como se deben 'escapar' debes poner cuatro \\\\
return 2
fi
export temporal=/tmp/tmpregistry
cat >> $temporal << EOF
h 2
cd \Microsoft\Windows\CurrentVersion\Run
nv 1 $2
ed $2
$1
EOF
}

function NTRunUser () {
if [ $# = 0 ]
then
echo sintaxis:  str_PathWINScripts str_idScripts Int_hive||\$usuario
echo ejemplo:   c:\\\\WINDOSWS\\\\crearusuarios.bat  scripts1 3
echo IMPORTANTE: el pathWIN debe llevar dos barras \\, pero como se deben 'escapar' debes poner cuatro \\\\
echo IMPORTANTE: el pathLinux si lleva espacios debe escaparse con una barra \\
echo IMPORTANTE Int_hive: 3 para el primer usuario, 4 para el segundo usuario
echo requiere export un HiveUser3=/mnt/windows/Document\ and\ Seeting\alumnmos\NTUSER.dat
return 2
fi
cat >> $temporal << EOF
h $3
cd \Software\Microsoft\Windows\CurrentVersion\Run
nv 1 $2
ed $2
$1
EOF
}



function NTPolUserOn () {
if [ $# = 0 ]
then
Msg "requiere LoadRegistryUser str_user1 str_user2..." orange
echo "sintaxis:  Int_hive"
echo "ejemplo: NTPolUserOn 3"
echo "IMPORTANTE:  la variable HiveUser3=/mnt/windows/Document/\ and/\ Seeting\alumnmos\NTUSER.dat"
return 2
fi
cp /var/EAC/admin/utilswin/Fondo.BMP ${particion}/WINDOWS/
cat >> $temporal << EOF
h $1
cd \Control Panel\Desktop
ed Wallpaper
C:\\WINDOWS\\fondo.bmp

cd \Software\Microsoft\Windows\CurrentVersion\Policies
nk Explorer
cd Explorer

nv 4 NoDesktop
ed NoDesktop
1

nv 4 NoSimpleStartMenu
ed NoSimpleStartMenu
1
nv 4 NoWindowsUpdate
ed NoWindowsUpdate
1

nv 4 NoSMConfigurePrograms
ed NoSMConfigurePrograms
1

nv 4 NoChangeStartMenu
ed NoChangeStartMenu
1

nv 4 Intellimenus
ed Intellimenus
1

nv 4 NoRun
ed NoRun
1

nv 4 NoRecentDocsHistory
ed NoRecentDocsHistory
1
EOF
}

function NTPolUserOFF () {
if [ $# = 0 ]
then
Msg "requiere LoadRegistryUser str_user1 str_user2..." orange
echo "sintaxis:  Int_hive"
echo "ejemplo: NTPolUserOFF 3"
echo "IMPORTANTE:  la variable HiveUser3=/mnt/windows/Document/\ and/\ Seeting\alumnmos\NTUSER.dat"
return 2
fi
cat >> $temporal << EOF
h $1
cd \Control Panel\Desktop
ed Wallpaper
C:\\WINDOWS\\web\\wallpaper\\Felicidad.bmp

cd \Software\Microsoft\Windows\CurrentVersion\
rdel Policies
nk Policies
1
EOF
}


function ogSetWindowsChkdisk() {
if [ $# = 0 ]
then
echo sintaxis: true|TRUE|0 false|false|1
echo ejemplos:  int=0 desactivado int=1 activado
return 2
fi
case $1 in
	0|true|TRUE)
		valor="autocheck autochk *";;
	1|false|FALSE)		
		valor="none";;
	*)
		return 0 ;;
esac

cat >> $TEMPhive << EOF
hive 1
cd \ControlSet001\Control\Session Manager
ed BootExecute
$valor
--n
EOF
}



### FASE DE PRUEBAS  NO FUNCIONA
function NTStartRecovery () {
if [ $# = 0 ]
then
	echo sintaxis: Int-Status
	echo ejemplos:  int=0 desactivado int=1 activado
	return 2
fi

[ $1 = 0 ] && valor="none"
[ $1 = 1 ] && valor="00000000"


cat >> $TEMPhive << EOF
hive 2
#cd \Policies\Microsoft\Windows\WinRE
#ed DisableSetup
cd \Policies\Microsoft\Windows
nk WinRE 
nv 4 DisableSetup
ed DisableSetup
$valor
--n
EOF


#Activado
#[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WinRE]
#"DisableSetup"=-

# Desactivado
#[HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\WinRE]
#"DisableSetup"=dword:00000000


}


function ogSchrootLinux () {

# Variables locales.
local PART DISK DIRCONF SCHROOTDEVICE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_partition" \
           "$FUNCNAME 1 1 "
    return
fi	

# Error si no se reciben 2 parámetros.
[ $# == 2 ] || return $(ogRaiseError $OG_ERR_FORMAT; echo $?)

DISK=$1; PART=$2; DIRCONF="/etc/schroot"


VERSION=$(ogGetOsVersion $DISK $PART) 
echo $VERSION | grep "Linux" || return $(ogRaiseError $OG_ERR_NOTOS "no es linux"; echo $?)

ogUnmount $DISK $PART || return $(ogRaiseError $OG_ERR_NOTOS "no es linux"; echo $?)

SCHROOTDEVICE=$(ogDiskToDev $DISK $PART)


rm ${DIRCONF}/mount-defaults
rm ${DIRCONF}/schroot.conf

cat >> ${DIRCONF}/mount-defaults << EOF
# <file system> <mount point>   <type>  <options>       <dump>  <pass>
proc            /proc           proc    defaults        0       0
/dev            /dev            none    rw,bind         0       0
/dev/pts        /dev/pts        none    rw,bind         0       0
/dev/shm        /dev/shm        none    rw,bind         0       0
EOF


cat >> ${DIRCONF}/schroot.conf << EOF
[linux]
description=$VERSION
type=block-device
device=$SCHROOTDEVICE
EOF




schroot -c linux

schroot -end-sessiona --all-sessions
}


#/**
#         ogInstallMiniSetup
#@brief   Metafunción para instalar archivo que se ejecutará en el arranque de Windows.
#@see     ogInstallFirstBoot ogInstallRunonce
#*/ ##
function ogInstallMiniSetup ()
{
case $# in
    3)  # Ejecución en el primer arranque de la máquina.
        ogInstallFirstBoot "$@" ;;
    6|8) # Ejecución en el "runonce".
        ogInstallRunonce "$@" ;;
    *)  ogRaiseError $OG_ERR_FORMAT
        exit $? ;;
esac
}


#/**
#         ogInstallFirstBoot int_ndisk int_npartition str_filename
#@brief   Crea unas claves del registro y el archivo cmd que se ejecutara en el primer arranque estando la maquina en un estado bloqueado
#@param   int_ndisk         nº de orden del disco
#@param   int_npartition    nº de orden de la partición
#@param   str_filename      nombre del archivo .cmd a ejecutar en el arranque
#@return  (nada)
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@note    El archivo estará en system32 y será visible por el sistema.
#@version 1.0.2 - Nueva función
#@author  Jonathan Alonso Martinez - Universidad Autonoma de Barcelona
#@date    2011-06-29
#@version 1.0.4 - Heredada de antigua función ogInstallMiniSetup.
#@author  Jonathan Alonso Martinez - Universidad Autonoma de Barcelona
#@date    2012-04-16
#*/ ##
function ogInstallMiniSetup ()
{
local MNTDIR CMDDIR CMDFILE
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition str_filename" \
           "$FUNCNAME 1 1 filename.cmd"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 3 ] || return $(ogRaiseError $OG_ERR_FORMAT; echo $?)
# Comprobar que existe el directorio del fichero de comandos.
MNTDIR=$(ogMount "$1" "$2") || return $?
CMDDIR=$(ogGetPath "$MNTDIR/windows/system32")
[ -n "$CMDDIR" ] || ogRaiseError $OG_ERR_NOTFOUND "$1/windows/system32" || return $?
CMDFILE="$CMDDIR/$2"

# Creamos el archivo cmd y creamos un par de comandos para que una vez acabe la 
# postconfiguracion resetee el mini setup, sino lo haria en cada arranque.
cat > "$CMDFILE" << EOF
REG ADD HKLM\System\Setup /v SystemSetupInProgress /t REG_DWORD /d 0 /f
REG ADD HKLM\System\Setup /v CmdLine /t REG_SZ /d "" /f
EOF

#Creamos las claves de registro necesarias para que se haga la ejecucion del .cmd al aranque
ogSetRegistryValue "$MNTDIR" SYSTEM "\Setup\SystemSetupInProgress" 1
ogSetRegistryValue "$MNTDIR" SYSTEM "\Setup\SetupType" 4
ogSetRegistryValue "$MNTDIR" SYSTEM "\Setup\CmdLine" "cmd.exe /c $2"
}


#/**
#         ogInstallRunonce int_ndisk int_npartition str_filename str_adm_user str_adm_password bool_autologin [str_auto_user str_auto_password]
#@brief   Crea el archivo cmd que se ejecutara en el runonce de un
usuario administrador
#@param   int_ndisk         nº de orden del disco
#@param   int_npartition    nº de orden de la partición
#@param   str_filename      nombre del archivo .cmd a ejecutar en el
arranque (estara en system32 y sera visible por el sistema)
#@param   str_adm_user      usuario administrador para hacer
autologin y ejecutar el runonce
#@param   str_adm_password  password del usuario administrador
#@param   bool_autologin    si despues de la postconfiguracion queremos que la maquina haga autologin (0 o 1)
#@param   str_auto_user     Usuario con el que queremos que haga
autologin despues de la postconfiguracion
#@param   str_auto_password Password del usuario que hara autologin
#@return  (nada)
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@version 1.0.2 - Nueva función
#@author  Jonathan Alonso Martinez - Universidad Autonoma de Barcelona
#@date    2011-06-29
#@version 1.0.4 - Heredado de antigua función ogInstallMiniSetup
#@author  Jonathan Alonso Martinez - Universidad Autonoma de Barcelona
#@date    2012-04-16
#*/ ##
function ogInstallRunonce ()
{
local MOUNTPOINT CMDDIR CMDFILE
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition str_filename str_adm_user str_adm_password bool_autologin [str_auto_user str_auto_password]" \
           "$FUNCNAME 1 1 filename.cmd administrator passadmin 1 userauto passuserauto" \
           "$FUNCNAME 1 1 filename.cmd administrator passadmin 0"
    return
fi
# Error si no se reciben 6 u 8 parámetros.
[ $# == 6 -o $# == 8 ] || return $(ogRaiseError $OG_ERR_FORMAT; echo $?)
# Punto de montaje.
MOUNTPOINT="$(ogGetPath "$1" "$2" /)"
# Comprobar que existe el directorio del fichero de comandos.
CMDDIR="$(ogGetPath "$1" "$2" /windows/system32)"
[ -n "$CMDDIR" ] || ogRaiseError $OG_ERR_NOTFOUND "$MOUNTPOINT/Windows/System32" || return $?
CMDFILE="$CMDDIR/$3"

if [ $6 == 0 ]; then
    # Si no volem fer autologin despres de la postconfiguracio o indiquem a las claus de registre
    cat > "$CMDFILE" << EOF
DEL C:\ogboot.*
REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v AutoAdminLogon /t REG_SZ /d 0 /f
REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultUserName /t REG_SZ /d "" /f
REG DELETE "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultPassword /f
EOF
else
    # Si volem fer autologin despres de la postconfiguracio introduim l'informacio a les claus de registre
    cat > "$CMDFILE" << EOF
DEL C:\ogboot.*
REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v AutoAdminLogon /t REG_SZ /d 1 /f
REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultUserName /t REG_SZ /d "$7" /f
REG ADD "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultPassword /t REG_SZ /d "$8" /f
EOF
fi
#Creamos las claves de registro necesarias para que meter el cmd en el runonce del usuario y este haga autologin
ogAddRegistryValue $MOUNTPOINT software '\Microsoft\Windows\CurrentVersion\RunOnce\PostConfiguracion' 2>/dev/null
ogSetRegistryValue $MOUNTPOINT software '\Microsoft\Windows\CurrentVersion\RunOnce\PostConfiguracion' "C:\windows\system32\\$3" 2>/dev/null
ogSetRegistryValue $MOUNTPOINT software '\Microsoft\Windows NT\CurrentVersion\Winlogon\AutoAdminLogon' 1 2>/dev/null
ogSetRegistryValue $MOUNTPOINT software '\Microsoft\Windows NT\CurrentVersion\Winlogon\DefaultUserName' "$4" 2>/dev/null
ogAddRegistryValue $MOUNTPOINT software '\Microsoft\Windows NT\CurrentVersion\Winlogon\DefaultPassword' 2>/dev/null
ogSetRegistryValue $MOUNTPOINT software '\Microsoft\Windows NT\CurrentVersion\Winlogon\DefaultPassword' "$5" 2>/dev/null
}


#         ogAddCmd int_ndisk int_npartition str_filename str_commands
#@brief   Añade comandos al cmd creado por ogInstalMiniSetup
#@param   int_ndisk         nº de orden del disco
#@param   int_npartition    nº de orden de la partición
#@param   str_filename      nombre del fichero cmd (siempre se guardara en windows\system32\para que sea visible por el sistema
#@param   str_commands      comando o comandos que se añadiran al fichero
#@return  
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_PARTITION Tipo de partición desconocido o no se puede montar.
#@version 1.0.2 - Nueva función
#@author  Jonathan Alonso Martinez - Universidad Autonoma de Barcelona
#@date    2011-06-29
#@version 1.0.4 - Cambios en los parametros de entrada de la funcion
#@author  Jonathan Alonso Martinez - Universidad Autonoma de Barcelona
#@date    2012-04-16
#*/ ##

function ogAddCmd ()
{
local MOUNTPOINT CMDFILE
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition str_filename str_commands" \
           "$FUNCNAME 1 1 filename.cmd command" 
    return
fi
# Error si no se reciben 4 parámetros.
[ $# == 4 ] || return $(ogRaiseError $OG_ERR_FORMAT; echo $?)
# Punto de montaje 
MOUNTPOINT="$(ogMount "$1" "$2") || return $?
# Comprobar que existe el fichero de comandos.
CMDFILE=$(ogGetPath "$MOUNTPOINT/windows/system32/$3")
[ -n "$CMDFILE" ] || ogRaiseError $OG_ERR_NOTFOUND "$MOUNTPOINT/windows/system32/$3" || return $?

# Concatenamos el comando en el fichero de comandos
cat >> "$CMDFILE" << EOF
$4
EOF
}

#         ogDomainScript int_ndisk int_npartition str_domain str_user str_password
#@brief   Crea un script .vbs para unir al dominio una maquina windows y el comando adequado en el archivo cmd creado por ogInstallMiniSetup
#@param   int_ndisk         nº de orden del disco
#@param   int_npartition    nº de orden de la partición
#@param   str_filename      nombre del fichero cmd donde deberemos introducir el comando de ejecutar el script vbs
#@param   str_domain        dominio donde se quiere conectar
#@param   str_user          usuario con privilegios para unir al dominio 
#@param   str_password      password del usuario con privilegios 
#@return  
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@version 1.0.2 - Nueva función
#@author  Jonathan Alonso Martinez - Universidad Autonoma de Barcelona
#@date    2011-06-29
#@version 1.0.4 - Cambios en los parametros de entrada de la funcion
#@author  Jonathan Alonso Martinez - Universidad Autonoma de Barcelona
#@date    2012-04-16
#*/ ##

function ogDomainScript ()
{
local CMDDIR
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" \
           "$FUNCNAME int_ndisk int_npartition str_filename str_domain str_user str_password" \
           "$FUNCNAME 1 1 filename.cmd domain user password_user"
    return
fi
# Error si no se reciben 6 parámetros.
[ $# == 6 ] || return $(ogRaiseError $OG_ERR_FORMAT; echo $?)
# Punto de montaje 
MOUNTPOINT="$(ogMount "$1" "$2")" || return $?
# Comprobar que existe el directorio de comandos.
CMDDIR=$(ogGetPath "$MOUNTPOINT/windows/system32")
[ -n "$CMDDIR" ] || ogRaiseError $OG_ERR_NOTFOUND "$1/windows/system32" || return $?

# Añadimos en el cmd que se ejecutara al arranque, el comando de ejecutar el script que añade al dominio.
ogAddCmd $1 $2 "$3" "CSCRIPT joindomain.vbs"
# Eliminamos el script porque tiene el usuario de administrador de dominio en claro
ogAddCmd $1 $2 "$3" "del /Q C:\Windows\System32\joindomain.vbs"
# Metemos unas claves de registro para que el dominio salga seleccionado por defecto
ogAddCmd $1 $2 "$3" "REG ADD \"HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\" /v DefaultDomainName /t REG_SZ /d \"$3\" /f"

# Creamos el archivo joindomain.vbs que nos introduce la maquina en el dominio
cat > "$CMDDIR/joindomain.vbs" << EOF
Const JOIN_DOMAIN = 1
Const ACCT_CREATE = 2
Const ACCT_DELETE = 4
Const WIN9X_UPGRADE = 16
Const DOMAIN_JOIN_IF_JOINED = 32
Const JOIN_UNSECURE = 64
Const MACHINE_PASSWORD_PASSED = 128
Const DEFERRED_SPN_SET = 256
Const INSTALL_INVOCATION = 262144

strDomain = "$4"
strUser = "$5"
strPassword = "$6"

Set objNetwork = CreateObject("WScript.Network")
strComputer = objNetwork.ComputerName

Set objComputer = GetObject("winmgmts:{impersonationLevel=Impersonate}!\\\" & _
    strComputer & "\root\cimv2:Win32_ComputerSystem.Name='" & strComputer & "'")

ReturnValue = objComputer.JoinDomainOrWorkGroup(strDomain, strPassword, _
    strDomain & "\" & strUser, NULL, JOIN_DOMAIN + ACCT_CREATE)
EOF
}

