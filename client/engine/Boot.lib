#!/bin/bash
#/**
#@file    Boot.lib
#@brief   Librería o clase Boot
#@class   Boot
#@brief   Funciones para arranque y post-configuración de sistemas de archivos.
#@version 1.1.0
#@warning License: GNU GPLv3+
#*/


#/**
#         ogBoot int_ndisk int_nfilesys [str_krnlparams]
#@brief   Inicia el proceso de arranque de un sistema de archivos.
#@param   int_ndisk      nº de orden del disco
#@param   int_nfilesys   nº de orden del sistema de archivos
#@param   str_krnlparams parámetros de arranque del kernel (opcional)
#@return  (activar el sistema de archivos).
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@exception OG_ERR_PARTITION Tipo de partición desconocido o no se puede montar.
#@exception OG_ERR_NOTOS     La partición no tiene instalado un sistema operativo.
#@note    En Linux, si no se indican los parámetros de arranque se detectan de la opción por defecto del cargador GRUB.
#@note    En Linux, debe arrancarse la partición del directorio \c /boot
#@version 0.1 - Integración para OpenGnSys. - EAC: HDboot; BootLinuxEX en Boot.lib  
#@author  Antonio J. Doblas Viso, Universidad de Malaga
#@date    2008-10-27
#@version 0.9 - Adaptación para OpenGnSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-09-11
#@version 1.0.4 - Soporta modo de arranque Windows (parámetro de inicio "winboot").
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2012-04-12
#@version 1.0.6 - Selección a partir de tipo de sistema operativo (en vez de S.F.) y arrancar Linux con /boot separado.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2015-06-05
#@version 1.1.0 - Nuevo parámetro opcional con opciones de arranque del Kernel.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2015-07-15
#*/ ##
function ogBoot ()
{
# Variables locales.
local PART TYPE MNTDIR PARAMS KERNEL INITRD APPEND FILE LOADER f

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_nfilesys [str_kernelparams" \
           "$FUNCNAME 1 1" "$FUNCNAME 1 2 \"root=/dev/sda2 ro\""
    return
fi
# Error si no se reciben 2 o 3 parámetros.
[ $# == 2 ] || [ $# == 3 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Detectar tipo de sistema de archivos y montarlo.
PART=$(ogDiskToDev $1 $2) || return $?
TYPE=$(ogGetOsType $1 $2) || return $?
# Error si no puede montar sistema de archivos.
MNTDIR=$(ogMount $1 $2) || return $?

case "$TYPE" in
    Linux|Android)
        # Si no se indican, obtiene los parámetros de arranque para Linux.
        PARAMS="${3:-$(ogLinuxBootParameters $1 $2)}"
        # Si no existe, buscar sistema de archivo /boot en /etc/fstab.
        if [ -z "$PARAMS" -a -e $MNTDIR/etc/fstab ]; then
            # Localizar S.F. /boot en /etc/fstab del S.F. actual.
            PART=$(ogDevToDisk $(awk '$2=="/boot" {print $1}' $MNTDIR/etc/fstab))
            # Montar S.F. de /boot.
            MNTDIR=$(ogMount $PART) || return $?
            # Buscar los datos de arranque.
            PARAMS=$(ogLinuxBootParameters $PART) || exit $?
        fi
        read -e KERNEL INITRD APPEND <<<"$PARAMS"
        # Si no hay kernel, no hay sistema operativo.
        [ -n "$KERNEL" ] || ogRaiseError $OG_ERR_NOTOS "$1 $2 ($TYPE)" || return $?
        # Arrancar de partición distinta a la original.
        [ -e "$MNTDIR/etc" ] && APPEND=$(echo $APPEND | awk -v P="$PART " '{sub (/root=[-+=_/a-zA-Z0-9]* /,"root="P);print}')
        # Configurar kernel Linux con los parámetros leídos de su GRUB.
        kexec -l "${MNTDIR}${KERNEL}" --append="$APPEND" --initrd="${MNTDIR}${INITRD}"
        kexec -e &
        ;;
    Windows|WinLoader)
        # Compruebar si hay un cargador de Windows.
        for f in io.sys ntldr bootmgr; do
            FILE="$(ogGetPath $1 $2 $f 2>/dev/null)"
            [ -n "$FILE" ] && LOADER="$f"
        done
        [ -n "$LOADER" ] || ogRaiseError $OG_ERR_NOTOS "$1 $2 ($TYPE)" || return $?
        if [ "$winboot" == "kexec" ]; then
            # Modo de arranque en caliente (con kexec).
            cp $OGLIB/grub4dos/* $MNTDIR    # */ (Comentario Doxygen)
            kexec -l $MNTDIR/grub.exe --append=--config-file="root (hd$[$1-1],$[$2-1]); chainloader (hd$[$1-1],$[$2-1])/$LOADER; tpm --init"
            kexec -e &
        else
            # Modo de arranque por reinicio (con reboot).
            dd if=/dev/zero of=${MNTDIR}/ogboot.me bs=1024 count=3
            dd if=/dev/zero of=${MNTDIR}/ogboot.firstboot bs=1024 count=3
            dd if=/dev/zero of=${MNTDIR}/ogboot.secondboot bs=1024 count=3
	    if  [ -z "$(ogGetRegistryValue $MNTDIR SOFTWARE '\Microsoft\Windows\CurrentVersion\Run\ogcleannboot')" ]; then               
            ogAddRegistryValue $MNTDIR SOFTWARE '\Microsoft\Windows\CurrentVersion\Run\ogcleanboot' 
            ogSetRegistryValue $MNTDIR SOFTWARE '\Microsoft\Windows\CurrentVersion\Run\ogcleanboot' "cmd /c del c:\ogboot.*"
            fi
            # Activar la partición.
            ogSetPartitionActive $1 $2
            reboot
        fi
        ;;
    MacOS)
        # Modo de arranque por reinicio.
        # Nota: el cliente tiene que tener configurado correctamente Grub.
        touch ${MNTDIR}/boot.mac &>/dev/null
        reboot
        ;;
    GrubLoader)
        # Reiniciar.
        reboot
        ;;
    *)  ogRaiseError $OG_ERR_NOTOS "$1 $2 ${TYPE:+($TYPE)}"
        return $?
        ;;
esac
}


#/**
#         ogGetWindowsName int_ndisk int_nfilesys
#@brief   Muestra el nombre del equipo en el registro de Windows.
#@param   int_ndisk      nº de orden del disco
#@param   int_nfilesys   nº de orden del sistema de archivos
#@return  str_name - nombre del equipo
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@exception OG_ERR_PARTITION Tipo de partición desconocido o no se puede montar.
#@version 0.9 - Adaptación para OpenGnSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-09-23
#*/ ##
function ogGetWindowsName ()
{
# Variables locales.
local PART MNTDIR

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
           "$FUNCNAME 1 1  ==>  PRACTICA-PC"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Montar el sistema de archivos.
MNTDIR=$(ogMount $1 $2) || return $?

# Obtener dato del valor de registro.
ogGetRegistryValue $MNTDIR system '\ControlSet001\Control\ComputerName\ComputerName\ComputerName'
}


#/**
#         ogLinuxBootParameters int_ndisk int_nfilesys
#@brief   Muestra los parámetros de arranque de un sistema de archivos Linux.
#@param   int_ndisk      nº de orden del disco
#@param   int_nfilesys   nº de orden del sistema de archivos
#@return  str_kernel str_initrd str_parameters ...
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@exception OG_ERR_PARTITION Tipo de partición desconocido o no se puede montar.
#@warning Función básica usada por \c ogBoot
#@version 0.9 - Primera adaptación para OpenGnSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-09-11
#@version 0.9.2 - Soporta partición /boot independiente.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2010-07-20
#@version 1.0.5 - Mejoras en tratamiento de GRUB2.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2013-05-14
#@version 1.0.6 - Detectar instalaciones sobre EFI.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2014-09-15
#*/ ##
function ogLinuxBootParameters ()
{
# Variables locales.
local MNTDIR CONFDIR CONFFILE f

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_nfilesys" \
           "$FUNCNAME 1 2  ==>  /vmlinuz-3.5.0-21-generic /initrd.img-3.5.0-21-generic root=/dev/sda2 ro splash"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Detectar id. de tipo de partición y codificar al mnemonico.
MNTDIR=$(ogMount $1 $2) || return $?

# Fichero de configuración de GRUB.
CONFDIR=$MNTDIR                               # Sistema de archivos de arranque (/boot).
[ -d $MNTDIR/boot ] && CONFDIR=$MNTDIR/boot   # Sist. archivos raíz con directorio boot.
for f in $MNTDIR/{,grubPARTITION/}{,boot/}{grub{,2},{,efi/}EFI/*}/{menu.lst,grub.cfg,grub.cfg.backup.og}; do
    [ -r $f ] && CONFFILE=$f
done
[ -n "$CONFFILE" ] || ogRaiseError $OG_ERR_NOTFOUND "grub.cfg" || return $?

# Toma del fichero de configuracion los valores del kernel, initrd
#       y parámetros de arranque usando las cláusulas por defecto
#       ("default" en GRUB1, "set default" en GRUB2)
#       y los formatea para que sean compatibles con \c kexec .  */
# /* (comentario Doxygen)
awk 'BEGIN {cont=-1;}
     $1~/^default$/     {sub(/=/," "); def=$2;}
     $1~/^set$/ && $2~/^default/ { gsub(/[="]/," "); def=$3;
                                   if (def ~ /saved_entry/) def=0;
                                 }
     $1~/^(title|menuentry)$/ {cont++}
     $1~/^(kernel|linux(16|efi)?)$/ { if (def==cont) {
                                       kern=$2;
                                       sub($1,""); sub($1,""); sub(/^[ \t]*/,""); app=$0
                                      } # /* (comentario Doxygen)
                                    }
     $1~/^initrd(16|efi)?$/ {if (def==cont) init=$2}
     END {if (kern!="") printf("%s %s %s", kern,init,app)}
    ' $CONFFILE
# */ (comentario Doxygen)
}


#/**
#         ogSetWindowsName int_ndisk int_nfilesys str_name
#@brief   Establece el nombre del equipo en el registro de Windows.
#@param   int_ndisk      nº de orden del disco
#@param   int_nfilesys   nº de orden del sistema de archivos
#@param   str_name       nombre asignado
#@return  (nada)
#@exception OG_ERR_FORMAT     Formato incorrecto.
#@exception OG_ERR_NOTFOUND   Disco o particion no corresponden con un dispositivo.
#@exception OG_ERR_PARTITION  Tipo de partición desconocido o no se puede montar.
#@exception OG_ERR_OUTOFLIMIT Nombre Netbios con más de 15 caracteres.
#@version 0.9 - Adaptación a OpenGnSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-09-24
#@version 1.0.5 - Establecer restricción de tamaño de nombre Netbios.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2013-03-20
#*/ ##
function ogSetWindowsName ()
{
# Variables locales.
local PART MNTDIR NAME

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_filesys str_name" \
           "$FUNCNAME 1 1 PRACTICA-PC"
    return
fi
# Error si no se reciben 3 parámetros.
[ $# == 3 ] || ogRaiseError $OG_ERR_FORMAT || return $?
# Error si el nombre supera los 15 caracteres.
[ ${#3} -le 15 ] || ogRaiseError $OG_ERR_OUTOFLIMIT "\"${3:0:15}...\"" || return $?

# Montar el sistema de archivos.
MNTDIR=$(ogMount $1 $2) || return $?

# Asignar nombre.
NAME="$3"

# Modificar datos de los valores de registro.
ogSetRegistryValue $MNTDIR system '\ControlSet001\Control\ComputerName\ComputerName\ComputerName' "$NAME" 2>/dev/null
ogSetRegistryValue $MNTDIR system '\ControlSet001\Services\Tcpip\Parameters\Hostname' "$NAME" 2>/dev/null
ogSetRegistryValue $MNTDIR system '\ControlSet001\services\Tcpip\Parameters\Hostname' "$NAME" 2>/dev/null
ogSetRegistryValue $MNTDIR system '\ControlSet001\Services\Tcpip\Parameters\NV Hostname' "$NAME" 2>/dev/null
ogSetRegistryValue $MNTDIR system '\ControlSet001\services\Tcpip\Parameters\NV Hostname' "$NAME" 2>/dev/null
}


#/**
#         ogSetWinlogonUser int_ndisk int_npartition str_username
#@brief   Establece el nombre de usuario por defecto en la entrada de Windows.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@param   str_username   nombre de usuario por defecto
#@return  (nada)
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@exception OG_ERR_PARTITION Tipo de partición desconocido o no se puede montar.
#@version 0.9.2 - Adaptación a OpenGnSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2010-07-20
#*/ ##
function ogSetWinlogonUser ()
{
# Variables locales.
local PART MNTDIR NAME

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition str_username" \
           "$FUNCNAME 1 1 USUARIO"
    return
fi
# Error si no se reciben 3 parámetros.
[ $# == 3 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Montar el sistema de archivos.
MNTDIR=$(ogMount $1 $2) || return $?

# Asignar nombre.
NAME="$3"

# Modificar datos en el registro.
ogSetRegistryValue $MNTDIR SOFTWARE '\Microsoft\Windows NT\CurrentVersion\Winlogon\DefaultUserName' "$3"
}


#/**
#         ogBootMbrXP int_ndisk
#@brief   Genera un nuevo Master Boot Record en el disco duro indicado, compatible con los SO tipo Windows
#@param   int_ndisk      nº de orden del disco
#@return  salida del programa my-sys
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_PARTITION Tipo de partición desconocido o no se puede montar.
#@version 0.9 - Adaptación a OpenGnSys.
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2009-09-24
#*/ ##

function ogBootMbrXP ()
{
# Variables locales.
local DISK

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk " \
           "$FUNCNAME 1"
    return
fi
# Error si no se recibe 1 parámetro.
[ $# == 1 ] || ogRaiseError $OG_ERR_FORMAT || return $?

DISK="$(ogDiskToDev $1)" || return $?
ms-sys -z -f $DISK
ms-sys -m -f $DISK
}


#/**
#         ogBootMbrGeneric int_ndisk
#@brief   Genera un nuevo Codigo de arranque en el MBR del disco indicado, compatible con los SO tipo Windows, Linux.
#@param   int_ndisk      nº de orden del disco
#@return  salida del programa my-sys
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND Tipo de partición desconocido o no se puede montar.
#@version 0.9 - Adaptación a OpenGnSys.
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2009-09-24
#*/ ##

function ogBootMbrGeneric ()
{
# Variables locales.
local DISK

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk " \
           "$FUNCNAME 1 "
    return
fi
# Error si no se recibe 1 parámetro.
[ $# == 1 ] || return $(ogRaiseError $OG_ERR_FORMAT; echo $?) 

DISK="$(ogDiskToDev $1)" || return $?
ms-sys -z -f $DISK
ms-sys -s -f $DISK
}




#/**
#         ogFixBootSector int_ndisk int_parition
#@brief   Corrige el boot sector de una particion activa para MS windows/dos -fat-ntfs
#@param   int_ndisk      nº de orden del disco
#@param   int_partition     nº de particion
#@return  
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_PARTITION Tipo de partición desconocido o no se puede montar.
#@version 0.9 - Adaptación a OpenGnSys.
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2009-09-24
#*/ ##

function ogFixBootSector ()
{
# Variables locales.
local PARTYPE DISK PART FILE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_partition " \
           "$FUNCNAME 1 1 "
    return
fi

# Error si no se reciben 2 parámetros.
[ $# == 2 ] || return $(ogRaiseError $OG_ERR_FORMAT; echo $?)

#TODO, solo si la particion existe
#TODO, solo si es ntfs o fat
PARTYPE=$(ogGetPartitionId $1 $2) 
case "$PARTYPE" in
	1|4|6|7|b|c|e|f|17|700)
	;;
	*)
	return $(ogRaiseError $OG_ERR_PARTITION; echo $?)
	;;
esac

ogUnmount $1 $2 || return $(ogRaiseError $OG_ERR_PARTITION; echo $?)

#Preparando instruccion	
let DISK=$1-1	
PART=$2
FILE=/tmp/temp$$
cat > $FILE <<EOF
disk=$DISK
main_part=$PART
fix_first_sector=yes
EOF

spartlnx.run -cui -nm -a -f $FILE &
sleep 5
ps aux > /dev/null | grep $! | grep -E "T|S" | kill -9 $! > /dev/null
rm -f $FILE
}



#/**
#         ogWindowsBootParameters int_ndisk int_parition
#@brief   Configura el gestor de arranque de windows 7 / vista / XP / 2000
#@param   int_ndisk      nº de orden del disco
#@param   int_partition     nº de particion
#@return  
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_PARTITION Tipo de partición desconocido o no se puede montar.
#@version 0.9 - Integración desde EAC para OpenGnSys.
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2009-09-24
#@version 1.0.1 - Adapatacion para OpenGnsys.
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2011-05-20
#@version 1.0.5 - Soporte para Windows 8 y Windows 8.1.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2014-01-28
#*/ ##

function ogWindowsBootParameters ()
{
# Variables locales.
local PART DISK FILE VERSION WINVER MOUNT

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_partition " \
           "$FUNCNAME 1 1 "
    return
fi

# Error si no se reciben 2 parámetros.
[ $# == 2 ] || return $(ogRaiseError $OG_ERR_FORMAT; echo $?)

ogDiskToDev $1 $2 || return $(ogRaiseError $OG_ERR_PARTITION; echo $?)

#Preparando variables adaptadas a sintaxis windows.
let DISK=$1-1
PART=$2	
FILE=/tmp/temp$$

VERSION=$(ogGetOsVersion $1 $2)

if echo "$VERSION" | grep "Windows 8.1"
then
	WINVER="Windows 8.1"
elif echo "$VERSION" | grep "Windows 8"
then
	WINVER="Windows 8"
elif echo "$VERSION" | grep "Windows 7"
then
	WINVER="Windows 7"
elif echo "$VERSION" | grep "Windows Seven"
then 
	WINVER="Windows Vista"
elif echo "$VERSION" | grep "XP"
then
	MOUNT=$(ogMount $1 $2)
	[ -f ${MOUNT}/boot.ini ] || return $(ogRaiseError $OG_ERR_NOTOS; echo $?)
	cat ${MOUNT}/boot.ini | sed s/partition\([0-9]\)/partition\($PART\)/g | sed s/rdisk\([0-9]\)/rdisk\($DISK\)/g > ${MOUNT}/tmp.boot.ini; mv ${MOUNT}/tmp.boot.ini ${MOUNT}/boot.ini
	return 0
else
	return $(ogRaiseError $OG_ERR_NOTOS; echo $?)
fi

ogUnmount $1 $2 || return $(ogRaiseError $OG_ERR_PARTITION; echo $?)


#Preparando instruccion	Windows Resume Application
cat > $FILE <<EOF
boot_disk=$DISK
boot_main_part=$PART
disk=$DISK
main_part=$PART
boot_entry=Windows Resume Application
EOF
spartlnx.run -cui -nm -w -f $FILE &
sleep 5
ps aux > /dev/null | grep $! | grep -E "T|S" | kill -9 $! > /dev/null

 

#Preparando instruccion	tipo windows
cat > $FILE <<EOF
boot_disk=$DISK
boot_main_part=$PART
disk=$DISK
main_part=$PART
boot_entry=$WINVER
EOF
spartlnx.run -cui -nm -w -f $FILE &
sleep 5
ps aux > /dev/null | grep $! | grep -E "T|S" | kill -9 $! > /dev/null


##Preparando instruccion	Ramdisk Options
cat > $FILE <<EOF
boot_disk=$DISK
boot_main_part=$PART
disk=$DISK
main_part=$PART
boot_entry=Ramdisk Options
EOF
spartlnx.run -cui -nm -w -f $FILE &
sleep 5
ps aux > /dev/null | grep $! | grep -E "T|S" | kill -9 $! > /dev/null


#Preparando instruccion	Windows Boot Manager
cat > $FILE <<EOF
boot_disk=$DISK
boot_main_part=$PART
disk=$DISK
main_part=$PART
boot_entry=Windows Boot Manager
EOF
spartlnx.run -cui -nm -w -f $FILE &
sleep 5
ps aux > /dev/null | grep $! | grep -E "T|S" | kill -9 $! > /dev/null


#Preparando instruccion	Herramienta de diagnóstico de memoria de Windows
cat > $FILE <<EOF
boot_disk=$DISK
boot_main_part=$PART
disk=$DISK
main_part=$PART
boot_entry=Herramienta de diagnóstico de memoria de Windows
EOF
spartlnx.run -cui -nm -w -f $FILE &
sleep 5
ps aux > /dev/null | grep $! | grep -E "T|S" | kill -9 $! > /dev/null

}


#         ogWindowsRegisterPartition int_ndisk int_partiton str_volume int_disk int_partition
#@brief   Registra una partición en windows con un determinado volumen.
#@param   int_ndisk      nº de orden del disco a registrar
#@param   int_partition     nº de particion a registrar
#@param   str_volumen      volumen a resgistar
#@param   int_ndisk_windows      nº de orden del disco donde esta windows
#@param   int_partition_windows     nº de particion donde esta windows
#@return  
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_PARTITION Tipo de partición desconocido o no se puede montar.
#@version 0.9 - Adaptación a OpenGnSys.
#@author  Antonio J. Doblas Viso. Universidad de Málaga
#@date    2009-09-24
#*/ ##
function ogWindowsRegisterPartition ()
{
# Variables locales.
local PART DISK FILE REGISTREDDISK REGISTREDPART REGISTREDVOL VERSION SYSTEMROOT

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk_TO_registre int_partition_TO_registre str_NewVolume int_disk int_parition " \
           "$FUNCNAME 1 1 c: 1 1"
    return
fi

# Error si no se reciben 5 parámetros.
[ $# == 5 ] || return $(ogRaiseError $OG_ERR_FORMAT; echo $?)

REGISTREDDISK=$1
REGISTREDPART=$2
REGISTREDVOL=$(echo $3 | cut -c1 | tr '[:lower:]' '[:upper:]')
DISK=$4
PART=$5
FILE=/tmp/temp$$

ogDiskToDev $REGISTREDDISK $REGISTREDPART || return $(ogRaiseError $OG_ERR_PARTITION "particion a registrar "; echo $?)
ogDiskToDev $DISK $PART || return $(ogRaiseError $OG_ERR_PARTITION "particion de windows"; echo $?)

ogGetOsType $DISK $PART | grep "Windows" || return $(ogRaiseError $OG_ERR_NOTOS "no es windows"; echo $?)

VERSION=$(ogGetOsVersion $DISK $PART)

#Systemroot

if ogGetPath $DISK $PART WINDOWS
then
	SYSTEMROOT="Windows"
elif ogGetPath $DISK $PART WINNT
then 
	SYSTEMROOT="winnt"
else
	return $(ogRaiseError $OG_ERR_NOTOS; echo $?)
fi

ogUnmount $DISK $PART
let DISK=$DISK-1
let REGISTREDDISK=$REGISTREDDISK-1
#Preparando instruccion	Windows Boot Manager
cat > $FILE <<EOF
windows_disk=$DISK
windows_main_part=$PART
windows_dir=$SYSTEMROOT
disk=$REGISTREDDISK
main_part=$REGISTREDPART
;ext_part
part_letter=$REGISTREDVOL
EOF
spartlnx.run -cui -nm -u -f $FILE &
sleep 5
ps aux > /dev/null | grep $! | grep -E "T|S" | kill -9 $! > /dev/null

}


#         ogGrubInstallMbr  int_disk_GRUBCFG  int_partition_GRUBCFG #@param   bolean_Check_Os_installed_and_Configure_2ndStage   true | false[default] 
#@brief   Instala y actualiza el gestor grub el el MBR del disco duro donde se encuentra el fichero grub.cfg. Admite sistemas Windows.
#@param   int_disk_SecondStage      
#@param   int_part_SecondStage     
#@param   bolean_Check_Os_installed_and_Configure_2ndStage   true | false[default] 
#@return  
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@version 1.0.2 - Primeras pruebas.
#@author  Antonio J. Doblas Viso.   Universidad de Malaga.
#@date    2011-10-29
#@version 1.0.3 - Soporte para linux de 32 y 64 bits 
#@author  Antonio J. Doblas Viso.   Universidad de Malaga.
#@date    2012-03-13
#@version 1.0.3 - Ficheros de configuracion independientes segun ubicación de la primera etapa
#@author  Antonio J. Doblas Viso.   Universidad de Malaga.
#@date    2012-03-13
#*/ ##

function ogGrubInstallMbr {

# Variables locales.
local PART DISK VERSION FIRSTAGE SECONSTAGE CHECKOS KERNELPARAM BACKUPNAME

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME  int_ndiskSecondStage int_partitionSecondStage bolean_Configure_2ndStage   \"param param \"  " \
           "$FUNCNAME 1 1 FALSE " \
           "$FUNCNAME 1 1 TRUE \"nomodeset irqpoll pci=noacpi quiet splash \" "
    return
fi  

# Error si no se reciben 2 parÃ¡metros.
[ $# -ge 2 ] || return $(ogRaiseError $OG_ERR_FORMAT; echo $?)


DISK=$1; PART=$2;
CHECKOS=${3:-"FALSE"}
KERNELPARAM=$4
BACKUPNAME=".backup.og"

#Error si no es linux.
#TODO: comprobar si se puede utilizar la particion windows como contenedor de grub.
#VERSION=$(ogGetOsVersion $DISK $PART) 
#echo $VERSION | grep "Linux" || return $(ogRaiseError $OG_ERR_NOTOS "no es linux"; echo $?)

#Localizar primera etapa del grub
FIRSTSTAGE=$(ogDiskToDev $DISK)

#localizar disco segunda etapa del grub
SECONDSTAGE=$(ogMount $DISK $PART)

# prepara el directorio principal de la segunda etapa
[ -d ${SECONDSTAGE}/boot/grub/ ]  || mkdir -p ${SECONDSTAGE}/boot/grub/

#Localizar directorio segunda etapa del grub   
PREFIXSECONDSTAGE="/boot/grubMBR"

# Si Reconfigurar segunda etapa (grub.cfg) == FALSE
if [ -f ${SECONDSTAGE}/boot/grub/grub.cfg -o -f ${SECONDSTAGE}/boot/grub/grub.cfg$BACKUPNAME ]
then 
    if [ "$CHECKOS" == "false" -o "$CHECKOS" == "FALSE" ]
    then
        # Si no se reconfigura se utiliza el grub.cfg orginal
        [ -f ${SECONDSTAGE}/boot/grub/grub.cfg$BACKUPNAME ] && mv ${SECONDSTAGE}/boot/grub/grub.cfg$BACKUPNAME ${SECONDSTAGE}/boot/grub/grub.cfg
		# Si no se reconfigure se borra los ficheros previos de configuración específicos de opengnsys.
        [ -d ${SECONDSTAGE}${PREFIXSECONDSTAGE} ] &&  rm -fr ${SECONDSTAGE}${PREFIXSECONDSTAGE}
        # Reactivamos el grub con el grub.cfg original.
        grub-install --force --root-directory=${SECONDSTAGE} $FIRSTSTAGE
        return $?
    fi
fi

# SI Reconfigurar segunda etapa (grub.cfg) == TRUE 
#Configur la sintaxis grub para evitar menus de "recovery" en el OGLive
echo "GRUB_DISABLE_RECOVERY=\"true\"" >> /etc/default/grub
echo "GRUB_DISABLE_LINUX_UUID=\"true\"" >> /etc/default/grub

#Evitar detectar modo recovery - mover grub.cfg original a grub.cfg.backup
[ -f ${SECONDSTAGE}/boot/grub/grub.cfg ] && mv ${SECONDSTAGE}/boot/grub/grub.cfg ${SECONDSTAGE}/boot/grub/grub.cfg$BACKUPNAME 

#Preparar configuración segunda etapa: crear ubicacion
mkdir -p ${SECONDSTAGE}${PREFIXSECONDSTAGE}/boot/grub/
#Preparar configuración segunda etapa: crear cabecera del fichero
/etc/grub.d/00_header > ${SECONDSTAGE}${PREFIXSECONDSTAGE}/boot/grub/grub.cfg
#Preparar configuración segunda etapa: crear entrada del sistema operativo
grubSyntax "$KERNELPARAM" >> ${SECONDSTAGE}${PREFIXSECONDSTAGE}/boot/grub/grub.cfg

#Instalar el grub 
grub-install --force --root-directory=${SECONDSTAGE}${PREFIXSECONDSTAGE} $FIRSTSTAGE
}



#         ogGrubInstallPartition int_disk_SECONDSTAGE  int_partition_SECONDSTAGE bolean_Check_Os_installed_and_Configure_2ndStage
#@brief   Instala y actualiza el gestor grub en el bootsector de la particion indicada
#@param   int_disk_SecondStage      
#@param   int_part_SecondStage     
#@param   bolean_Check_Os_installed_and_Configure_2ndStage   true | false[default] 
#@param   str "kernel param "   
#@return  
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@version 1.0.2 - Primeras pruebas.
#@author  Antonio J. Doblas Viso.   Universidad de Malaga.
#@date    2011-10-29
#@version 1.0.3 - Soporte para linux de 32 y 64 bits 
#@author  Antonio J. Doblas Viso.   Universidad de Malaga.
#@date    2012-03-13
#@version 1.0.3 - Ficheros de configuracion independientes segun ubicación de la priemra etapa
#@author  Antonio J. Doblas Viso.   Universidad de Malaga.
#@date    2012-03-13
#*/ ##

function ogGrubInstallPartition {

# Variables locales.
local PART DISK VERSION FIRSTAGE SECONSTAGE CHECKOS KERNELPARAM BACKUPNAME

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndiskSecondStage int_partitionSecondStage bolean_Configure_2ndStage   \"param param \" " \
           "$FUNCNAME 1 1 FALSE " \
           "$FUNCNAME 1 1 TRUE \"nomodeset irqpoll pci=noacpi quiet splash \" "
    return
fi  

# Error si no se reciben 2 parÃ¡metros.
[ $# -ge 2 ] || return $(ogRaiseError $OG_ERR_FORMAT; echo $?)

DISK=$1; PART=$2;
CHECKOS=${3:-"FALSE"}
KERNELPARAM=$4
BACKUPNAME=".backup.og"

#error si no es linux.
VERSION=$(ogGetOsVersion $DISK $PART) 
echo $VERSION | grep "Linux" || return $(ogRaiseError $OG_ERR_NOTOS "no es linux"; echo $?)

#Localizar primera etapa del grub
FIRSTSTAGE=$(ogDiskToDev $DISK $PART)

#localizar disco segunda etapa del grub
SECONDSTAGE=$(ogMount $DISK $PART)

#Localizar directorio segunda etapa del grub    
PREFIXSECONDSTAGE="/boot/grubPARTITION"

# Si Reconfigurar segunda etapa (grub.cfg) == FALSE
if [ -f ${SECONDSTAGE}/boot/grub/grub.cfg -o -f ${SECONDSTAGE}/boot/grub/grub.cfg$BACKUPNAME ]
then 
    if [ "$CHECKOS" == "false" -o "$CHECKOS" == "FALSE" ]
    then
        # Si no se reconfigura se utiliza el grub.cfg orginal
        [ -f ${SECONDSTAGE}/boot/grub/grub.cfg$BACKUPNAME ] && mv ${SECONDSTAGE}/boot/grub/grub.cfg$BACKUPNAME ${SECONDSTAGE}/boot/grub/grub.cfg
		# Si no se reconfigure se borra los ficheros previos de configuración específicos de opengnsys.
        [ -d ${SECONDSTAGE}${PREFIXSECONDSTAGE} ] &&  rm -fr ${SECONDSTAGE}${PREFIXSECONDSTAGE}
        # Reactivamos el grub con el grub.cfg original.
        grub-install --force --root-directory=${SECONDSTAGE} $FIRSTSTAGE
        return $?
    fi
fi

# SI Reconfigurar segunda etapa (grub.cfg) == TRUE 
#Configur la sintaxis grub para evitar menus de "recovery" en el OGLive
echo "GRUB_DISABLE_RECOVERY=\"true\"" >> /etc/default/grub
echo "GRUB_DISABLE_LINUX_UUID=\"true\"" >> /etc/default/grub

#Evitar detectar modo recovery - mover grub.cfg original a grub.cfg.backup.og
[ -f ${SECONDSTAGE}/boot/grub/grub.cfg ] && mv ${SECONDSTAGE}/boot/grub/grub.cfg ${SECONDSTAGE}/boot/grub/grub.cfg$BACKUPNAME 

#Preparar configuración segunda etapa: crear ubicacion
mkdir -p ${SECONDSTAGE}${PREFIXSECONDSTAGE}/boot/grub/
#Preparar configuración segunda etapa: crear cabecera del fichero
/etc/grub.d/00_header > ${SECONDSTAGE}${PREFIXSECONDSTAGE}/boot/grub/grub.cfg
#Preparar configuración segunda etapa: crear entrada del sistema operativo
grubSyntax $DISK $PART "$KERNELPARAM" >> ${SECONDSTAGE}${PREFIXSECONDSTAGE}/boot/grub/grub.cfg

#Instalar el grub 
grub-install --force --root-directory=${SECONDSTAGE}${PREFIXSECONDSTAGE} $FIRSTSTAGE
}

###
#En pruebas
##
#/**
#         ogConfigureFstab int_ndisk int_nfilesys
#@brief   Establece el nombre del equipo en los ficheros hostname y hosts.
#@param   int_ndisk      nº de orden del disco
#@param   int_nfilesys   nº de orden del sistema de archivos
#@return  (nada)
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  No se encuentra el fichero fstab a procesar.
#@warning Puede haber un error si hay más de 1 partición swap.
#@version 1.0.5 - Primera versión para OpenGnSys.
#@author  Antonio J. Doblas Viso.   Universidad de Malaga.
#@date    2013-03-21
#*/ ##
function ogConfigureFstab {
# Variables locales.
local FSTAB DEFROOT PARTROOT DEFSWAP PARTSWAP

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_nfilesys" \
           "$FUNCNAME 1 1"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?
# Error si no se encuentra un fichero  etc/fstab  en el sistema de archivos.
FSTAB=$(ogGetPath $1 $2 /etc/fstab) 2>/dev/null
[ -n "$FSTAB" ] || ogRaiseError $OG_ERR_NOTFOUND "$1,$2,/etc/fstab" || return $?

# Hacer copia de seguridad del fichero fstab original.
cp -a ${FSTAB} ${FSTAB}.backup
# Dispositivo del raíz en fichero fstab: 1er campo (si no tiene "#") con 2º campo = "/".
DEFROOT=$(awk '$1!~/#/ && $2=="/" {print $1}' ${FSTAB})
PARTROOT=$(ogDiskToDev $1 $2)
# Configuración de swap (solo 1ª partición detectada).
PARTSWAP=$(blkid -t TYPE=swap | awk -F: 'NR==1 {print $1}')
if [ -n "$PARTSWAP" ]
then
    # Dispositivo de swap en fichero fstab: 1er campo (si no tiene "#") con 3er campo = "swap".
    DEFSWAP=$(awk '$1!~/#/ && $3=="swap" {print $1}' ${FSTAB})
    if [ -n "$DEFSWAP" ]
    then
        echo "Hay definicion de swap en el fstab $DEFSWAP -> modificamos fichero con nuevo valor $DEFSWAP->$PARTSWAP"	# Mensaje temporal.
        sed "s|$DEFSWAP|$PARTSWAP|g ; s|$DEFROOT|$PARTROOT|g" ${FSTAB}.backup > ${FSTAB}
    else
        echo "No hay definicion de swap y si hay partición swap -> moficamos fichero"	# Mensaje temporal.
        sed "s|$DEFROOT|$PARTROOT|g" ${FSTAB}.backup > ${FSTAB}
        echo "$PARTSWAP  none    swap    sw   0  0" >> ${FSTAB}
    fi  
else
    echo "No hay partición swap -> configuramos fstba"	# Mensaje temporal.
    sed "s|$DEFROOT|$PARTROOT|g" ${FSTAB}.backup > ${FSTAB}
fi
}


###
#En pruebas
##
#/**
#         ogSetLinuxName int_ndisk int_nfilesys [str_name]
#@brief   Establece el nombre del equipo en los ficheros hostname y hosts.
#@param   int_ndisk      nº de orden del disco
#@param   int_nfilesys   nº de orden del sistema de archivos
#@param   str_name       nombre asignado (opcional)
#@return  (nada)
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@exception OG_ERR_PARTITION Tipo de partición desconocido o no se puede montar.
#@note    Si no se indica nombre, se asigna un valor por defecto.
#@version 1.0.5 - Primera versión para OpenGnSys.
#@author  Antonio J. Doblas Viso.   Universidad de Malaga.
#@date    2013-03-21
#*/ ##
function ogSetLinuxName ()
{
# Variables locales.
local MNTDIR ETC NAME

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_nfilesys [str_name]" \
           "$FUNCNAME 1 1" "$FUNCNAME 1 1 practica-pc"
    return
fi
# Error si no se reciben 2 o 3 parámetros.
case $# in
    2)   # Asignar nombre automático (por defecto, "pc").
         NAME="$(ogGetHostname)"
         NAME=${NAME:-"pc"} ;;
    3)   # Asignar nombre del 3er parámetro.
         NAME="$3" ;;
    *)   # Formato de ejecución incorrecto.
         ogRaiseError $OG_ERR_FORMAT
         return $?
esac

# Montar el sistema de archivos.
MNTDIR=$(ogMount $1 $2) || return $?

ETC=$(ogGetPath $1 $2 /etc)

if [ -d "$ETC" ]; then 
	#cambio de nombre en hostname
	echo "$NAME" > $ETC/hostname
	#Opcion A para cambio de nombre en hosts
	#sed "/127.0.1.1/ c\127.0.1.1 \t $HOSTNAME" $ETC/hosts > /tmp/hosts && cp /tmp/hosts $ETC/ && rm /tmp/hosts
	#Opcion B componer fichero de hosts
        cat > $ETC/hosts <<EOF
127.0.0.1       localhost
127.0.1.1       $NAME

# The following lines are desirable for IPv6 capable hosts
::1     ip6-localhost ip6-loopback
fe00::0 ip6-localnet
ff00::0 ip6-mcastprefix
ff02::1 ip6-allnodes
ff02::2 ip6-allrouters
EOF
fi
}


###
#En pruebas
##
#/**
#         ogCleanLinuxDevices int_ndisk int_nfilesys
#@brief   Limpia los dispositivos del equipo de referencia. Interfaz de red ...
#@param   int_ndisk      nº de orden del disco
#@param   int_nfilesys   nº de orden del sistema de archivos
#@return  (nada)
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@exception OG_ERR_PARTITION Tipo de partición desconocido o no se puede montar.
#@version 1.0.5 - Primera versión para OpenGnSys.
#@author  Antonio J. Doblas Viso.   Universidad de Malaga.
#@date    2013-03-21
#*/ ##
function ogCleanLinuxDevices ()
{
# Variables locales.
local MNTDIR

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_nfilesys" \
           "$FUNCNAME 1 1"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Montar el sistema de archivos.
MNTDIR=$(ogMount $1 $2) || return $?

# Eliminar fichero de configuración de udev para dispositivos fijos de red.
rm -f ${MNTDIR}/etc/udev/rules.d/70-persistent-net.rules
}

#/**
# ogGrubAddOgclient num_disk num_part [ timeout ] [ offline ]
#@brief   Crea entrada de menu grub para ogclient, tomando como paramentros del kernel los actuales del cliente.
#@param 1 Numero de disco
#@param 2 Numero de particion
#@param 3 timeout  Segundos de espera para iniciar el sistema operativo por defecto (opcional)
#@param 4 offline  configura el modo offline [offline|online] (opcional)
#@return  (nada)
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND No existe kernel o initrd  en cache.
#@exception OG_ERR_NOTFOUND No existe archivo de configuracion del grub.
# /// FIXME: Solo para el grub instalado en MBR por Opengnsys, ampliar para más casos.
#*/

ogGrubAddOgclient () {
    local TIMEOUT DIRMOUNT GRUBGFC PARTTABLETYPE NUMDISK NUMPART KERNEL STATUS NUMLINE MENUENTRY

    # Si se solicita, mostrar ayuda.
    if [ "$*" == "help" ]; then
        ogHelp  "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition [ time_out ] [ offline|online ] " \
                "$FUNCNAME 1 1" \
                "$FUNCNAME 1 6 15 offline"
        return
    fi

    # Error si no se reciben 2 parámetros.
    [ $# -lt 2 ] && return $(ogRaiseError session $OG_ERR_FORMAT "$MSG_FORMAT: $FUNCNAME num_disk num_part [ timeout ]"; echo $?)
    [[ "$3" =~ ^[0-9]*$ ]] && TIMEOUT="$3"

    # Error si no existe el kernel y el initrd en la cache.
    # Falta crear nuevo codigo de error.
    [ -r $OGCAC/boot/ogvmlinuz -a -r $OGCAC/boot/oginitrd.img ] || return $(ogRaiseError log session $OG_ERR_NOTFOUND "CACHE: ogvmlinuz, oginitrd.img" 1>&2; echo $?)

    # Archivo de configuracion del grub
    DIRMOUNT=$(ogMount $1 $2)
    GRUBGFC="$DIRMOUNT/boot/grubMBR/boot/grub/grub.cfg"

    # Error si no existe archivo del grub
    [ -r $GRUBGFC ] || return $(ogRaiseError log session $OG_ERR_NOTFOUND  "$GRUBGFC" 1>&2; echo $?)

    # Si existe la entrada de opengnsys nos salimos.
    grep "menuentry Opengnsys" $GRUBGFC &>/dev/null && return 0

    # Tipo de tabla de particiones
    PARTTABLETYPE=$(ogGetPartitionTableType $1 | tr [:upper:] [:lower:])

    # Localizacion de la cache
    read NUMDISK NUMPART <<< $(ogFindCache)
    let NUMDISK=$NUMDISK-1
    # kernel y sus opciones. Pasamos a modo usuario
    KERNEL="/boot/ogvmlinuz $(sed -e s/^.*linuz//g -e s/ogactiveadmin=true/ogactiveadmin=false/g /proc/cmdline)"

    # Configuracion offline si existe parametro
    echo "$@" |grep offline &>/dev/null && STATUS=offline
    echo "$@" |grep online  &>/dev/null && STATUS=online
    [ -z "$STATUS" ] || KERNEL="$(echo $KERNEL | sed  s/"ogprotocol=[a-z]* "/"ogprotocol=local "/g ) ogstatus=$STATUS"

    # Numero de línea de la primera entrada del grub.
    NUMLINE=$(grep -n -m 1 "^menuentry" $GRUBGFC|cut -d: -f1)
    # Texto de la entrada de opengnsys
MENUENTRY="menuentry "Opengnsys"  --class gnu-linux --class gnu --class os { \n \
\tinsmod part_$PARTTABLETYPE \n \
\tinsmod ext2 \n \
\tset root='(hd${NUMDISK},$PARTTABLETYPE${NUMPART})' \n \
\tlinux $KERNEL \n \
\tinitrd /boot/oginitrd.img \n \
}"


    # Insertamos la entrada de opengnsys antes de la primera entrada existente.
    sed -i "${NUMLINE}i\ $MENUENTRY" $GRUBGFC

    # Ponemos que la entrada por defecto sea la primera.
    sed -i s/"set.*default.*$"/"set default=\"0\""/g $GRUBGFC

    # Si me dan valor para timeout lo cambio en el grub.
    [ $TIMEOUT ] &&  sed -i s/timeout=.*$/timeout=$TIMEOUT/g $GRUBGFC
}


#/**
# ogGrubHidePartitions num_disk num_part
#@brief Configura el grub para que oculte las particiones de windows que no se esten iniciando.
#@param 1 Numero de disco
#@param 2 Numero de particion
#@return  (nada)
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception No existe archivo de configuracion del grub.
#@ /// FIXME: Solo para el grub instalado en MBR por Opengnsys, ampliar para más casos.
#*/
function ogGrubHidePartitions {
    local DIRMOUNT GRUBGFC PARTTABLETYPE WINENTRY ENTRY TEXT ENTRY2 LINE2 PART2 HIDDEN

    # Si se solicita, mostrar ayuda.
    if [ "$*" == "help" ]; then
        ogHelp  "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
                "$FUNCNAME 1 6"
        return
    fi

    # Error si no se reciben 2 parámetros.
    [ $# -lt 2 ] && return $(ogRaiseError session $OG_ERR_FORMAT "$MSG_FORMAT: $FUNCNAME num_disk num_part"; echo $?)

    # Archivo de configuracion del grub
    DIRMOUNT=$(ogMount $1 $2)
    GRUBGFC="$DIRMOUNT/boot/grubMBR/boot/grub/grub.cfg"

    # Error si no existe archivo del grub
    [ -r $GRUBGFC ] || return $(ogRaiseError log session $OG_ERR_NOTFOUND  "$GRUBGFC" 1>&2; echo $?)

    # Si solo hay una entrada de Windows me salgo
    [ $(grep -n "menuentry.*Windows" $GRUBGFC |wc -l) -eq 1 ] && return 0

    # Elimino llamadas a parttool, se han incluido en otras ejecuciones de esta funcion.
    sed -i '/parttool/d' $GRUBGFC

    PARTTABLETYPE=$(ogGetPartitionTableType $1 | tr [:upper:] [:lower:])

    # Entradas de Windows: numero de linea y particion. De mayor a menor.
    WINENTRY=$(awk '/menuentry.*Windows/ { gsub(/\/dev\/sda/,""); gsub(/\)\"/, "");  print NR":"$6} ' $GRUBGFC | sed '1!G;h;$!d' )
    # Modifico todas las entradas de Windows.
    for ENTRY in $WINENTRY; do
        LINE=${ENTRY%:*}
        # En cada entrada, oculto o muestro cada particion.
        TEXT=""
        for ENTRY2 in $WINENTRY; do
                LINE2=${ENTRY2%:*}
                PART2=${ENTRY2#*:}
                # Muestro solo la particion de la entrada actual.
                [ $LINE2 -eq $LINE ] && HIDDEN="-" || HIDDEN="+"

                TEXT="\tparttool (hd0,$PARTTABLETYPE$PART2) hidden$HIDDEN \n$TEXT"
        done
	
        sed -i "${LINE}a\ $TEXT" $GRUBGFC
    done

    # Activamos la particion que se inicia en todas las entradas de windows.
    sed -i "/chainloader/i\\\tparttool \$\{root\} boot+"  $GRUBGFC

}

#/**
# ogGrubDeleteEntry num_disk num_part num_part_delete
#@brief Borra en el grub las entradas para el inicio en una particion.
#@param 1 Numero de disco donde esta el grub
#@param 2 Numero de particion donde esta el grub
#@parm 3 Numero de la particion de la que borramos las entradas
#@return  (nada)
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception No existe archivo de configuracion del grub.
#@ /// FIXME: Solo para el grub instalado en MBR por Opengnsys, ampliar para más casos.
#*/


function ogGrubDeleteEntry {
    local DIRMOUNT GRUBGFC MENUENTRY DELETEENTRY ENDENTRY ENTRY

    # Si se solicita, mostrar ayuda.
    if [ "$*" == "help" ]; then
        ogHelp  "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition int_npartition_delete" \
                "$FUNCNAME 1 6 2"
        return
    fi

    # Error si no se reciben 3 parámetros.
    [ $# -lt 3 ] && return $(ogRaiseError session $OG_ERR_FORMAT "$MSG_FORMAT: $FUNCNAME num_disk num_part"; echo $?)

    # Archivo de configuracion del grub
    DIRMOUNT=$(ogMount $1 $2)
    GRUBGFC="$DIRMOUNT/boot/grubMBR/boot/grub/grub.cfg"

    # Error si no existe archivo del grub)
    [ -r $GRUBGFC ] || return $(ogRaiseError log session $OG_ERR_NOTFOUND  "$GRUBGFC"; echo $?)

    # Numero de linea de cada entrada, de mayor a menor.
    MENUENTRY="$(grep -n -e menuentry.*/dev/sda $GRUBGFC| cut -d: -f1 | sed '1!G;h;$!d' )"

    # Entradas que hay que borrar.
    DELETEENTRY=$(grep -n menuentry.*/dev/sda$3 $GRUBGFC| cut -d: -f1)

    # Recorremos el fichero del final hacia el principio.
    ENDENTRY="$(wc -l $GRUBGFC|cut  -d" " -f1)"
    for ENTRY in $MENUENTRY; do
        # Comprobamos si hay que borrar la entrada.
        if  ogCheckStringInGroup $ENTRY "$DELETEENTRY" ; then
            let ENDENTRY=$ENDENTRY-1
            sed -i -e $ENTRY,${ENDENTRY}d  $GRUBGFC
        fi

        # Guardamos el número de línea de la entrada, que sera el final de la siguiente.
        ENDENTRY=$ENTRY
    done

}

