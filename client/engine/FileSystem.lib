#!/bin/bash
#/**
#@file    FileSystem.lib
#@brief   Librería o clase FileSystem
#@class   FileSystem
#@brief   Funciones para gestión de sistemas de archivos.
#@version 0.9
#@warning License: GNU GPLv3+
#*/


#/**
#         ogCheckFs int_ndisk int_npartition
#@brief   Comprueba el estado de un sistema de archivos.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@return  (nada)
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@exception OG_ERR_PARTITION Partición desconocida o no accesible.
#@note    Requisitos: *fsck*
#@warning No se comprueban sistemas de archivos montados o bloqueados.
#@todo    Definir salidas.
#@version 0.9 - Primera adaptación para OpenGNSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-10-07
#*/
function ogCheckFs ()
{
# Variables locales.
local PART TYPE PROG PARAMS

#/// Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?
#/// Obtener partición.
PART="$(ogDiskToDev $1 $2)" || return $?

TYPE=$(ogGetFsType $1 $2)
case "$TYPE" in
    EXT[234])     PROG="e2fsck" ;;
    REISERFS)     PROG="reiserfsck"; PARAMS="<<<\"Yes\"" ;;
    JFS)          PROG="fsck.jfs" ;;
    XFS)          PROG="fsck.xfs" ;;
    NTFS|HNTFS)   PROG="ntfsfix" ;;
    FAT32|HFAT32) PROG="dosfsck"; PARAMS="-a" ;;
    FAT16|HFAT16) PROG="dosfsck"; PARAMS="-a" ;;
    FAT12|HFAT12) PROG="dosfsck"; PARAMS="-a" ;;
    *)            ogRaiseError $OG_ERR_PARTITION "$1, $2, $TYPE"
	              return $? ;;
esac
#/// Error si el sistema de archivos esta montado o bloqueado.
if ogIsMounted $1 $2; then
    ogRaiseError $OG_ERR_PARTITION "$1 $2"       # Indicar nuevo error
    return $?
fi
if ogIsLocked $1 $2; then
    ogRaiseError $OG_ERR_LOCKED "$1 $2"
    return $?
fi
#/// Comprobar en modo uso exclusivo.
ogLock $1 $2
eval $PROG $PARAMS $PART
ERRCODE=$?
case $ERRCODE in
    0)    ;;
    127)  ogRaiseError $OG_ERR_NOTEXEC "$PROG" ;;
    *)    ogRaiseError $OG_ERR_PARTITION "$1 $2" ;;
esac
ogUnlock $1 $2
return $ERRCODE
}


#/**
#         ogExtendFs int_ndisk int_npartition
#@brief   Extiende un sistema de archivos al tamaño de su partición.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@return  (nada)
#@exception OG_ERR_FORMAT   Formato incorrecto.
#@exception OG_ERR_NOTFOUND Disco o particion no corresponden con un dispositivo.
#@exception OG_ERR_PARTITION Partición desconocida o no accesible.
#@note    Requisitos: *resize*
#@version 0.1 -  Integracion para Opengnsys  -  EAC:   EnlargeFileSystem() en ATA.lib
#@author  Antonio J. Doblas Viso. Universidad de Malaga
#@date    2008-10-27
#@version 0.9 - Primera adaptacion para OpenGNSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-09-23
#*/
function ogExtendFs ()
{
# Variables locales.
local PART PROG PARAMS

#/// Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
           "$FUNCNAME 1 1"
    return
fi
#/// Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

#/// Obtener partición.
PART="$(ogDiskToDev $1 $2)" || return $?

ogUnmount $1 $2 2>/dev/null
#/// Redimensionar al tamano máximo según el tipo de partición.
TYPE=$(ogGetFsType $1 $2)
case "$TYPE" in
    EXT[234])   PROG="resize2fs"; PARAMS="-f" ;;
    REISERFS)   PROG="resize_reiserfs"; PARAMS="-f" ;;
    NTFS|HNTFS) PROG="ntfsresize"; PARAMS="<<<\"y\" -f" ;;
    *)          ogRaiseError $OG_ERR_PARTITION "$1 $2 $TYPE"
                return $? ;;
esac
#/// Error si el sistema de archivos está montado o bloqueado.
if ogIsMounted $1 $2; then
    ogRaiseError $OG_ERR_PARTITION "$1 $2"       # Indicar nuevo error
    return $?
fi
if ogIsLocked $1 $2; then
    ogRaiseError $OG_ERR_LOCKED "$1 $2"
    return $?
fi
#/// Redimensionar en modo uso exclusivo.
ogLock $1 $2
eval $PROG $PARAMS $PART &>/dev/null
ERRCODE=$?
case $ERRCODE in
    0)    ;;
    127)  ogRaiseError $OG_ERR_NOTEXEC "$PROG" ;;
    *)    ogRaiseError $OG_ERR_PARTITION "$1 $2" ;;
esac
ogUnlock $1 $2
return $ERRCODE
}


#/**
#         ogFormat int_ndisk int_npartition | CACHE
#@see     ogFormatFs ogFormatCache
#*/
function ogFormat ()
{
case "$*" in
    CACHE|cache)  ogFormatCache ;;
    *)            ogFormatFs "$@" ;;
esac
}


#/**
#         ogFormatFs int_ndisk int_npartition [type_fstype] [str_label]
#@brief   Formatea un sistema de ficheros según el tipo de su partición.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@param   type_fstype    mnemónico de sistema de ficheros a formatear
#@param   str_label      etiqueta de volumen (opcional)
#@return  (por determinar)
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@exception OG_ERR_PARTITION Partición no accesible o desconocida.
#@note    Requisitos:	mkfs*
#@warning No formatea particiones montadas ni bloqueadas.
#@todo    Definir salidas.
#@version 0.9 - Primera versión para OpenGNSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-10-08
#*/ ##
function ogFormatFs ()
{
# Variables locales
local PART ID TYPE LABEL PROG PARAMS ERRCODE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition [str_label]" \
           "$FUNCNAME 1 1" \
           "$FUNCNAME 1 1 EXT4" \
           "$FUNCNAME 1 1 \"DATA\"" \
           "$FUNCNAME 1 1 EXT4 \"DATA\""
    return
fi
# Error si no se reciben entre 2 y 4 parámetros.
[ $# -ge 2 -a $# -le 4 ] || ogRaiseError $OG_ERR_FORMAT || return $?
# Obtener dispositivo y tipo de sisitema de archivos.
PART="$(ogDiskToDev $1 $2)" || return $?
TYPE="$(ogGetFsType $1 $2)" || return $?

# Elegir tipo de formato segun el tipo de particion.
case "$3" in
    EXT2)      ID=83; PROG="mkfs.ext2";;
    EXT3)      ID=83; PROG="mkfs.ext3";;
    EXT4)      ID=83; PROG="mkfs.ext4";;
    REISERFS)  ID=83; PROG="mkfs.reiserfs"; PARAMS="-f" ;;
    REISER4)   ID=83; PROG="mkfs.reiser4";;
    XFS)       ID=83; PROG="mkfs.xfs"; PARAMS="-f" ;;
    JFS)       ID=83; PROG="mkfs.jfs"; PARAMS="<<<\"y\"";;
    NTFS)      ID=7;  PROG="mkntfs"; PARAMS="-f" ;;
    HNTFS)     ID=17; PROG="mkntfs"; PARAMS="-f" ;;
    FAT32)     ID=b;  PROG="mkdosfs"; PARAMS="-F 32" ;;
    HFAT32)    ID=1b; PROG="mkdosfs"; PARAMS="-F 32" ;;
    FAT16)     ID=6;  PROG="mkdosfs"; PARAMS="-F 16" ;;
    HFAT16)    ID=16; PROG="mkdosfs"; PARAMS="-F 16" ;;
    FAT12)     ID=1;  PROG="mkdosfs"; PARAMS="-F 12" ;;
    HFAT12)    ID=11; PROG="mkdosfs"; PARAMS="-F 12" ;;
    *)         LABEL="$3" ;;
esac
# Si no se indica explícitamente, detectar el tipo de sistema de archivos.
if [ -z "$PROG" ]; then
    case "$TYPE" in
        EXT2)         PROG="mkfs.ext2";;
        EXT3)         PROG="mkfs.ext3";;
        EXT4)         PROG="mkfs.ext4";;
        REISERFS)     PROG="mkfs.reiserfs"; PARAMS="-f" ;;
        REISER4)      PROG="mkfs.reiser4";;
        XFS)          PROG="mkfs.xfs"; PARAMS="-f" ;;
        JFS)          PROG="mkfs.jfs"; PARAMS="<<<\"y\"";;
        NTFS|HNTFS)   PROG="mkntfs"; PARAMS="-f" ;;
        FAT32|HFAT32) PROG="mkdosfs"; PARAMS="-F 32" ;;
        FAT16|HFAT16) PROG="mkdosfs"; PARAMS="-F 16" ;;
        FAT12|HFAT12) PROG="mkdosfs"; PARAMS="-F 12" ;;
        *)            ogRaiseError $OG_ERR_PARTITION "$1 $2 $TYPE"
                      return $? ;;
    esac
else
    [ $TYPE == "$3" -o $ID == "$(ogGetPartitionId $1 $2)" ] || ogRaiseError $OG_ERR_PARTITION "$3 != $TYPE" || return $?
fi
# Comprobar consistencia entre id. de partición y tipo de sistema de archivos.
[ -n "$PROG" ] || ogRaiseError $OG_ERR_PARTITION "$3 != $TYPE" || return $?

# Etiquetas de particion.
if [ -z "$LABEL" ]; then
    [ "$4" != "CACHE" ] || ogRaiseError $OG_ERR_FORMAT "$MSG_RESERVEDVALUE: CACHE" || return $?
    [ -n "$4" ] && PARAMS="$PARAMS -L $4"
else
    PARAMS="$PARAMS -L $LABEL"
fi

# Error si la particion esta montada o está bloqueada.
if ogIsMounted $1 $2; then
    ogRaiseError $OG_ERR_PARTITION "$1 $2"       # Indicar nuevo error
    return $?
fi
if ogIsLocked $1 $2; then
    ogRaiseError $OG_ERR_LOCKED "$1 $2"
    return $?
fi
# Formatear en modo uso exclusivo.
ogLock $1 $2
eval $PROG $PARAMS $PART 2>/dev/null
ERRCODE=$?
case $ERRCODE in
    0)    ;;
    127)  ogRaiseError $OG_ERR_NOTEXEC "$PROG" ;;
    *)    ogRaiseError $OG_ERR_PARTITION "$1 $2" ;;
esac
ogUnlock $1 $2
return $ERRCODE
}


#/**
#         ogGetFsType int_ndisk int_npartition
#@brief   Devuelve el mnemonico con el tipo de sistema de archivos.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@return  Mnemonico
#@note 	  Mnemonico: { EXT2, EXT3, EXT4, REISERFS, XFS, JFS, LINUX-SWAP, LINUX-LVM, LINUX-RAID, SOLARIS, FAT16, HFAT16, FAT32, HFAT32, NTFS, HNTFS, WIN-DYNAMIC, CACHE, EMPTY, EXTENDED, UNKNOWN }
#@exception OG_ERR_FORMAT   Formato incorrecto.
#@exception OG_ERR_NOTFOUND Disco o particion no corresponden con un dispositivo.
#@version 0.1 -  Integracion para Opengnsys  -  EAC:   TypeFS() en ATA.lib
#@author  Antonio J. Doblas Viso. Universidad de Malaga
#@date    2008-10-27
#@version 0.9 - Primera adaptacion para OpenGNSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-07-21
#*/ ##
function ogGetFsType () {

# Variables locales.
local ID TYPE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
           "$FUNCNAME 1 1  =>  NTFS"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Detectar id. de tipo de partición y codificar al mnemonico.
DISK=$(ogDiskToDev "$1") || return $?
ID=$(ogGetPartitionId "$1" "$2") || return $?
case "$ID" in
     0) 	TYPE="EMPTY" ;;
     1) 	TYPE="FAT12" ;;
     5|f) 	TYPE="EXTENDED" ;;
     [6e])	TYPE="FAT16" ;;
     7) 	TYPE="NTFS" ;;          # Nota: también puede ser EXFAT
     [bc])	TYPE="FAT32" ;;
     11) 	TYPE="HFAT12" ;;
     12) 	TYPE="COMPAQDIAG" ;;
     1[6e])	TYPE="HFAT16" ;;
     17)	TYPE="HNTFS" ;;
     1[bc])	TYPE="HFAT32" ;;
     42)	TYPE="WIN-DYNAMIC" ;;
     82)	TYPE="LINUX-SWAP" ;;
     83)	TYPE="$(parted -sm $DISK print 2>/dev/null | \
                            awk -F: -v fs=$2 '{if ($1==fs) {print toupper($5)}}')"
                # Si el tipo no es válido para partición Linux, Ext3 por defecto.
                case "$TYPE" in
                     EXT[234]|REISERFS|REISER4|BTRFS|JFS|XFS)
                         ;;
                     *)  TYPE="EXT3" ;;
                esac
                ;;
     8e)	TYPE="LINUX-LVM" ;;
     a7)	TYPE="CACHE" ;;         # (compatibilidad con Brutalix)
     af)	TYPE="HFS" ;;
     bf)	TYPE="SOLARIS" ;;
     ca)	TYPE="CACHE" ;;
     fd)	TYPE="LINUX-RAID" ;;
     *) 	TYPE="UNKNOWN" ;;
esac
echo $TYPE
}


#/**
#         ogGetMountPoint int_ndisk int_npartition
#@brief   Devuelve el punto de montaje de un sistema de archivos.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@return  Punto de montaje
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@note    Requisitos: \c mount* \c awk
#@version 0.9 - Primera versión para OpenGNSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-10-15
#*/ ##
function ogGetMountPoint ()
{
# Variables locales
local PART
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
           "$FUNCNAME 1 1  =>  /mnt/sda1"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?
# Obtener partición.
PART="$(ogDiskToDev $1 $2)" || return $?

mount | awk -v P=$PART '{if ($1==P) {print $3}}'
}


#/**
#         ogIsFormated int_ndisk int_npartition
#@brief   Comprueba si un sistema de archivos está formateado.
#@param   int_ndisk      nº de orden del disco o volumen.
#@param   int_npartition nº de orden del sistema de archivos.
#@return  int_code       Código de salida
#@version 0.91 - Adaptación inicial para comprobar que existe caché.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2010-03-18
#*/ ##
function ogIsFormated ()
{
# Variables locales
local DISK
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
           "if $FUNCNAME 1 1; then ... ; fi"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

DISK=$(ogDiskToDev "$1")
test -n "$(parted -sm $DISK print 2>/dev/null | \
                      awk -F: -v fs=$2 '{if ($1==fs) print $5}')"
}


#/**
#         ogIsMounted int_ndisk int_npartition
#@brief   Comprueba si un sistema de archivos está montado.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@return  Código de salida: 0 - sin montar, 1 - montado.
#@version 0.9 - Primera versión para OpenGNSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-10-15
#*/ ##
function ogIsMounted ()
{
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
           "if $FUNCNAME 1 1; then ... ; fi"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

test -n "$(ogGetMountPoint $1 $2)"
}


#/**
#         ogIsLocked int_ndisk int_npartition
#@brief   Comprueba si una partición está bloqueada por una operación de uso exclusivo.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@return  Código de salida: 0 - sin bloquear, 1 - bloqueada.
#@note    El fichero de bloqueo se localiza en \c /var/lock/part, siendo \c part el dispositivo de la partición, sustituyendo el carácter "/" por "-".
#@version 0.9 - Primera versión para OpenGNSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-09-03
#*/ ##
function ogIsLocked ()
{
# Variables locales
local PART LOCKFILE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
           "if $FUNCNAME 1 1; then ... ; fi"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Obtener partición.
PART="$(ogDiskToDev $1 $2)" || return $?

# Comprobar existencia del fichero de bloqueo.
LOCKFILE="/var/lock/lock${PART//\//-}"
test -f $LOCKFILE
}


#/**
#         ogLock int_ndisk int_npartition
#@see     ogLockPartition
#*/
function ogLock ()
{
ogLockPartition "$@"
}

#/**
#         ogLockPartition int_ndisk int_npartition
#@brief   Genera un fichero de bloqueo para una partición en uso exlusivo.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@return  (nada)
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@note    El fichero de bloqueo se localiza en \c /var/lock/part, siendo \c part el dispositivo de la partición, sustituyendo el carácter "/" por "-".
#@version 0.9 - Primera versión para OpenGNSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-09-03
#*/ ##
function ogLockPartition ()
{
# Variables locales
local PART LOCKFILE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
           "$FUNCNAME 1 1"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Obtener partición.
PART="$(ogDiskToDev $1 $2)" || return $?

# Crear archivo de bloqueo exclusivo.
LOCKFILE="/var/lock/lock${PART//\//-}"
touch $LOCKFILE
}


#/**
#         ogMount int_ndisk int_npartition
#@see     ogMountFs ogMountCache ogMountCdrom
#*/ ##
function ogMount ()
{
case "$*" in
    CACHE|cache)
        ogMountCache ;;
    CDROM|cdrom)
        ogMountCdrom ;;
    *)  ogMountFs "$@" ;;
esac
}


#/**
#         ogMountFs int_ndisk int_npartition
#@brief   Monta un sistema de archivos.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@return  Punto de montaje
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@exception OG_ERR_PARTITION Tipo de particion desconocido o no se puede montar.
#@version 0.1 -  Integracion para Opengnsys  -  EAC:   MountPartition() en FileSystem.lib
#@author  Antonio J. Doblas Viso. Universidad de Malaga
#@date    2008-10-27
#@version 0.9 - Primera version para OpenGNSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-09-28
#*/ ##
function ogMountFs ()
{
# Variables locales
local PART TYPE MNTDIR MOUNT PARAMS

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
           "$FUNCNAME 1 1  =>  /mnt/sda1"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Obtener partición.
PART="$(ogDiskToDev $1 $2)" || return $?

# Comprobar si el sistema de archivos ya está montada.
MNTDIR="$(ogGetMountPoint $1 $2)"
# Si no, montarla en un directorio de sistema
if [ -z "$MNTDIR" ]; then
    # Error si la particion esta bloqueada.
    if ogIsLocked $1 $2; then
        ogRaiseError $OG_ERR_LOCKED "$MSG_PARTITION, $1 $2"
        return $?
    fi
    # Crear punto de montaje o enlace símbolico para Caché local.
    MNTDIR=${PART/dev/mnt}
    TYPE="$(ogGetFsType $1 $2)" || return $?
    if [ "$TYPE" == "CACHE" -a -n "$OGCAC" ]; then
        ln -fs $OGCAC $MNTDIR
    else
        mkdir -p $MNTDIR
    fi
    # Montar según el tipo de sitema de archivos.
    case "$TYPE" in
        CACHE)      MOUNT=mount ;;
        EXT[234])   MOUNT=mount ;;
        REISERFS)   insmod /lib/modules/$(uname -r)/kernel/fs/reiserfs/reiserfs.ko 2>/dev/null
                    MOUNT=mount ;;
        JFS)        insmod /lib/modules/$(uname -r)/kernel/fs/jfs/jfs.ko 2>/dev/null
                    MOUNT=mount ;;
        XFS)        insmod /lib/modules/$(uname -r)/kernel/fs/xfs/xfs.ko 2>/dev/null
                    MOUNT=mount ;;
        NTFS|HNTFS) MOUNT=ntfs-3g ;;
        FAT16|FAT32|HFAT16|HFAT32)
                    MOUNT=mount; PARAMS="-t vfat" ;;
        *)  #/// Error, si la partición no es montable.
            rmdir $MNTDIR
            ogRaiseError $OG_ERR_PARTITION "$1, $2, $TYPE"
            return $OG_ERR_PARTITION
            ;;
    esac
    $MOUNT $PARAMS $PART $MNTDIR 2>/dev/null || \
               $MOUNT $PARAMS $PART $MNTDIR -o force,remove_hiberfile 2>/dev/null || \
               ogRaiseError $OG_ERR_PARTITION "$1, $2, $TYPE" || return $?
    # linea temporal durante desarrollo para poder usar el cliente completo nfs y testeas nuevas herramientas.
    if grep -q nfsroot /proc/cmdline; then
        echo "$PART $MNTDIR" >> /etc/mtab
    fi
    # fin linea temporal.
fi
echo $MNTDIR
}


#####  PRUEBAS
# Montar CDROM
function ogMountCdrom ()
{
local DEV MNTDIR
DEV="/dev/cdrom"            # Por defecto
MNTDIR=$(mount | awk -v D=$DEV '{if ($1==D) {print $3}}')
if [ -z "$MNTDIR" ]; then
    MNTDIR=${DEV/dev/mnt}
    mkdir -p $MNTDIR
    mount -t iso9660 $DEV $MNTDIR || ogRaiseError $OG_ERR_PARTITION "cdrom" || return $?
fi
echo $MNTDIR
}


#/**
#         ogReduceFs int_ndisk int_npartition
#@brief   Reduce el tamaño del sistema de archivos, sin tener en cuenta el espacio libre.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@return  int_tamañoKB - tamaño en KB
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@exception OG_ERR_PARTITION Partición desconocida o no accesible.
#@warning En Windows, se borran los ficheros pagefile.sys e hiberfile.sys
#@warning El sistema de archivos se amplía al mínimo + 10%.
#@note    Requisitos:	*resize*
#@version 0.1 -  Integracion para Opengnsys  -  EAC:   ReduceFileSystem() en ATA.lib
#@author  Antonio J. Doblas Viso. Universidad de Malaga
#@date    2008-10-27
#@version 0.9 - Primera version para OpenGNSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-09-23
#@version 0.9.2 - Añadir un 10% al tamaño mínimo requerido.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2010-09-27
#@version 1.0 -  Deteccion automatica del tamaño minimo adecuado
#@author  Antonio J. Doblas Viso. Universidad de Malaga
#@date    2011-02-24
#*/ ##
function ogReduceFs ()
{
# Variables locales
local PART BLKS SIZE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
           "$FUNCNAME 1 1"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Obtener partición.
PART="$(ogDiskToDev $1 $2)" || return $?

# Redimensionar según el tipo de particion.
case "$(ogGetFsType $1 $2)" in
    EXT[234])
        ogUnmount $1 $2 2>/dev/null
        # Ext2/3/4: Tamaño de los bloques del sistema de archivos
        BLKS=$(tune2fs -l $PART | awk '/Block size/ {print int($3/512)}')
        # Traduce el num. en sectores de 512B a tamano en MB.
        #SIZE=$(resize2fs -P $PART 2>/dev/null | \
		#       awk -v B=$BLKS '/minimum size/ {print int($7*1.1*B/2048)}')
        #resize2fs -fp $PART "${SIZE}M" &>/dev/null || ogRaiseError $OG_ERR_PARTITION "$1,$2" || return $?
        resize2fs -fpM $PART  &>/dev/null || ogRaiseError $OG_ERR_PARTITION "$1,$2" || return $?
	    ;;
#    REISERFS)		# Usar "resize_reiserfs"
#	    ;;
    NTFS|HNTFS)
        ogDeleteFile $1 $2 pagefile.sys
        ogDeleteFile $1 $2 hiberfile.sys
        ogUnmount $1 $2 2>/dev/null
        ## NTFS: Obtiene tamaño mínimo en MB.
        #SIZE=$(ntfsresize -fi $PART | awk '/resize at/ {print int($8*1.1)}')
        #ntfsresize -fns "${SIZE}M" $PART >/dev/null || ogRaiseError $OG_ERR_PARTITION "$1,$2" || return $?
        #ntfsresize -fs "${SIZE}M" $PART <<<"y" >/dev/null || ogRaiseError $OG_ERR_PARTITION "$1,$2" || return $?
		SIZE=$(ogReduceFsCheck $1 $2)
	    [ "$SIZE" == 0 ] && return 1	
        ntfsresize -fs "${SIZE}M" $PART <<<"y"  || ogRaiseError $OG_ERR_PARTITION "error reduciendo $1,$2" || return $?
	    ;;
    *)  ogRaiseError $OG_ERR_PARTITION "$1,$2"
	    return $? ;;
esac
#/// Mostrar nuevo tamaño en KB.
#echo $[SIZE*1024]
ogGetFsSize $1 $2
}


function ogReduceFsCheck ()
{
#IMPORTANTE: retorna el valor en MB que podrá reducir el FS de una particion ntfs
#valor devuelto 0, y codigo error 1. No se puede reducir, probar a reiniciar windows y chkdsk


local  PART RC MODE SIZE SIZEDATA 
[ $# == 2 ] && MODE=STAGE1
[ $# == 3 ] && MODE=STAGE2
[ -z $MODE ] && return

PART="$(ogDiskToDev $1 $2)" || return $?
ogUnmount $1 $2 &>/dev/null


case $MODE in
	STAGE1)
	#	echo "primera etapa $*"
		ntfsresize -fi $PART &>/dev/null
		RC=`echo $?`
	#	echo "RC es" $RC
		if [ "$RC" -eq "1" ]
		then 
			echo "0" 
     			return 1	
		fi  
		SIZEDATA=$(ntfsresize -fi $PART | awk '/resize at/ {print $8+1000}')
	#	echo "salida" $?
	#	echo $SIZEDATA
		ogReduceFsCheck $1 $2 $SIZEDATA 
		return 0
       ;;
	STAGE2)
	#	echo "segunda etapa $*"
		SIZEDATA=$3
        	ntfsresize -fns "${SIZEDATA}M" $PART &>/tmp/ntfsresize.txt
		RC=$?
		if [ "$RC" == "0" ]
		then  
			SIZE=$SIZEDATA	
			echo $SIZE	
		else
			SIZEEXTRA=$(cat /tmp/ntfsresize.txt | awk '/Needed relocations :/ {print $0}' | awk -F"(" '{print $2}' | awk '{print $1+500}')
			SIZE=$(expr $SIZEDATA + $SIZEEXTRA)
			ogReduceFsCheck $1 $2 $SIZE 
			return 0 
		fi
	;;
	*)
	return
	;;
esac
}



#/**
#         ogUnlock int_ndisk int_npartition
#@see     ogUnlockPartition
#*/
function ogUnlock ()
{
ogUnlockPartition "$@"
}

#/**
#         ogUnlockPartition int_ndisk int_npartition
#@brief   Elimina el fichero de bloqueo para una particion.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@return  (nada)
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@note    El fichero de bloqueo se localiza en \c /var/lock/part, siendo \c part el dispositivo de la partición, sustituyendo el carácter "/" por "-".
#@version 0.9 - Primera versión para OpenGNSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-09-03
#*/ ##
function ogUnlockPartition ()
{
# Variables locales
local PART LOCKFILE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
           "$FUNCNAME 1 1"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Obtener partición.
PART="$(ogDiskToDev $1 $2)" || return $?

# Borrar archivo de bloqueo exclusivo.
LOCKFILE="/var/lock/lock${PART//\//-}"
rm -f $LOCKFILE
}


#/**
#         ogUnmount int_ndisk int_npartition
#@see     ogUnmountFs
#*/
function ogUnmount ()
{
ogUnmountFs "$@"
}

#/**
#         ogUnmountFs int_ndisk int_npartition
#@brief   Desmonta un sistema de archivos.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@return  Nada
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@warning La partición no está previamente montada o no se puede desmontar.
#@version 0.1 -  Integracion para Opengnsys  -  EAC:  UmountPartition() en FileSystem.lib
#@author  Antonio J. Doblas Viso. Universidad de Malaga
#@date    2008-10-27
#@version 0.9 - Primera version para OpenGNSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-09-28
#*/ ##
function ogUnmountFs ()
{
# Variables locales
local PART MNTDIR

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" "$FUNCNAME 1 1"
    return
fi
# Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Obtener partición y punto de montaje.
PART="$(ogDiskToDev $1 $2)" || return $?
MNTDIR="$(ogGetMountPoint $1 $2)"

# Si está montada, desmontarla.
if [ -n "$MNTDIR" ]; then
    # Error si la particion está bloqueada.
    if ogIsLocked $1 $2; then
        ogRaiseError $OG_ERR_LOCKED "$MSG_PARTITION $1, $2"
        return $?
    fi
    # Desmontar y borrar punto de montaje.
    umount $PART 2>/dev/null || ogEcho warning "$FUNCNAME: $MSG_DONTUNMOUNT: \"$1, $2\""
    rmdir $MNTDIR 2>/dev/null || rm -f $MNTDIR 2>/dev/null
    # linea temporal durante desarrollo para testear nuevas herramientas con el cliente completo nfs
    if grep -q nfsroot /proc/cmdline; then
        grep -v $PART /etc/mtab > /var/tmp/mtab.temporal && cp /var/tmp/mtab.temporal /var/tmp/mtab && rm /var/tmp/mtab.temporal
    fi
    # fin linea temporal.
else
    ogEcho warning "$MSG_DONTMOUNT: \"$1,$2\""
fi
}


#/**
#         ogUnmountAll int_ndisk
#@brief   Desmonta todos los sistema de archivos de un disco, excepto el caché local.
#@param   int_ndisk      nº de orden del disco
#@return  Nada
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@warning No se desmonta la partición marcada como caché local.
#@version 0.9 - Versión para OpenGNSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009/10/07
#*/ ##
function ogUnmountAll ()
{
# Variables locales
local DISK PART
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk" "FUNCNAME 1"
    return
fi
# Error si no se recibe 1 parámetro.
[ $# == 1 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Obtener partición y punto de montaje.
DISK="$(ogDiskToDev $1)" || return $?
for ((PART=1; PART<=$(ogGetPartitionsNumber $1); PART++)); do
    case "$(ogGetFsType $1 $PART)" in
        CACHE|LINUX-SWAP)
           ;;
        *)
           ogUnmount $1 $PART ;;
    esac
done
}

#/**  @function ogGetFsSize: @brief Muestra el tamanio del sistema de archivos indicado, permite definir la unidad de medida, por defecto GB
#@param  $1 int_diskEAC
#@param $2 int_PartitionEAC
#@param $3 str_UnidadMediada		parametro opcional, admite [ kB MB GB -default GB]
#@return  cadena con int_TotalSize:int_DataSize:int_DataFree
#@warning  Salidas de errores no determinada
#@warning
#@attention
#@version 0.1 -  Integracion para Opengnsys  -  EAC:  SizeFileSystem() en FileSystem.lib
#@author  Antonio J. Doblas Viso. Universidad de Malaga
#@date    2008-10-27
#*/
function ogGetFsSize () {
if [ $# = 0 ]
then
	echo "sintaxis: ogGetFsSize int_disco int_partition str_SizeOutput [ kB MB GB -default GB]-]" red
	echo "devuelve int_size : int_data : int_free" red
return
fi
if [ $# -ge 2 ]
then
	particion=`ogMount $1 $2 ` #1>/dev/null 2>&1
	if [ -z $3 ]
		then
			unit=kB  # s B kB MB GB TB %
		else
			unit=$3
	fi
	case $unit in
		kB)
			factor="1.024";
		#	valor=`df | grep  $particion | awk -F" " '{size=$2*1.024; used=$3*1.024; free=$4*1.024; printf "%d:%d:%d", size,used,free}'`
			valor=`df | grep  $particion | awk -F" " '{size=$2*1.024; used=$3*1.024; free=$4*1.024; printf "%d", size}'`
		;;
		MB)
			factor="1.024/1000";
			valor=`df | grep  $particion | awk -F" " '{size=$2*1.024/1000; used=$3*1.024/1000; free=$4*1.024/1000; printf "%d:%d:%d", size,used,free}'`
		;;
		GB)
			factor="1.024/1000000";
			valor=`df | grep $particion | awk -F" " '{size=$2*1.024/1000000; used=$3*1.024/1000000; free=$4*1.024/1000000; printf "%f:%f:%f", size,used,free}'`
		;;
	esac
	#echo $valor
	#NumberRound $valor
	#valor=`NumberRound $valor`;
	ogUnmount $1 $2 1>/dev/null 2>&1
	echo $valor

fi
}

function ogGetFreeSize () {
if [ $# = 0 ]
then
	echo "sintaxis: ogGetFreeSize int_disco int_partition str_SizeOutput [ kB MB GB -default GB]-]" red
	echo "devuelve int_size : int_data : int_free" red
return
fi
if [ $# -ge 2 ]
then
	particion=`ogMount $1 $2 ` #1>/dev/null 2>&1
	if [ -z $3 ]
		then
			unit=kB  # s B kB MB GB TB %
		else
			unit=$3
	fi
	case $unit in
		kB)
			factor="1.024";
			#valor=`df | grep  $particion | awk -F" " '{size=$2*1.024; used=$3*1.024; free=$4*1.024; printf "%d:%d:%d", size,used,free}'`
			valor=`df | grep  $particion | awk -F" " '{size=$2*1.024; used=$3*1.024; free=$4*1.024; printf "%d", free}'`
			;;
		MB)
			factor="1.024/1000";
			valor=`df | grep  $particion | awk -F" " '{size=$2*1.024/1000; used=$3*1.024/1000; free=$4*1.024/1000; printf "%d:%d:%d", size,used,free}'`
		;;
		GB)
			factor="1.024/1000000";
			valor=`df | grep $particion | awk -F" " '{size=$2*1.024/1000000; used=$3*1.024/1000000; free=$4*1.024/1000000; printf "%f:%f:%f", size,used,free}'`
		;;
	esac
	#echo $valor
	#NumberRound $valor
	#valor=`NumberRound $valor`;
	ogUnmount $1 $2 1>/dev/null 2>&1
	echo $valor

fi
}



function ogDeletePartitionsLabels ()
{
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME " \
           "$FUNCNAME "
    return
fi
rm /dev/disk/by-label/* 2>/dev/null   # */ COMENTARIO OBLIGATORIO PARA DOXYGEN
}

function ogDeletePartitionTable ()
{

# Variables locales.
local DISK

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME int_disk"  \
           "$FUNCNAME 1"
    return
fi
# Error si no se reciben 1 parámetros.
[ $# == 1 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Obteniendo Identificador linux de la particion.
DISK=$(ogDiskToDev $1) || return $?

# Elimando las particiones con fdisk
echo -ne "o\nw" | fdisk $DISK
}
