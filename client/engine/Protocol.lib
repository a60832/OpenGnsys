#!/bin/bash
#/**
#@file    Protocol.lib
#@brief   Librería o clase Protocol
#@class   FileTransfer
#@brief   Funciones para transmisión de datos
#@version 0.91
#@warning License: GNU GPLv3+
#*/


#/**
#         ogCheckStringInGroup 
#@brief   Función para determinar si el elemento pertenece a un conjunto
#@param 1 elemento a comprobar
#@param 2 grupo de elementos para comprobar tipo "valor1 valor2 valor3"
#@return  0 si pertenece al grupo
#@return  1 si NO pertenece al grupo
#@exception OG_ERR_FORMAT     formato incorrecto.
#@note    
#@TODO: 
#@version 0.91 - Definición de 
#@author  Antonio Doblas Viso, Universidad de Málaga
#@date    2010/05/09
#*/ ##
#/**
ogCheckStringInGroup ()
{
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME str_elemento    str_grupo" \
		   "$FUNCNAME full-duplex \"full-duplex half-duplex broadcast\" "
    return
fi

# Error si no se recibe 2 parámetro.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?


for i in `echo $2`
do
  if [ "$1" == "$i" ] 
  then
      return 0
  fi
done

return 1
} 




#/**
#         ogCheckStringInReg
#@brief   Función para determinar si el elemento contiene una "expresión regular"
#@param 1 elemento a comprobar
#@param 2 expresión regular"
#@return  0 si coincide con la expresión
#@return  1 si NO coincide con la expresión
#@exception OG_ERR_FORMAT     formato incorrecto.
#@note    
#@TODO: 
#@version 0.91 - Definición de 
#@author  Antonio Doblas Viso, Universidad de Málaga
#@date    2010/05/09
#*/ ##
#/**


ogCheckStringInReg()
{

local REG

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME str_elemento    str_expresión_regular" \
		   "$FUNCNAME 50M \"^[0-9]{1,2}\M$\" "
    return
fi

# Error si no se recibe 2 parámetro.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

REG=$2
[[ $1 =~ $REG ]] && return 0 || return 1
}



#/**
#         ogCheckIpAddress
#@brief   Función para determinar si una cadena es una dirección ipv4 válida
#@param 1 string de la ip a comprobar
#@return  0 si es una dirección válida
#@return  1 si NO es una dirección válida
#@exception OG_ERR_FORMAT     formato incorrecto.
#@note    
#@TODO: 
#@version 0.91 - Definición de 
#@author  Antonio Doblas Viso, Universidad de Málaga
#@date    2010/05/09
#*/ ##
#/**
ogCheckIpAddress()
{
local REG IP arrIP

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME str_IpAddressToCheck" \
		   "$FUNCNAME 192.18.35.3"
    return
fi

# Error si no se recibe 1 parámetro.
[ $# == 1 ] || ogRaiseError $OG_ERR_FORMAT || return $?
   
    
IP=$1
REG="^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$"
if [[ "$IP" =~ $REG ]]
then    	
	OIFS=$IFS; 
    IFS='.' ; 
    arrIP=($IP)  
    IFS=$OIFS           
    if [[ ${arrIP[0]} -le 255 && ${arrIP[1]} -le 255 && ${arrIP[2]} -le 255 && ${arrIP[3]} -le 255 ]]
    then
    	return 0
    fi
fi
return 1
}



#/**
#         ogGenerateSintaxMcast
#@brief   Función para generar la instrucción de ejucción la transferencia de datos multicast
#@param 1 Tipo de operación [ SENDPARTITION RECEIVERPARTITION SENDFILE RECEIVERFILE ] 
#@param 2 Sesión Mulicast 
#@param 3 Dispositivo (opción PARTITION) o fichero(opción FILE) que será enviado.
#@param 4 Tools de clonación (opcion PARTITION)
#@param 5 Tools de compresion (opcion PARTITION) 
#@return  instrucción para ser ejecutada.
#@exception OG_ERR_FORMAT     formato incorrecto.
#@note    Requisitos: upd-cast 2009
#@TODO: localvar  check versionudp
#@version 0.91 - Definición de FileTransfer
#@author  Antonio Doblas Viso, Universidad de Málaga
#@date    2010/05/09
#*/ ##
#/**
#         


function ogGenerateSintaxMcast ()
{

local ISUDPCAST PARM SESSION SESSIONPARM MODE PORTBASE PERROR
local METHOD ADDRESS BITRATE NCLIENTS MAXTIME CERROR 
local TOOL LEVEL DEVICE MBUFFER SINTAXSERVER SINTAXCLIENT

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" -o "$2" == "help" ]; then
    ogHelp "$FUNCNAME SENDPARTITION      str_sessionSERVER     str_device str_tools str_level" \
		   "$FUNCNAME RECEIVERPARTITION  str_sessionCLIENT     str_device str_tools str_level "\
		   "$FUNCNAME SENDFILE           str_sessionSERVER     str_file "\
		   "$FUNCNAME RECEIVERFILE       str_sessionCLIENT     str_file "
    return
fi
PERROR=0

#si no tenemos updcast o su version superior 2009 udpcast error.
ISUDPCAST=$(udp-receiver --help 2>&1)
echo $ISUDPCAST | grep start-timeout > /dev/null || ogRaiseError $OG_ERR_FORMAT "upd-cast no existe o version antigua -requerida 2009-"|| return $?


# Error si no se reciben $PARM parámetros.
echo "$1" | grep "PARTITION" > /dev/null && PARM=5 || PARM=3
[ "$#" -eq "$PARM" ] || ogRaiseError $OG_ERR_FORMAT "sin parametros"|| return $?


# 1er param check
ogCheckStringInGroup "$1" "SENDPARTITION sendpartition RECEIVERPARTITION receiverpartition SENDFILE sendfile RECEIVERFILE receiverfile" || ogRaiseError $OG_ERR_FORMAT "1st param: $1" || PERROR=1 #return $?

# 2º param check
echo "$1" | grep "SEND" > /dev/null && MODE=server || MODE=client

#TODO: diferenciamos los paramatros especificos de la sessión multicast  
#SI: controlamos todos los parametros de la sessión multicast.
[ $MODE == "client" ] && SESSIONPARM=1 || SESSIONPARM=6
OIFS=$IFS; IFS=':' ; SESSION=($2); IFS=$OIFS


[[ ${#SESSION[*]} == $SESSIONPARM ]]  || ogRaiseError $OG_ERR_FORMAT "parametros session multicast no completa" || PERROR=2# return $?


#controlamos el PORTBASE de la sesion. Comun.-
PORTBASE=${SESSION[0]}
ogCheckStringInGroup ${SESSION[0]} "9000 9002 9004 9006 9008 9010" || ogRaiseError $OG_ERR_FORMAT "McastSession portbase ${SESSION[0]}" || PERROR=3 #return $?
if [ $MODE == "server" ]
then    
	ogCheckStringInGroup ${SESSION[1]} "full-duplex FULL-DUPLEX half-duplex HALF-DUPLEX broadcast BROADCAST" || ogRaiseError $OG_ERR_FORMAT "McastSession method ${SESSION[1]}" || PERROR=4 #return $?
	METHOD=${SESSION[1]}
	ogCheckIpAddress ${SESSION[2]}  || ogRaiseError $OG_ERR_FORMAT "McastSession address ${SESSION[2]}" || PERROR=5 #return $?
	ADDRESS=${SESSION[2]}
	ogCheckStringInReg ${SESSION[3]} "^[0-9]{1,2}\M$" || ogRaiseError $OG_ERR_FORMAT "McastSession bitrate ${SESSION[3]}" || PERROR=6 # return $?
	BITRATE=${SESSION[3]}
	ogCheckStringInReg ${SESSION[4]} "^[0-9]{1,10}$" || ogRaiseError $OG_ERR_FORMAT "McastSession nclients ${SESSION[4]}" || PERROR=7 # return $?
	NCLIENTS=${SESSION[4]}
	ogCheckStringInReg ${SESSION[5]} "^[0-9]{1,10}$" || ogRaiseError $OG_ERR_FORMAT "McastSession maxtime ${SESSION[5]}" || PERROR=8 # return $?
	MAXTIME=${SESSION[5]}
fi

#3er param check - que puede ser un dispositvo o un fichero.
#ogGetPath "$3" > /dev/null || ogRaiseError $OG_ERR_NOTFOUND " device or file $3" || PERROR=9 #return $?  
DEVICE=$3

#4 y 5 param check .  solo si es sobre particiones.
if [ "$PARM" == "5" ]
then
	# 4 param check 
	ogCheckStringInGroup "$4" "partclone partimage ntfsclone" || ogRaiseError $OG_ERR_NOTFOUND " herramienta $4 no soportada" || PERROR=10 #return $?
	TOOL=$4
	ogCheckStringInGroup "$5" "lzop gzip 0 1" || ogRaiseError $OG_ERR_NOTFOUND " compresor $5 no valido" || PERROR=11 #return $?
	LEVEL=$5
fi


[ "$PERROR" -gt "0" ] && return 1

# Valores estandar no configurables.
CERROR="8x8/128"

# opción del usuo de tuberia intermedia en memoria mbuffer.
which mbuffer > /dev/null && MBUFFER=" --pipe 'mbuffer -m 20M' " 

# Generamos la instrucción base de multicast -Envio,Recepcion-
SINTAXSERVER="udp-sender $MBUFFER --portbase $PORTBASE --$METHOD --mcast-data-address $ADDRESS --fec $CERROR --max-bitrate $BITRATE --ttl 1 --min-clients $NCLIENTS --max-wait $MAXTIME "
SINTAXCLIENT="udp-receiver $MBUFFER --portbase $PORTBASE "


case "$1" in
SENDPARTITION)
		PROG1=`ogCreateImageSintax $DEVICE " " $TOOL $LEVEL | awk -F"|" '{print $1 $3}' | tr -d ">"`
		echo "$PROG1 | $SINTAXSERVER"
	;;
    RECEIVERPARTITION)
		COMPRESSOR=`ogRestoreImageSintax " " $DEVICE $TOOL $LEVEL | awk -F\| '{print $1}'`
		TOOLS=`ogRestoreImageSintax " " $DEVICE $TOOL $LEVEL | awk -F\| '{print $NF}'`
		echo "$SINTAXCLIENT | $COMPRESSOR | $TOOLS "
	;;
	SENDFILE)
		echo "$SINTAXSERVER --file $3"
    ;;
    RECEIVERFILE)
		echo "$SINTAXCLIENT --file $3"
    ;;
   *)
   ;;
esac
}



#/**
#         ogMcastSendFile [ str_repo | int_ndisk int_npart ] /Relative_path_file  sessionMulticast
#@brief   Envía un fichero por multicast   ORIGEN(fichero) DESTINO(sessionmulticast)
#@param (2 parámetros)  $1 path_aboluto_fichero  $2 sesionMcast
#@param (3 parámetros)  $1 Contenedor REPO|CACHE $2 path_absoluto_fichero $3 sesionMulticast
#@param (4 parámetros)  $1 disk $2 particion $3 path_absoluto_fichero $4 sesionMulticast
#@return  
#@exception OG_ERR_FORMAT     formato incorrecto.
#@note    Requisitos: 
#@version 0.91 - Definición de Protocol.lib
#@author  Antonio Doblas Viso, Universidad de Málaga
#@date    2010/05/09
#*/ ##
#/**
# 

function ogMcastSendFile ()
{
# Variables locales.
local ARGS SOURCE TARGET COMMAND DEVICE
#ARGS usado para controlar ubicación de la sesion multicast

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME [str_REPOSITORY] [int_ndisk int_npart] /Relative_path_file sesionMcast" \
           "$FUNCNAME  1 1 /aula1/winxp.img sesionMcast" \
           "$FUNCNAME  REPO /aula1/ubuntu.iso sesionMcast" \
           "$FUNCNAME  CACHE /aula1/winxp.img sesionMcast" \
           "$FUNCNAME  /opt/opengnsys/images/aula1/hd500.vmx sesionMcast"
    return
fi

ARGS="$@"
case "$1" in
    /*)     # Camino completo.               */ (Comentrio Doxygen)
        SOURCE=$(ogGetPath "$1")
        ARG=2
        DEVICE="$1"
		;;
    [1-9]*) # ndisco npartición.
        SOURCE=$(ogGetPath "$1" "$2" "$3")
        ARG=4
        DEVICE="$1 $2 $3"
        ;;
    *)      # Otros: repo, cache, cdrom (no se permiten caminos relativos).
        SOURCE=$(ogGetPath "$1" "$2")
        ARG=3
        DEVICE="$1 $2 "
        ;;
esac


# Error si no se reciben los argumentos ARG necesarios según la opcion.
[ $# == "$ARG" ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Comprobar fichero origen
ogGetPath $SOURCE &> /dev/null || ogRaiseError $OG_ERR_NOTFOUND " device or file $DEVICE not found" || return $?  

SESSION=${!ARG}
# llamando a la funcion con param1 session $SESSION y param2 $SOURCE
COMMAND=`ogGenerateSintaxMcast "SENDFILE" "$SESSION" "$SOURCE"`
echo $COMMAND
eval $COMMAND
}



#/**
#         ogMcastReceiverFile  sesion Multicast [ str_repo | int_ndisk int_npart ] /Relative_path_file
#@brief   Recibe un fichero multicast   ORIGEN(sesionmulticast) DESTINO(fichero)
#@param (2 parámetros)  $1 sesionMcastCLIENT $2 path_aboluto_fichero_destino  
#@param (3 parámetros)  $1 sesionMcastCLIENT $2 Contenedor REPO|CACHE $3 path_absoluto_fichero_destino
#@param (4 parámetros)  $1 sesionMcastCLIENT $2 disk $3 particion $4 path_absoluto_fichero_destino
#@return  
#@exception OG_ERR_FORMAT     formato incorrecto.
#@note    Requisitos: 
#@version 0.91 - Definición de Protocol.lib
#@author  Antonio Doblas Viso, Universidad de Málaga
#@date    2010/05/09
#*/ ##
#/**
# 

ogMcastReceiverFile ()
{

# Variables locales.
local ARGS ARG TARGETDIR TARGETFILE


# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME [ str_portMcast] [ [Relative_path_file] | [str_REPOSITORY path_file] |  [int_ndisk int_npart path_file ]  ]" \
           "$FUNCNAME 9000 /PS1_PH1.img" \
           "$FUNCNAME 9000 CACHE /aula1/PS2_PH4.img" \
           "$FUNCNAME 9000 1 1 /isos/linux.iso" 
    return
fi

ARGS="$@"
case "$2" in
    /*)     # Camino completo.          */ (Comentrio Doxygen)
    	TARGETDIR=$(ogGetParentPath "$2")
		ARG=2		
	;;
    [1-9]*) # ndisco npartición.
    	TARGETDIR=$(ogGetParentPath "$2" "$3" "$4")
        ARG=4      
    ;;
    *)      # Otros: repo, cache, cdrom (no se permiten caminos relativos).
    	TARGETDIR=$(ogGetParentPath "$2" "$3")
        ARG=3 
    ;;
esac

# Error si no se reciben los argumentos ARG necesarios según la opcion.
[ $# == "$ARG" ] || ogRaiseError $OG_ERR_FORMAT "Parametros no admitidos"|| return $?

#obtenemos el nombre del fichero a descargar.
TARGETFILE=`basename ${!ARG}`

#generamos la instrucción a ejecutar.  
COMMAND=`ogGenerateSintaxMcast RECEIVERFILE "$1" $TARGETDIR/$TARGETFILE `
echo $COMMAND
eval $COMMAND
}


##########################################
############## funciones torrent
#/**
#         ogTorrentStart  [ str_repo | int_ndisk int_npart ] Relative_path_file.torrent | SessionProtocol
#@brief   Función iniciar P2P - requiere un tracker para todos los modos, y un seeder para los modos peer y leecher y los ficheros .torrent.
#@param   str_pathDirectory  str_Relative_path_file
#@param  int_disk    int_partition   str_Relative_path_file
#@param  str_REPOSITORY(CACHE - LOCAL)  str_Relative_path_file
#@param (2 parámetros)  $1 path_aboluto_fichero_torrent  $2 Parametros_Session_Torrent  
#@param (3 parámetros)  $1 Contenedor CACHE $2 path_absoluto_fichero_Torrent $3 Parametros_Session_Torrent
#@param (4 parámetros)  $1 disk $2 particion $3 path_absoluto_fichero_Torrent 4$ Parametros_Session_Torrent

#@return
#@note
#@todo: 
#@version 0.1 - Integración para OpenGNSys.
#@author        Antonio J. Doblas Viso. Universidad de Málaga
#@date
#@version 0.2 - Chequeo del tamaño de imagen descargado.
#@author        Irina . Univesidad de Sevilla.
#@date
#@version 0.3 - Control de los modos de operación, y estado de descarga.
#@author        Antonio J. Doblas Viso. Univesidad de Málaga.
#@date
#@version 0.4 - Enviadando señal (2) a ctorrent permiendo la comunicación final con tracker
#@author        Antonio J. Doblas Viso. Univesidad de Málaga.
#@date
#*/ ##

#protocoloTORRENT    mode:time
#mode=seeder  -> Dejar el equipo seedeando hasta que transcurra el tiempo indicado o un kill desde consola, 
#mode=peer    -> seedear mientras descarga
#mode=leecher  -> NO seedear mientras descarga
#time tiempo que una vez descargada la imagen queremos dejar al cliente como seeder.

ogTorrentStart ()
{

# Variables locales.
local ARGS ARG TARGETDIR TARGETFILE SESSION ERROR
ERROR=0

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME $FUNCNAME [ str_repo] [ [Relative_path_fileTORRENT] | [str_REPOSITORY path_fileTORRENT] |  [int_ndisk int_npart path_fileTORRENT ]  ] SessionTorrent" \
           "$FUNCNAME CACHE /PS1_PH1.img.torrent seeder:10000" \
           "$FUNCNAME /opt/opengnsys/cache/linux.iso peer:60" \
           "$FUNCNAME 1 1 /linux.iso.torrent leecher:60" 
    return
fi

case "$1" in
    /*)     # Camino completo.          */ (Comentrio Doxygen)
           SOURCE=$(ogGetPath "$1")
           ARG=2
     ;;
    [1-9]*) # ndisco npartición.
           SOURCE=$(ogGetPath "$1" "$2" "$3")
           ARG=4
     ;;
    *) # Otros: Solo cache (no se permiten caminos relativos).
        SOURCE=$(ogGetPath "$1" "$2" 2>/dev/null)
        ARG=3
     ;;
esac

# Error si no se reciben los argumentos ARG necesarios según la opcion.
[ $# == "$ARG" ] || ogRaiseError $OG_ERR_FORMAT "Parametros no admitidos"|| return $?

#controlar source, que no se haga al repo.
if [ $ARG == "3" ]
then
    ogCheckStringInGroup "$1" "CACHE cache" || ogRaiseError $OG_ERR_FORMAT "La descarga torrent solo se hace desde local, copia el torrent a la cache y realiza la operación desde esa ubicación" || return $?
fi
if [ $ARG == "2" ]
then
    if `ogCheckStringInReg "$1" "^/opt/opengnsys/images"` 
    then
    	ogRaiseError $OG_ERR_FORMAT "La descarga torrent solo se hace desde local, copia el torrent a la cache y realiza la operación desde esa ubicación" 
    	return $?
	fi
fi

#controlar el source, para que sea un torrent.
ctorrent -x ${SOURCE} &> /dev/null; [ $? -eq 0 ] ||  ogRaiseError $OG_ERR_NOTFOUND "${ARGS% $*}" || return $?

TARGET=`echo $SOURCE | awk -F.torrent '{print $1}'`
DIRSOURCE=`ogGetParentPath $SOURCE`
cd $DIRSOURCE



SESSION=${!ARG}
OIFS=$IFS; IFS=':' ; SESSION=($SESSION); IFS=$OIFS
[[ ${#SESSION[*]} == 2 ]]  || ogRaiseError $OG_ERR_FORMAT "parametros session Torrent no completa:  modo:tiempo" || ERROR=1# return $?
#controlamos el modo de operación del cliente-
ogCheckStringInGroup ${SESSION[0]} "seeder SEEDER peer PEER leecher LEECHER" || ogRaiseError $OG_ERR_FORMAT "valor modo Torrent no valido ${SESSION[0]}" || ERROR=1 #return $?
MODE=${SESSION[0]}
#contolamos el tiempo para el seeder o una vez descargada la imagen como peer o leecher.
ogCheckStringInReg ${SESSION[1]} "^[0-9]{1,10}$" || ogRaiseError $OG_ERR_FORMAT "valor tiempo no valido ${SESSION[1]}" || ERROR=1 # return $?
TIME=${SESSION[1]}
# si ha habido error en el control de parametros error.
[ "$ERROR" == "1" ] && return 1


#SINTAXSEEDER="echo MODE seeder ctorrent ; (sleep \$TIME && kill -9 \`pidof ctorrent\`) & ; ctorrent \${SOURCE}"

# si No fichero .bf, y Si fichero destino    imagen ya descargada y su chequeo fue comprobado en su descarga inicial.
if [ ! -f ${SOURCE}.bf -a -f ${TARGET} ]
then
  echo "imagen ya descargada"
  case "$MODE" in 
	seeder|SEEDER)
		echo "MODE seeder ctorrent"     #### ${SOURCE} -X 'sleep $TIME; kill -9 \$(pidof ctorrent)' -C 100"
		(sleep $TIME && kill -2 `pidof ctorrent`) &
		ctorrent -f ${SOURCE}		
  esac
  return 0
fi

#Si no existe bf ni fichero destino         descarga inicial.
if [ ! -f ${SOURCE}.bf -a ! -f ${TARGET} ]
then
	OPTION=DOWNLOAD
    echo "descarga inicial" 
fi 

# Si fichero bf           descarga anterior no completada -.
if [ -f ${SOURCE}.bf -a -f ${TARGET} ]
then       
        echo Continuar con Descargar inicial no terminada.
        OPTION=DOWNLOAD
fi

if [ "$OPTION" == "DOWNLOAD" ]
then
	case "$MODE" in
        peer|PEER)
        	echo "Donwloading Torrent as peer"  ### echo "ctorrent -X 'sleep $TIME; kill -9 \$(pidof ctorrent)' -C 100 $SOURCE -s $TARGET -b ${SOURCE}.bf"
            ctorrent -f -X "sleep $TIME; kill -2 \$(pidof ctorrent)" -C 100 ${SOURCE} -s ${TARGET} -b ${SOURCE}.bf
        ;;
        leecher|LEECHER)
           	echo "Donwloading Torrent as leecher" # echo "ctorrent ${SOURCE} -X 'sleep $TIME; kill -9 \$(pidof ctorrent)' -C 100 -U 0"
         	ctorrent ${SOURCE} -X "sleep $TIME; kill -2 \$(pidof ctorrent)" -C 100 -U 0
        ;;
        seeder|SEEDER)
        	echo "MODE seeder ctorrent"     #### ${SOURCE} -X 'sleep $TIME; kill -9 \$(pidof ctorrent)' -C 100"
           	ctorrent -f -X "sleep $TIME; kill -2 \$(pidof ctorrent)" -C 100 ${SOURCE} -s ${TARGET} -b ${SOURCE}.bf
		;;
	esac
fi
if [ "$OPTION" == "DOWNLOAD" ]
then
 	echo "comprobando el fichero descargado. Espere: "
 	#echo " ctorrent -s $TARGET -c $SOURCE | tail -n1 | cut -f2 -d\( "
 	TOTAL=`ctorrent -s $TARGET -c $SOURCE | tail -n1 | cut -f2 -d\(`
 	if [ "$TOTAL" == "100%)" ]
 	then
    	 return 0
 	else 
    	 return 1
 	fi
 
 fi
 
cd /tmp
}

#/**
#         ogCreateTorrent  [ str_repo | int_ndisk int_npart ] Relative_path_file
#@brief   Función para crear el fichero torrent.
#@param   str_pathDirectory  str_Relative_path_file
#@param  int_disk    int_partition   str_Relative_path_file
#@param  str_REPOSITORY(CACHE - LOCAL)  str_Relative_path_file
#@return
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@exception OG_ERR_PARTITION Tipo de partición desconocido o no se puede montar.
#@exception OG_ERR_NOTOS     La partición no tiene instalado un sistema operativo.
#@note
#@version 0.1 - Integración para OpenGNSys.
#@author        Antonio J. Doblas Viso. Universidad de Málaga
#@date
#@version 0.2 - Integración para btlaunch.
#@author        Irina . Univesidad de Sevilla.
#@date
#*/ ##

ogCreateTorrent ()
{
# Variables locales.
local ARGS ARG SOURCE IPTORRENT


# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME [str_REPOSITORY] [int_ndisk int_npart] Relative_path_file IpBttrack" \           "$FUNCNAME 1 1 /aula1/winxp 10.1.15.23" \
       "$FUNCNAME REPO /aula1/winxp 10.1.15.45"

    return
fi

# Error si se quiere crear el fichero en cache y no existe
[ "$1" != "CACHE" ] || `ogFindCache >/dev/null` || ogRaiseError $OG_ERR_NOTFOUND "CACHE"|| return $?

case "$1" in
    /*)     # Camino completo.          */ (Comentrio Doxygen)
           SOURCE=$(ogGetPath "$1.img")
        ARG=2
		;;
    [1-9]*) # ndisco npartición.
           SOURCE=$(ogGetPath "$1" "$2" "$3.img")
        ARG=4
        ;;
    *)      # Otros: repo, cache, cdrom (no se permiten caminos relativos).
           SOURCE=$(ogGetPath "$1" "$2.img")
        ARG=3
        ;;
esac

# Error si no se reciben los argumentos ARG necesarios según la opcion.
[ $# -eq "$ARG" ] || ogRaiseError $OG_ERR_FORMAT || return $?


# Error si no existe la imagen
[ $SOURCE ] ||  ogRaiseError $OG_ERR_NOTFOUND || return $?

[ -r $SOURCE.torrent ] && mv "$SOURCE.torrent" "$SOURCE.torrent.ant" && echo "Esperamos que se refresque el servidor" && sleep 20

IPTORRENT="${!#}"
# Si ponemos el path completo cuando creamos el fichero torrent da error
cd `dirname $SOURCE`
echo ctorrent -t `basename $SOURCE` -u http://$IPTORRENT:6969/announce -s $SOURCE.torrent
ctorrent -t `basename $SOURCE` -u http://$IPTORRENT:6969/announce -s $SOURCE.torrent

}






############################################################
### FUNCIONES MULTICAST EN DESARROLLO ##########


#/**
#         ogMcastSessionCheck [session]
#@brief   Controla los parámetros de una sessión multicast
#@param   str_session   
#@return  (nada, por determinar)
#@exception OG_ERR_FORMAT     formato incorrecto.
#@note    Requisitos: 
#@version 0.91 - Definición de FileTransfer
#@author  Antonio Doblas Viso, Universidad de Málaga
#@date    2010/05/09
#*/ ##
ogMcastSessionCheck ()
{
echo "en pruebas"
#sessionSERVER  PORTBASE:METHOD:ADDRESS:BITRATE:NCLINTS:MAXTIME:TOOLCLONE:COMPRESSOR
#sessionCLIENT  PORTBASE:TOOLCLONE:COMPRESSOR
#PORTBASE: 9000 (incluye el 9001), 9002 (incluye el 9003), 9004
#METHOD: full-duplex half-duplex brodcast
#ADDRESS: Dirección habilitada para la transferencia. 339.194.ip2.ip3
#BITRATE: 90M   80M   70M
#NCLIENTS:
#MAXTIME:
#TOOLCLONE:
#COMPRESSOR:
}


#/**
#         ogMcastSessionList
#@brief   Lista las sessiones abiertas multicast.
#@param   (en pruebas) 
#@return  (nada, por determinar)
#@exception OG_ERR_FORMAT     formato incorrecto.
#@note    Requisitos: 
#@version 0.91 - Definición de FileTransfer
#@author  Antonio Doblas Viso, Universidad de Málaga
#@date    2010/05/09
#*/ ##
ogMcastSessionList()
{
echo "en preubas"
#puertos a utilizar 9000 - 9008 => se definen 10 sesiones
#lsof -i -nP | grep 900 | awk '{print $9}' | awk -F: '{print $2}' | uniq
}

#/**
#         ogMcastSessionDelete
#@brief   Libera una session Mulitcast.
#@param   (en pruebas) 
#@return  (nada, por determinar)
#@exception OG_ERR_FORMAT     formato incorrecto.
#@note    Requisitos: 
#@version 0.91 - Definición de FileTransfer
#@author  Antonio Doblas Viso, Universidad de Málaga
#@date    2010/05/09
#*/ ##
ogMcastSessionDelete()
{
echo "en pruebas"
}

#/**
#         ogMcastSendPartition
#@brief   Función para enviar el contenido de una partición a multiples particiones remotas.
#@param
#@param
#@param
#@return
#@exception
#@note
#@todo:
#@version 0.1 - Integración para OpenGNSys.
#@author
#@date
#*/ ##

ogMcastSendPartition ()
{

# Variables locales
local PART  ERRCODE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npart " \
           "$FUNCNAME 1 1 "
    return
fi
# Error si no se reciben 2 parámetros.
[ $# -lt 2 ] && ogRaiseError $OG_ERR_FORMAT && return $?

PART=$(ogDiskToDev "$1" "$2") || return $?
if ogIsLocked $1 $2; then
    ogRaiseError $OG_ERR_LOCKED "$1,$2"
    return $?
fi


echo "en pruebas"

}


#/**
#         ogMcastRestorePartition
#@brief   Función para recibir directamente en la partición el contenido de un fichero imagen remoto enviado por multicast.
#@param
#@param
#@param
#@return
#@exception
#@note
#@todo:
#@version 0.1 - Integración para OpenGNSys.
#@author
#@date
#*/ ##
ogMcastRestorePartition ()
{
echo "en pruebas"
}

########################## FUNCIONES TORRENT EN DESARROLLO
##################################################
#/**
#         ogStartTracker
#@brief   Inicia el tracker
#@param   str_pathDirectory  str_Relative_path_file
#@param  int_disk    int_partition   str_Relative_path_file
#@param  str_REPOSITORY(CACHE - LOCAL)  str_Relative_path_file
#@return
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o particion no corresponden con un dispositivo.
#@exception OG_ERR_PARTITION Tipo de partición desconocido o no se puede montar.
#@exception OG_ERR_NOTOS     La partición no tiene instalado un sistema operativo.
#@note
#@version 0.1 - Integración para OpenGNSys.
#@author
#@date
#*/ ##
ogStartTracker ()
{
	echo " bug2: usar el tracker del bittornado. "
	echo " solucion bug2: apt-get autoremove bittorrent python-bittorrent "
	echo "soulución bug2: apt-get install bittornado. "
	echo "#Paso 2: iniciar track "
local TESTBTT
TESTBTT=`ps aux | grep bttrack | egrep -v grep | wc -l`
if [ "$TESTBTT" == "0" ]; then
	bttrack --reannounce_interval 10 --port 6969 --dfile /root/dstate --logfile /root/bttracker.log --save_dfile_interval 10 --timeout_downloaders_interval 10 2>/dev/null &
else
	echo "bttrack iniciado"
fi

}

ogShareTorrent ()
{
# Variables locales.
local ARGS SOURCE TARGET


# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME [str_REPOSITORY] [int_ndisk int_npart] Relative_path_file" \
           "$FUNCNAME 1 1 /aula1/winxp" \
           "$FUNCNAME REPO /aula1/winxp"

    return
fi

# Error si se quiere compartir un fichero en cache y no existe la cache
[ "$1" != "CACHE" ] || `ogFindCache >/dev/null` || ogRaiseError $OG_ERR_NOTFOUND "CACHE"|| return $?

case "$1" in
    /*)     # Camino completo.          */ (Comentrio Doxygen)
           SOURCE=$(ogGetPath "$1.img")
           ARG=1
		;;
    [1-9]*) # ndisco npartición.
           SOURCE=$(ogGetPath "$1" "$2" "$3.img")
        ARG=3
        ;;
    *)      # Otros: repo, cache, cdrom (no se permiten caminos relativos).
           SOURCE=$(ogGetPath "$1" "$2.img" 2>/dev/null)
        ARG=2
        ;;
esac


# Error si no se reciben los argumentos ARG necesarios según la opcion.
[ $# -ne "$ARG" ] && ogRaiseError $OG_ERR_FORMAT && return $?

# Comprobar fichero origen
[ -n "$SOURCE.torrent" ] || ogRaiseError $OG_ERR_NOTFOUND "${ARGS% $*}" || return $?

echo ctorrent $SOURCE.torrent -d
ctorrent $SOURCE.torrent -d

}


ogTorrentReceiverFile ()
{
# obligatorio disponer de cache
# origen destino.
#origen es el .torrent
# origen: REPO /file.torrent
# Si REPO, (nfs, http) copiamos a CACHE.

# destino es el fichero final.
# destino: CACHE /file
# destino: disk part /file

# Variables locales.
    local ARGS ARG SOURCEDIR SOURCEFILE TARGETDIR TARGETFILE

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME [str_REPOSITORY] [int_ndisk int_npart] Relative_path_file" \
           "$FUNCNAME REPO /aula1/winxp.torrent CACHE /aula1/winxp" \
           "$FUNCNAME REPO /aula1/winxp.torrent 1 1 /iso" 
fi
# Comprobamos que existe Cache
`ogFindCache > /dev/null` || ogRaiseError $OG_ERR_NOTFOUND "CACHE" || return $?

# guardamos torrent. controlamos tamaño del fichero y comprobamos con cache.
ogCopyFile $1 $2 $3 $4


}

ogReceiveTorrent ()
{
# Variables locales.
    local ARGS ARG TARGETDIR TARGETFILE



# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME [str_REPOSITORY] [int_ndisk int_npart] Relative_path_file" \
           "$FUNCNAME 1 1 /aula1/winxp" \
           "$FUNCNAME REPO /aula1/winxp" \
           "$FUNCNAME /mnt/sda2/winxp"


    return
fi

# Comprobamos que existe Cache
`ogFindCache > /dev/null` || ogRaiseError $OG_ERR_NOTFOUND "CACHE" || return $?

ARGS="$*"
case "$1" in
    /*)     # Camino completo.          */ (Comentrio Doxygen)
    TARGETDIR=$(ogGetParentPath "$1")
        ARG=1
		;;
    [1-9]*) # ndisco npartición.
    TARGETDIR=$(ogGetParentPath "$1" "$2" "$3")
        ARG=3
        ;;
    *)      # Otros: repo, cache, cdrom (no se permiten caminos relativos).
    TARGETDIR=$(ogGetParentPath "$1" "$2")
        ARG=2
        ;;
esac
#echo $TARGETDIR

# Error si no se reciben los argumentos ARG necesarios según la opcion.
[ "$#" -ne "$ARG" ] && ogRaiseError $OG_ERR_FORMAT && return $?

#obtenemos el nombre del fichero a descargar.
TARGETFILE=`basename ${!ARG}`
CACHE=`ogMountCache`

# Error si no existe el fichero torrent
[ -r $TARGETDIR/$TARGETFILE.img.torrent ] || ogRaiseError $OG_ERR_NOTFOUND || return $?
[ -d ${CACHE}/$OGIMG ] || ogRaiseError $OG_ERR_NOTFOUND || return $?

TimeToWaitForCloseAfterDownload=20  # tiempo que deseamos que el cliente este como semilla, despues de la descarga.

# Si el fichero ya se ha bajado antes de iniciar el ctorrent no se ejecuta el comando kill, siguen encendido siempre
# Comprobamos si se ha descargado antes, si es asi nos salimos
Total=`ctorrent -s ${CACHE}/$OGIMG/${TARGETFILE}.img -c $TARGETDIR/$TARGETFILE.img.torrent|tail -n1|cut -f2 -d\(`
[ $Total == "100%)" ] &&  return 0

echo "ctorrent -X 'sleep $TimeToWaitForCloseAfterDownload; kill -9 \$(pidof ctorrent)' $TARGETDIR/$TARGETFILE.img.torrent -s ${CACHE}/$OGIMG/${TARGETFILE}.img -b ${CACHE}/$OGIMG/$TARGETFILE.bf -C 100"
ctorrent -X "sleep $TimeToWaitForCloseAfterDownload; kill -9 \$(pidof ctorrent)" $TARGETDIR/$TARGETFILE.img.torrent -s ${CACHE}/$OGIMG/${TARGETFILE}.img -b ${CACHE}/$OGIMG/$TARGETFILE.bf -C 100

[ -r ${CACHE}/$OGIMG/$TARGETFILE.bf ] && rm ${CACHE}/$OGIMG/$TARGETFILE.bf
}

ogCheckSessionMulticast ()
{
# $1 tipo de sesion server client
# 2 la sesisón.
#variables locales
local NPARM MODE SESSION 

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME str_mode    array_session" \
		   "$FUNCNAME client PORTBASE"\
		   "$FUNCNAME server PORTBASE:METHOD:ADDRESS:BITRATE:NCLIENTS:MAXTIME"
    return
fi


# Error si no se recibe 2 parámetro.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# controlamos el primer parametro.
ogCheckStringInGroup "$1" "client server" || ogRaiseError $OG_ERR_OUTOFLIMIT || return $?

#controlamos el segundo parametro. La sessión multicast.
[ $1 == "client" ] && NPARM=1 || NPARM=6
OIFS=$IFS; IFS=':' ; SESSION=($2); IFS=$OIFS
[[ ${#SESSION[*]} == $NPARM ]]  || ogRaiseError $OG_ERR_OUTOFLIMIT || return $?

#controlamos el PORTBASE de la sesion. Comun.-
ogCheckStringInGroup ${SESSION[0]} "9000 9002 9004 9006 9008 9010" || ogRaiseError $OG_ERR_OUTOFLIMIT || return $?

if [ "$1" == "server" ]
then
    # $METHOD
	ogCheckStringInGroup ${SESSION[1]} "full-duplex half-duplex broadcast" || ogRaiseError $OG_ERR_OUTOFLIMIT || return $?
	# $ADDRESS
	ogCheckIpAddress ${SESSION[2]}  || ogRaiseError $OG_ERR_OUTOFLIMIT || return $?
	#BITRATE
	ogCheckStringInReg ${SESSION[3]} "^[1-9]{1,2}M$" || ogRaiseError $OG_ERR_OUTOFLIMIT || return $?
	#NCLIENTS
	ogCheckStringInReg ${SESSION[4]} "^[0-9]{1,10}$" || ogRaiseError $OG_ERR_OUTOFLIMIT || return $?
	#MAXTIME
	ogCheckStringInReg ${SESSION[5]} "^[0-9]{1,10}$" || ogRaiseError $OG_ERR_OUTOFLIMIT "  " || return $?
fi
return 0
}
