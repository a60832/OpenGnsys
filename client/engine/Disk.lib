#!/bin/bash
#/**
#@file    Disk.lib
#@brief   Librería o clase Disk
#@class   Disk
#@brief   Funciones para gestión de discos y particiones.
#@version 0.9
#@warning License: GNU GPLv3+
#*/


#/**
#         ogCreatePartitions ndisk parttype:partsize ...
#@brief   Define el conjunto de particiones de un disco.
#@arg \c  int_ndisk      nº de orden del disco
#@arg \c  str_parttype   mnemónico del tipo de partición
#@arg \c  int_partsize   tamaño de la partición (en KB)
#@return  (nada, por determinar)
#@exception OG_ERR_FORMAT   formato incorrecto.
#@exception OG_ERR_NOTFOUND disco o particion no detectado (no es un dispositivo).
#@attention El nº de partición se indica por el orden de los párametros \c parttype:partsize
#@attention Pueden definirse particiones vacías de tipo \c EMPTY
#@note    Requisitos: sfdisk, parted, partprobe, awk
#@todo    Definir atributos (arranque, oculta) y tamaños en MB, GB, etc.
#@version 0.9 - Primera versión para OpenGNSys
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009/09/09
#*/
function ogCreatePartitions () {

# Variables locales.
local DISK PART SECTORS START SIZE TYPE EXTSTART EXTSIZE tmpsfdisk
#/// Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk str_parttype:int_partsize ..." \
           "$FUNCNAME 1 NTFS:10000000 EXT3:5000000 LINUX-SWAP:1000000"
    return
fi
#/// Error si no se reciben menos de 2 parámetros.
[ $# -gt 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

#/// Desmontar todos los sistemas de archivos del disco.
DISK="$(ogDiskToDev $1)" || return $?
ogUnmountAll $1
shift

# Nº total de sectores, para evitar desbordamiento
SECTORS=$(awk -v D=${DISK#/dev/} '{if ($4==D) {print $3*2}}' /proc/partitions)
# Sector de inicio de la particon (la 1ª empieza en el sector 63).
START=63
PART=1

# Fichero temporal de entrada para "sfdisk"
tmpsfdisk=/tmp/sfdisk$$
trap "rm -f $tmpsfdisk" 1 2 3 9 15

echo "unit: sectors" >$tmpsfdisk
echo                >>$tmpsfdisk

#/// Generar fichero de entrada para "sfdisk" con las particiones.
while [ $# -gt 0 ]; do
    #/// Leer formato de cada parámetro - Tipo:Tamaño
    TYPE="${1%%:*}"
    SIZE="${1#*:}"
    [ -z "$SIZE" ] && ogRaiseError $OG_ERR_FORMAT && return $?
    #/// Convertir en sectores de 512 B.
    SIZE=$[SIZE*2]
    [ $SIZE -eq 0 ] && ogRaiseError $OG_ERR_FORMAT && return $?
    #/// Obtener identificador de tipo de partición.
    case "$TYPE" in
        EMPTY)      ID=0  ;;
        EXTENDED)	ID=5
                    [ $PART -gt 4 ] && ogRaiseError $OG_ERR_FORMAT && return $?
                    EXTSTART=$START
                    EXTSIZE=$SIZE
                    ;;
        EXT[234]|REISERFS|REISER4|XFS|JFS)
                    ID=83 ;;
        LINUX-SWAP) ID=82 ;;
        LINUX-LVM)  ID=8e ;;
        LINUX-RAID) ID=fd ;;
        SOLARIS)    ID=bf ;;
        NTFS|EXFAT) ID=7  ;;
        HNTFS)	    ID=17 ;;
        FAT32)	    ID=b  ;;
        HFAT32)     ID=1b ;;
        FAT16)	    ID=6  ;;
        HFAT16)     ID=16 ;;
        FAT12)	    ID=1  ;;
        HFAT12)     ID=11 ;;
        CACHE)      ID=ca ;;
        *)          ogRaiseError $OG_ERR_PARTITION "$TYPE"
	                return $? ;;
    esac
    #/// Incluir particiones lógicas dentro de la partición extendida.
    if [ $PART = 5 ]; then
        [ -z "$EXTSTART" ] && ogRaiseError $OG_ERR_FORMAT && return $?
        START=$EXTSTART
        SECTORS=$[EXTSTART+EXTSIZE]
    fi
    #/// Generar datos para la partición.
    echo "$DISK$PART : start=$START, size=$SIZE, Id=$ID" >>$tmpsfdisk
    #/// Error si se supera el nº total de sectores.
    START=$[START+SIZE]
    [ $START -gt $SECTORS ] && ogRaiseError $OG_ERR_FORMAT && return $?
    PART=$[PART+1]
    shift
done
# Si no se indican las 4 particiones primarias, definirlas como vacías.
while [ $PART -le 4 ]; do
    echo "$DISK$PART : start=0, size=0, Id=0" >>$tmpsfdisk
    PART=$[PART+1]
done
# Si se define partición extendida sin lógicas, crear particion 5 vacía.
if [ $PART = 5 -a -n "$EXTSTART" ]; then
    echo "${DISK}5 : start=$EXTSTART, size=$EXTSIZE, Id=0" >>$tmpsfdisk
fi

# Si la tabla de particiones no es valida, volver a generarla.
[ $(parted -s $DISK print >/dev/null) ] || fdisk $DISK <<< "w"
#/// Definir particiones y notificar al kernel.
sfdisk -f $DISK < $tmpsfdisk 2>/dev/null && sfdisk -R $DISK
rm -f $tmpsfdisk
}


#/**
#         ogDevToDisk device
#@brief   Devuelve el nº de orden de dicso (y partición) correspondiente al nombre de fichero de dispositivo.
#@arg \c  path_device Camino del fichero de dispositivo.
#@return  ndisk (para dispositivo de disco)
#@return  ndisk npartition (para dispositivo de partición).
#@exception OG_ERR_FORMAT   Formato incorrecto.
#@exception OG_ERR_NOTFOUND Dispositivo no detectado.
#@note    Requisitos: awk
#@version 0.9 - Primera versión para OpenGNSys
#@author  Ramon Gomez, ETSII Universidad Sevilla
#@date    2009-07-20
#*/
function ogDevToDisk () {

# Variables locales.
local d n
#/// Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME path_device" \
           "$FUNCNAME /dev/sda  =>  1 1"
    return
fi

#/// Error si no se recibe 1 parámetro.
[ $# == 1 ] || ogRaiseError $OG_ERR_FORMAT || return $?
#/// Error si no es fichero de bloques.
[ -b "$1" ] || ogRaiseError $OG_ERR_NOTFOUND "$1" || return $?

#/// Procesa todos los discos para devolver su nº de orden y de partición.
n=1
for d in $(ogDiskToDev); do
    [ -n "$(echo $1 | grep $d)" ] && echo "$n ${1#$d}" && return
    n=$[n+1]
done
ogRaiseError $OG_ERR_NOTFOUND "$1"
return $OG_ERR_NOTFOUND
}


#/**
#         ogDiskToDev [ndisk [npartition]]
#@brief   Devuelve la equivalencia entre el nº de orden del dispositivo (dicso o partición) y el nombre de fichero de dispositivo correspondiente.
#@arg \c  int_ndisk      nº de orden del disco
#@arg \c  int_npartition nº de orden de la partición
#@return  Para 0 parametros: Devuelve los nombres de ficheros  de los dispositivos sata/ata/usb linux encontrados.
#@return  Para 1 parametros: Devuelve la ruta del disco duro indicado.
#@return  Para 2 parametros: Devuelve la ruta de la particion indicada.
#@exception OG_ERR_FORMAT   Formato incorrecto.
#@exception OG_ERR_NOTFOUND Dispositivo no detectado.
#@note    Requisitos: awk, lvm
#@version 0.9 - Primera versión para OpenGNSys
#@author  Ramon Gomez, ETSII Universidad Sevilla
#@date    2009-07-20
#*/
function ogDiskToDev () {

# Variables locales
local ALLDISKS VOLGROUPS DISK PART

#/// Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk [int_npartition]" \
           "$FUNCNAME      =>  /dev/sda /dev/sdb" \
           "$FUNCNAME 1    =>  /dev/sda" \
           "$FUNCNAME 1 1  =>  /dev/sda1"
    return
fi

#/// Listar dispositivo para los discos duros (tipos: 3=hd, 8=sd).
ALLDISKS=$(awk '($1==3 || $1==8) && $4!~/[0-9]/ {printf "/dev/%s ",$4}' /proc/partitions)
VOLGROUPS=$(vgchange -ay &>/dev/null && vgs -a --noheadings | awk '{printf "/dev/%s ",$1}')
ALLDISKS="$ALLDISKS $VOLGROUPS"

#/// Mostrar salidas segun el número de parametros.
case $# in
    0)  # Muestra todos los discos, separados por espacios.
        echo $ALLDISKS
        ;;
    1)  # Error si el parámetro no es un digito.
        [ -z "${1/[1-9]/}" ] || ogRaiseError $OG_ERR_FORMAT || return $?
        DISK=$(echo "$ALLDISKS" | awk -v n=$1 '{print $n}')
        # Error si el fichero no existe.
        [ -e "$DISK" ] || ogRaiseError $OG_ERR_NOTFOUND "$1" || return $?
        echo "$DISK"
        ;;
    2)  # Error si los 2 parámetros no son digitos.
        [ -z "${1/[1-9]/}" -a -z "${2/[1-9]/}" ] || ogRaiseError $OG_ERR_FORMAT|| return $?
        DISK=$(echo "$ALLDISKS" | awk -v n=$1 '{print $n}')
        [ -e "$DISK" ] || ogRaiseError $OG_ERR_NOTFOUND "$1" || return $?
        PART="$DISK$2"
        #/// Comprobar si es partición.
        if [ -b "$PART" ]; then
            echo "$PART"
        elif [ -n "$VOLGROUPS" ]; then
            #/// Comprobar si volumen lógico.
            PART=$(lvscan -a 2>/dev/null | grep "'$DISK/" | awk -v n=$2 -F\' '{if (NR==n) print $2}')
            [ -e "$PART" ] || ogRaiseError $OG_ERR_NOTFOUND "$1 $2" || return $?
            echo "$PART"
        else
            ogRaiseError $OG_ERR_NOTFOUND "$1 $2" || return $?
        fi
        ;;
    *)  # Formato erroneo.
        ogRaiseError $OG_ERR_FORMAT
        return $OG_ERR_FORMAT
        ;;
esac
}


#/**
#         ogGetPartitionActive ndisk
#@brief   Muestra que particion de un disco esta marcada como de activa.
#@arg \c  int_ndisk      nº de orden del disco
#@return  Nº de partición activa
#@exception OG_ERR_FORMAT Formato incorrecto.
#@exception OG_ERR_NOTFOUND Disco o particion no corresponden con un dispositivo.
#@note    Requisitos: parted
#@todo    Queda definir formato para atributos (arranque, oculta, ...).
#@version 0.9 - Primera versión compatible con OpenGNSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009/07/24
#*/
function ogGetPartitionActive () {

# Variables locales
local DISK

#/// Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk" "$FUNCNAME 1  =>  1"
    return
fi
#/// Error si no se recibe 1 parámetro.
[ $# == 1 ] || ogRaiseError $OG_ERR_FORMAT || return $?

#/// Comprobar que el disco existe y listar su partición activa.
DISK="$(ogDiskToDev $1)" || return $?
parted $DISK print 2>/dev/null | awk '/boot/ {print $1}'
}


#/**
#         ogGetPartitionId ndisk npartition
#@brief   Devuelve el mnemonico con el tipo de sistema de archivos.
#@arg \c  int_ndisk      nº de orden del disco
#@arg \c  int_npartition nº de orden de la partición
#@return  Identificador de tipo de partición.
#@exception OG_ERR_FORMAT   Formato incorrecto.
#@exception OG_ERR_NOTFOUND Disco o particion no corresponden con un dispositivo.
#@note    Requisitos: sfdisk
#@version 0.9 - Primera versión compatible con OpenGNSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    25/03/2009
#*/
function ogGetPartitionId () {

# Variables locales.
local DISK PART

#/// Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
           "$FUNCNAME 1 1  =>  7"
    return
fi
#/// Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

#/// Detectar id. de tipo de particion y codificar al mnemonico.
DISK=$(ogDiskToDev $1) || return $?
PART=$(ogDiskToDev $1 $2) || return $?
echo $(sfdisk --id $DISK $2 2>/dev/null)
}


#/**
#         ogGetPartitionSize ndisk npartition
#@brief   Muestra el tamano en KB de una particion determinada.
#@arg \c  int_ndisk      nº de orden del disco
#@arg \c  int_npartition nº de orden de la partición
#@return  tamañoKB
#@exception OG_ERR_FORMAT   formato incorrecto.
#@exception OG_ERR_NOTFOUND disco o particion no detectado (no es un dispositivo).
#@note    Requisitos: sfdisk, awk
#@version 0.9 - Primera versión para OpenGNSys
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009/07/24
#*/
function ogGetPartitionSize () {

# Variables locales.
local PART

#/// Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
           "$FUNCNAME 1 1  =>  10000000"
    return
fi
#/// Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

#/// Obtener el tamaño de la partición.
PART="$(ogDiskToDev $1 $2)" || return $?
sfdisk -s $PART
}


#/**
#         ogListPartitions int_ndisk
#@brief   Lista las particiones definidas en un disco.
#@arg \c  int_ndisk  nº de orden del disco
#@return  tipo:tamanoKB ...
#@exception OG_ERR_FORMAT   formato incorrecto.
#@exception OG_ERR_NOTFOUND disco o particion no detectado (no es un dispositivo).
#@note    Requisitos: \c parted \c awk
#@attention El nº de partición se indica por el orden de los párametros \c parttype:partsize
#@attention Las tuplas de valores están separadas por espacios.
#@version 0.9 - Primera versión para OpenGNSys
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009/07/24
#*/
function ogListPartitions () {

# Variables locales.
local DISK PART NPARTS

#/// Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk" \
           "$FUNCNAME 1  =>  NTFS:10000000 EXT3:5000000 LINUX-SWAP:1000000"
    return
fi
#/// Error si no se recibe 1 parámetro.
[ $# == 1 ] || ogRaiseError $OG_ERR_FORMAT "$FORMAT" || return $?

#/// Procesar la salida de \c parted .
DISK="$(ogDiskToDev $1)" || return $?
NPARTS=$(parted -s $DISK print | awk '$1~/^[1-9]/ {print $1}')
for PART in $NPARTS; do
    echo -n "$(ogGetFsType $1 $PART):$(ogGetPartitionSize $1 $PART) "
done
echo
}


#/**
#         ogSetPartitionActive ndisk npartition
#@brief   Establece cual es la partición activa de un disco.
#@arg \c  int_ndisk      nº de orden del disco
#@arg \c  int_npartition nº de orden de la partición
#@return  Nada.
#@exception OG_ERR_FORMAT   Formato incorrecto.
#@exception OG_ERR_NOTFOUND Disco o partición no corresponden con un dispositivo.
#@note    Requisitos: parted
#@version 0.9 - Primera versión compatible con OpenGNSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009/09/17
#*/
function ogSetPartitionActive () {

# Variables locales
local DISK PART

#/// Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
	   "$FUNCNAME 1 1"
    return
fi
#/// Error si no se reciben 2 parámetros.
[ $# == 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

#/// Comprobar que el disco existe y activar la partición indicada.
DISK="$(ogDiskToDev $1)" || return $?
PART="$(ogDiskToDev $1 $2)" || return $?
parted -s $DISK set $2 boot on 2>/dev/null
}


#/**
#         ogSetPartitionSize ndisk npartition size
#@brief   Muestra el tamano en KB de una particion determinada.
#@arg \c  int_ndisk      nº de orden del disco
#@arg \c  int_npartition nº de orden de la partición
#@arg \c  int_size       tamaño de la partición (en KB)
#@return  (nada)
#@exception OG_ERR_FORMAT   formato incorrecto.
#@exception OG_ERR_NOTFOUND disco o particion no detectado (no es un dispositivo).
#@note    Requisitos: sfdisk, awk
#@todo    Compruebar que el tamaño sea numérico positivo y evitar que pueda solaparse con la siguiente partición.
#@version 0.9 - Primera versión para OpenGNSys
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009/07/24
#*/
function ogSetPartitionSize () {

# Variables locales.
local DISK PART SIZE

#/// Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
           "$FUNCNAME 1 1 10000000"
    return
fi
#/// Error si no se reciben 3 parámetros.
[ $# == 3 ] || ogRaiseError $OG_ERR_FORMAT || return $?

#/// Obtener el tamaño de la partición.
DISK="$(ogDiskToDev $1)" || return $?
PART="$(ogDiskToDev $1 $2)" || return $?
# Convertir tamaño en KB a sectores de 512 B.
SIZE=$[$3*2] || ogRaiseError $OG_ERR_FORMAT || return $?
#/// Usar \c sfdisk para redefinir el tamaño.
sfdisk -f -uS -N$2 $DISK <<< ",$SIZE" &>/dev/null || ogRaiseError $OG_ERR_PARTITION "$1,$2" || return $?
}


#/**
#         ogUpdatePartitionTable
#@brief   Fuerza al kernel releer la tabla de particiones de los discos duros
#@arg \c  no requiere
#@return  informacion propia de la herramienta
#@note    Requisitos: \c partprobe
#@warning pendiente estructurar la funcion a opengnsys
#@version 0.1       Date: 27/10/2008                 Author Antonio J. Doblas Viso. Universidad de Malaga
#@note	 funcion importada de EAC
#*/

function ogUpdatePartitionTable () {
echo "Forzando al kernel la lectura de la tabla de particiones"
list=`partprobe -s | cut -f1 -d: ` 2>/dev/null
echo $list > /tmp/disk
}




function ogGetPartitionsNumber () {
#/**  @function ogGetPartitionsNumber: @brief detecta el numero de particiones del disco duro indicado.
#@param  int_numdisk   (indentificado EAC del disco)
#@return  devuelve el numero paritiones del disco duro indicado
#@warning  Salidas de errores no determinada
#@attention Requisitos: parted
#@note	  Notas sin especificar
#@version 0.1       Date: 27/10/2008                 Author Antonio J. Doblas Viso. Universidad de Malaga
#*/
disco=`ogDiskToDev $1`
totalpart=`parted $disco print | egrep ^" [0123456789] " -c`
echo $totalpart
}


function ogDiskToRelativeDev () {
#/**  @function ogDiskToRelativeDev: @brief Traduce los ID de discos o particiones EAC a ID Linux relativos, es decir 1 1 => sda1
#@param  Admite 1 parametro:   $1  int_numdisk
#@param  Admite 2 parametro:   $1   int_numdisk                    $2  int_partition
#@return  Para 1 parametros traduce Discos Duros: Devuelve la ruta relativa linux del disco duro indicado con nomenclatura EAC.........ejemplo: IdPartition 1 => sda
#@return  Para 2 parametros traduce Particiones: Devuelve la ruta relativa linux de la particion indicado con nomenclatura EAC...........  ejemplo: IdPartition  2 1 => sdb1
#@warning  No definidas
#@attention
#@note	  Notas sin especificar
#@version 0.1       Date: 27/10/2008                 Author Antonio J. Doblas Viso. Universidad de Malaga
#*/

if [ $# = 0 ]
then
	Msg "Info: Traduce el identificador del dispositivo EAC a dispositivo linux \n" info
	Msg "Sintaxis1: IdPartition int_disk -----------------Ejemplo1: IdPartition 1 -> sda " example
	Msg "Sintaxis2: IdPartition int_disk int_partition  --Ejemplo2: IdPartition 1 2 -> sda2 " example

return
fi
#PART="$(Disk|cut -f$1 -d' ')$2"    # se comenta esta linea porque doxygen no reconoce la funcion disk y no crea los enlaces y referencias correctas.
PART=$(ogDiskToDev|cut -f$1 -d' ')$2
echo $PART | cut -f3 -d \/
}


function ogDeletePartitionTable () {
#/**  @function ogDeletePartitionTable: @brief Borra la tabla de particiones del disco.
#@param $1 opcion A (identificador LINUX) 	str_ID_linux (/dev/sda)
#@param $1 opcion B (Identifiador EAC)  		int_numdiskEAC(1)
#@return   la informacion propia del fdisk
#@warning    no definidos
#@attention
#@note
#@version 0.1       Date: 27/10/2008                 Author Antonio J. Doblas Viso. Universidad de Malaga
#*/
if [ $# = 0 ]
then
	Msg "sintaxis1: ogDeletePartitionTable int_disk" red
	Msg "sintaxis2: ogDeletePartitionTable str_/dev/sdX" red
	return
fi
if [ -n "${1%/dev/*}" ]
	then
	dev=`DiskToDev $1`
	else
	dev=$1
fi
echo -ne "o\nw" | fdisk $dev
}



function ogSetPartitionId() {
#/**  @function ogSetPartitionId: @brief Cambia el identificador de la particion, pero no su sistema de archivos.
#@param  $1 int_numdiskEAC
#@param  $2 int_numpartitionEAC
#@param  $3 str_tipoPartition admite EXT2 EXT3 NTFS FAT32 SWAP CACHE
#@return   la propia del fdisk
#@warning    no controla los parametros, si se introducen mal o simplemente no se introducen no muestra mensaje
#@warning    Identifica por nombre del sistema de archivos no por número
#@attention Requisitos:  fdisk
#@note
#@version 0.1       Date: 27/10/2008                 Author Antonio J. Doblas Viso. Universidad de Malaga
#*/

# Variables locales
local DISK PART ID

#/// Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
           "$FUNCNAME 1 1 10000000"
    return
fi
#/// Error si no se reciben 3 parámetros.
[ $# == 3 ] || ogRaiseError $OG_ERR_FORMAT || return $?

#/// Sustituye nº de disco por su dispositivo.
DISK=`ogDiskToDev $1` || return $?
PART=`ogDiskToDev $1 $2` || return $?

#/// Elección del tipo de partición.
case "$3" in
    EMPTY)      ID=0  ;;
    EXTENDED)   ID=5  ;;
    NTFS|EXFAT) ID=7  ;;
    FAT32)      ID=b  ;;
    HNTFS)      ID=17 ;;
    HFAT32)     ID=1b ;;
    LINUX-SWAP) ID=82 ;;
    EXT[234]|REISERFS|REISER4|XFS|JFS)
                ID=83 ;;
    SOLARIS)    ID=bf ;;
    CACHE)      ID=ca ;;
    *)          ogRaiseError $OG_ERR_PARTITION "$TYPE"
                return $? ;;
esac
echo -ne "t\n$2\n${ID}\nw\n" | fdisk $DISK 1>/dev/null 2>&1
}


function ogDeletePartitionsLabels () {
#/**  @function ogDeletePartitionsLabels: @brief Elimina la informacion que tiene el kernel del cliente og sobre los labels de los sistemas de archivos
#@param  No requiere
#@return   Nada
#@warning
#@attention Requisitos:  comando interno linux rm
#@note
#@version 0.1       Date: 27/10/2008                 Author Antonio J. Doblas Viso. Universidad de Malaga
#*/
rm /dev/disk/by-label/*    # */ COMENTARIO OBLIGATORIO PARA DOXYGEN
}

