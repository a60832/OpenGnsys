#!/bin/bash
#/**
#@file    Inventory.lib
#@brief   Librería o clase Inventory
#@class   Inventory
#@brief   Funciones para recogida de datos de inventario de hardware y software de los clientes.
#@version 1.0.6
#@warning License: GNU GPLv3+
#*/


#/**
#         ogGetArch
#@brief   Devuelve el tipo de arquitectura del cliente.
#@return  str_arch - Arquitectura (i386 para 32 bits, x86_64 para 64 bits).
#@version 0.9.2 - Primera versión para OpenGnSys.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2010-07-17
#*/ 
function ogGetArch ()
{
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME" "$FUNCNAME  =>  x86_64"
    return
fi

[ -d /lib64 ] && echo "x86_64" || echo "i386"
}


#/**
#         ogGetOsType int_ndisk int_npartition
#@brief   Devuelve el tipo del sistema operativo instalado.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@return  OSType - Tipo de sistema operativo.
#@see     ogGetOsVersion
#*/ ##
function ogGetOsType ()
{
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_npartition" \
           "$FUNCNAME 1 2  =>  Linux"
    return
fi
ogGetOsVersion "$@" | cut -sf1 -d:
}


#/**
#         ogGetOsVersion int_ndisk int_nfilesys
#@brief   Devuelve la versión del sistema operativo instalado en un sistema de archivos.
#@param   int_ndisk      nº de orden del disco
#@param   int_nfilesys   nº de orden de la partición
#@return  OSType:OSVersion - tipo y versión del sistema operativo.
#@note    OSType = { Android, BSD, GrubLoader, Hurd, Linux, MacOS, Solaris, Windows, WinLoader }
#@note    Requisitos: awk, head, chroot
#@exception OG_ERR_FORMAT    Formato incorrecto.
#@exception OG_ERR_NOTFOUND  Disco o partición no corresponden con un dispositiv
#@exception OG_ERR_PARTITION Fallo al montar el sistema de archivos.
#@version 0.9 - Primera versión para OpenGnSys
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-09-15
#@version 1.0.4 - Incluir tipos BSD, MacOS y Solaris.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2012-06-29
#@version 1.0.5 - Incluir tipos GrubLoader, Hurd y WinLoader, leer por defecto fichero /etc/os-release.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2013-10-07
#@version 1.0.6 - Detectar GrubLoader al final y sistemas basados en EFI.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2014-08-27
#*/ ##
function ogGetOsVersion ()
{
# Variables locales.
local MNTDIR TYPE DISTRIB VERSION IS64BIT FILE
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME int_ndisk int_nfilesys" \
           "$FUNCNAME 1 2  =>  Linux:Ubuntu precise (12.04 LTS) 64 bits"
    return
fi
# Error si no se reciben 2 parametros.
[ $# = 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Montar la particion, si no lo estaba previamente.
MNTDIR=$(ogMount $1 $2) || return $?

# Buscar tipo de sistema operativo.
# Para GNU/Linux: leer descripción.
TYPE="Linux"
FILE="$MNTDIR/etc/os-release"
[ -r $FILE ] && VERSION="$(awk -F= '$1~/PRETTY_NAME/ {gsub(/\"/,"",$2); print $2}' $FILE)"
# Si no se puede obtener, buscar en ficheros del sistema.
if [ -z "$VERSION" ]; then
    FILE="$MNTDIR/etc/lsb-release"
    [ -r $FILE ] && VERSION="$(awk -F= '$1~/DESCRIPTION/ {gsub(/\"/,"",$2); print $2}' $FILE)"
    for DISTRIB in redhat SuSE mandrake gentoo; do
        FILE="$MNTDIR/etc/${DISTRIB}-release"
        [ -r $FILE ] && VERSION="$(head -1 $FILE)"
    done
    FILE="$MNTDIR/etc/arch-release"
    [ -r $FILE ] && VERSION="Arch Linux"
    FILE="$MNTDIR/etc/slackware-version"
    [ -r $FILE ] && VERSION="Slackware $(cat $FILE)"
fi
# Si no se encuentra, intentar ejecutar "lsb_release".
[ -z "$VERSION" ] && VERSION=$(chroot $MNTDIR lsb_release -d 2>/dev/null | awk -F":\t" '{print $2}')
# Comprobar Linux de 64 bits.
[ -n "$VERSION" ] && [ -e $MNTDIR/lib64 ] && IS64BIT="$MSG_64BIT"
# Para Android, leer fichero de propiedades.
if [ -z "$VERSION" ]; then
    TYPE="Android"
    FILE="$MNTDIR/android*/system/build.prop"
    [ -r $FILE ] && VERSION="Android $(awk -F= '$1~/(product.brand|build.version.release)/ {print $2}' $FILE | tr '\n' ' ')"
    [ -e $MNTDIR/lib64 ] && IS64BIT="$MSG_64BIT"
fi
# Para GNU/Hurd, comprobar fichero de inicio (basado en os-prober).
if [ -z "$VERSION" ]; then
    TYPE="Hurd"
    FILE="$MNTDIR/hurd/init"
    [ -r $FILE ] && VERSION="GNU/Hurd"
fi
# Para Windows: leer la version del registro.
if [ -z "$VERSION" ]; then
    TYPE="Windows"
    VERSION=$(ogGetRegistryValue $MNTDIR software '\Microsoft\Windows NT\CurrentVersion\ProductName' 2>/dev/null)
    [ -n "$(ogGetRegistryValue $MNTDIR software '\Microsoft\Windows\CurrentVersion\ProgramW6432Dir' 2>/dev/null)" ] && IS64BIT="$MSG_64BIT"
fi
# Para cargador Windows: buscar versión en fichero BCD (basado en os-prober).
if [ -z "$VERSION" ]; then
    TYPE="WinLoader"
    FILE="$(ogGetPath $MNTDIR/boot/bcd)"
    [ -z "$FILE" ] && FILE="$(ogGetPath $MNTDIR/EFI/Microsoft/boot/bcd)"
    if [ -n "$FILE" ]; then
        for DISTRIB in "Windows Recovery" "Windows Boot"; do
            if grep -qs "$(echo "$DISTRIB" | sed 's/./&./g')" $FILE; then
                VERSION="$DISTRIB loader"
            fi
        done
    fi
fi
# Para MacOS: detectar kernel y completar con fichero plist de información del sistema.
if [ -z "$VERSION" ]; then
    TYPE="MacOS"
    # Kernel de Mac OS (no debe ser fichero de texto).
    FILE="$MNTDIR/mach_kernel"
    if [ -z "$(file -b $FILE | grep 'text')" ]; then
        # Obtener tipo de kernel.
        [ -n "$(file -b $FILE | grep 'Mach-O')" ] && VERSION="Mac OS"
        [ -n "$(file -b $FILE | grep 'Mach-O 64-bit')" ] && IS64BIT="$MSG_64BIT"
        # Datos de configuración de versión de Mac OS.
        FILE="$MNTDIR/System/Library/CoreServices/SystemVersion.plist"
        [ -r $FILE ] && VERSION=$(awk -F"[<>]" '
                                      /ProductName/ {getline;s=$3}
                                      /ProductVersion/ {getline;v=$3}
                                      END {print s,v}' $FILE)
        # Datos de recuperación de Mac OS.
        FILE="$MNTDIR/com.apple.recovery.boot"
        [ -r $FILE -a -n "$VERSION" ] && VERSION="$VERSION recovery"
    fi
fi
# Para FreeBSD: obtener datos del Kernel.
### TODO Revisar solución.
if [ -z "$VERSION" ]; then
    TYPE="BSD"
    FILE="$MNTDIR/boot/kernel/kernel"
    if [ -r $FILE ]; then
        VERSION="$(strings $FILE|awk '/@.*RELEASE/ {print $1,$2}')"
        [ -n "$(file -b $FILE | grep 'x86-64')" ] && IS64BIT="$MSG_64BIT"
    fi
fi
# Para Solaris: leer el fichero de versión.
### TODO Revisar solución.
if [ -z "$VERSION" ]; then
    TYPE="Solaris"
    FILE="$MNTDIR/etc/release"
    [ -r $FILE ] && VERSION="$(head -1 $FILE)"
fi
# Para cargador GRUB, comprobar fichero de configuración.
if [ -z "$VERSION" ]; then
    TYPE="GrubLoader"
    for FILE in $MNTDIR/{,boot/}grub/menu.lst; do
        [ -r $FILE ] && VERSION="GRUB Loader"
    done
    for FILE in $MNTDIR/{,boot/}{grub{,2},EFI/*}/grub.cfg; do
        [ -r $FILE ] && VERSION="GRUB2 Loader"
    done
fi

# Mostrar resultado y salir sin errores.
[ -n "$VERSION" ] && echo "$TYPE:$VERSION $IS64BIT"
return 0
}


#/**
#         ogListHardwareInfo
#@brief   Lista el inventario de hardware de la máquina cliente.
#@return  TipoDispositivo:Modelo    (por determinar)
#@warning Se ignoran los parámetros de entrada.
#@note    TipoDispositivo = { ata, bio, boa, cdr, cpu, dis, fir, mem, mod, mul, net, ser, vga }
#@note    Requisitos: lshw, awk
#@version 0.1 - Primeras pruebas con OpenGnSys
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-07-28
#*/ ##
function ogListHardwareInfo ()
{
# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME"
    return
fi

# Recopilación de disposibivos procesando la salida de \c lshw
ogEcho info "$MSG_HARDWAREINVENTORY}"
lshw | awk 'BEGIN {type="mod";}
	/product:/ {sub(/ *product: */,"");  prod=$0;}
	/vendor:/  {sub(/ *vendor: */,"");   vend=$0;}
	/version:/ {sub(/ *version: */,"v.");vers=$0;}
	/size:/    {sub(/ *size: */,"");     size=$0;}
	/\*-/	   {if (type=="mem")
                    print type"="size;
                else
                    if (type!="" && prod!="")
                        print type"="vend,prod,size,vers;
                type=prod=vend=vers=size="";}
	/-core/    {type="boa";}
	/-firmware/ {type="bio";}
	/-cpu/     {type="cpu";}
	/-memory/  {type="mem";}
	/-ide/     {type="ide";}
	/-disk/    {type="dis";}
	/-cdrom/   {type="cdr";}
	/-display/ {type="vga";}
	/-network/ {type="net";}
	/-multimedia/ {type="mul";}
	/-usb/     {type="usb";}
	/-firewire/ {type="fir";}
	/-serial/  {type="bus";}
	END 	   {if (type!="" && prod!="")
                    print type"="vend,prod,size,vers;}
      '
# */ (comentario para Doxygen)
}


#/**
#         ogListSoftware int_ndisk int_npartition
#@brief   Lista el inventario de software instalado en un sistema operativo.
#@param   int_ndisk      nº de orden del disco
#@param   int_npartition nº de orden de la partición
#@return  programa versión ...
#@warning Se ignoran los parámetros de entrada.
#@note    Requisitos: ...
#@todo    Detectar software en Linux
#@version 0.1 - Primeras pruebas con OpenGnSys
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2009-09-23
#@version 1.0.5 - Aproximación para inventario de software de Mac OS.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2013-10-08
#@version 1.0.6 - Proceso depende del tipo de SO y sporte para FreeBSD.
#@author  Ramon Gomez, ETSII Universidad de Sevilla
#@date    2014-11-13
#*/ ##
function ogListSoftware ()
{
# Variables locales.
local MNTDIR TYPE DPKGDIR RPMDIR PACMANDIR KEYS KEYS32 k PROG VERS

# Si se solicita, mostrar ayuda.
if [ "$*" == "help" ]; then
    ogHelp "$FUNCNAME" "$FUNCNAME 1 1"
    return
fi
# Error si no se reciben 2 parametros.
[ $# = 2 ] || ogRaiseError $OG_ERR_FORMAT || return $?

# Obtener tipo de sistema de archivos y montarlo.
MNTDIR=$(ogMount $1 $2) || return $?
TYPE=$(ogGetOsType $1 $2) || return $?

case "$TYPE" in
    Linux)          # Software de GNU/Linux.
        # Procesar paquetes dpkg.
        DPKGDIR="${MNTDIR}/var/lib/dpkg"
        if [ -r $DPKGDIR ]; then
        #    dpkg --admindir=$DPKGDIR -l | \
            # Proceso de fichero en sistemas de 64 bits.
            if [ -e $MNTDIR/lib64 ]; then
                awk '/Package:/ {if (pack!="") print pack,vers;
                                 sub(/-dev$/,"",$2);
                                 pack=$2}
                     /Version:/ {sub(/^.*:/,"",$2); sub(/-.*$/,"",$2);
                                 vers=$2}
                     /Status:/  {if ($2!="install") pack=vers=""}
                     END        {if (pack!="") print pack,vers}
                    ' $DPKGDIR/status | sort | uniq
            else
                # FIXME Sólo 32 bits
                chroot "$MNTDIR" /usr/bin/dpkg -l | \
                    awk '$1~/ii/ {sub(/-dev$/,"",$2); sub(/^.*:/,"",$3);
                                  sub(/-.*$/,"",$3); print $2,$3}
                        ' | sort | uniq
            fi
        fi
        # Procesar paquetes RPM.
        RPMDIR="${MNTDIR}/var/lib/rpm"
        if [ -r $RPMDIR ]; then
            # Listar si está instalado el paquete "rpm" en el cliente.
            if which rpm &>/dev/null; then
                rm -f ${RPMDIR}/__db.*
                rpm --dbpath $RPMDIR -qa --qf "%{NAME} %{VERSION}\n" 2>/dev/null | \
                    awk '$1!~/-devel$/ {sub(/-.*$/,"",$2); print $0}' | sort | uniq
                rm -f ${RPMDIR}/__db.*
            else
                # Obtener el nombre de cada paquete en la BD de RPM.
                python <<<"
import re;
import bsddb;
db=bsddb.hashopen('$RPMDIR/Name','r');
for k in db.keys():
    print re.sub('-devel$','',k);" | sort | uniq
            fi
        fi
        # Procesar paquetes pacman.
        PACMANDIR="${MNTDIR}/var/lib/pacman/local"
        if [ -r $PACMANDIR ]; then
            # FIXME Separar nombre y versión de los paquetes
            ls -A $PACMANDIR
        fi
        ;;
    Windows)        # Software de Windows.
        # Claves de registro para programas instalados: formato "{clave}".
        KEYS=$(ogListRegistryKeys $MNTDIR software '\Microsoft\Windows\CurrentVersion\Uninstall')
        KEYS32=$(ogListRegistryKeys $MNTDIR software '\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall')
        # Mostrar los valores "DisplayName" y "DisplayVersion" para cada clave.
        (for k in $KEYS; do
            PROG=$(ogGetRegistryValue $MNTDIR software "\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$k\\DisplayName")
            if [ -n "$PROG" ]; then
                VERS=$(ogGetRegistryValue $MNTDIR software "\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$k\\DisplayVersion")
                echo "$PROG $VERS"
            fi
        done
        for k in $KEYS32; do
            PROG=$(ogGetRegistryValue $MNTDIR software "\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$k\\DisplayName")
            if [ -n "$PROG" ]; then
                VERS=$(ogGetRegistryValue $MNTDIR software "\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\$k\\DisplayVersion")
                echo "$PROG $VERS"
            fi
        done) | sort | uniq
        ;;
    MacOS)          # Software de Mac OS.
        # Listar directorios de aplicaciones e intentar obtener la versión del fichero .plist (tanto original como descomprimido).
        find "${MNTDIR}/Applications" -type d -name "*.app" -prune -print | \
                while read k; do
                    FILE="$k/Contents/version.plist"
                    [ -s "$FILE" ] || FILE="$k/Contents/version.plist.uncompress"
                    [ -s "$FILE" ] && VERSION=$(awk -F"[<>]" '/ShortVersionString/ {getline;v=$3}
                                                              END {print v}' "$FILE")
                    echo "$(basename "$k" .app) $VERSION"
                done | sort
        ;;
    BSD)            # Software de FreeBSD.
        sqlite3 $MNTDIR/var/db/pkg/local.sqlite <<<"SELECT name FROM pkg_search;" 2>/dev/null | \
                sed 's/\(.*\)-\(.*\)/\1 \2/g' | sort
        ;;
    *)  ogRaiseError $OG_ERR_PARTITION "$1, $2"
        return $? ;;
esac
}


#/**  @function ogInfoCache: @brief muestra la informacion de la CACHE.
#@param  sin parametros
#@return  texto que se almacena en $IP.-InfoCache.  punto_montaje, tama?oTotal, TamanioOcupado, TaminioLibre, imagenes dentro de la cahce
#@warning  Salidas de errores no determinada
#@warning   printf no soportado por busybox
#@attention
#@version 0.1	Date: 27/10/2008 Author Antonio J. Doblas Viso. Universidad de Malaga
#*/
function ogInfoCache ()
{
local info infoFilesystem infoSize infoUsed infoUsedPorcet infoMountedOn content
if ogMountCache
then
	info=`df -h | grep $OGCAC`
	infoFilesystem=`echo $info | cut -f1 -d" "`
	infoSize=`echo $info | cut -f2 -d" "`
	infoUsed=`echo $info | cut -f3 -d" "`
	infoAvail=`echo $info | cut -f4 -d" "`
	infoUsedPorcet=`echo $info | cut -f5 -d" "`
	infoMountedOn=`echo $info | cut -f2 -d" "`
        if `ls  ${OGCAC}$OGIMG > /dev/null 2>&1`
	then
	       cd ${OGCAC}${OPENGNSYS}
		#content=`find images/ -type f -printf "%h/  %f  %s \n"`   busybox no soporta printf
		content=`find images/ -type f`
		cd /
		echo $info
		echo -ne $content
		echo " "
		#echo "$info" > ${OGLOG}/${IP}-InfoCache
		#echo "$content" >> {$OGLOG}/${IP}-InfoCache
	else
		echo $info
		#echo "$info" > {$OGLOG}/${IP}-InfoCache
	fi
	ogUnmountCache
else
	echo " "
	#echo " " > {$OGLOG}/${IP}-InfoCache

fi
}

